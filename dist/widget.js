
// 自动注入样式
(function() {
  var style = document.createElement('style');
  style.textContent = `.w-100[data-v-b6253ea0] {
  font-weight: 100;
}
.w-200[data-v-b6253ea0] {
  font-weight: 200;
}
.w-300[data-v-b6253ea0] {
  font-weight: 300;
}
.w-400[data-v-b6253ea0] {
  font-weight: 400;
}
.w-500[data-v-b6253ea0] {
  font-weight: 500;
}
.w-600[data-v-b6253ea0] {
  font-weight: 600;
}
.w-700[data-v-b6253ea0] {
  font-weight: 700;
}
.w-800[data-v-b6253ea0] {
  font-weight: 800;
}
.w-900[data-v-b6253ea0] {
  font-weight: 900;
}
html[data-v-b6253ea0] {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.s-8[data-v-b6253ea0] {
  font-size: 8px;
}
.s-10[data-v-b6253ea0] {
  font-size: 10px;
}
.s-12[data-v-b6253ea0] {
  font-size: 12px;
}
.s-13[data-v-b6253ea0] {
  font-size: 13px;
}
.s-14[data-v-b6253ea0] {
  font-size: 14px;
}
.s-16[data-v-b6253ea0] {
  font-size: 16px;
}
.s-18[data-v-b6253ea0] {
  font-size: 18px;
}
.s-20[data-v-b6253ea0] {
  font-size: 20px;
}
.s-22[data-v-b6253ea0] {
  font-size: 22px;
}
.s-24[data-v-b6253ea0] {
  font-size: 24px;
}
.s-32[data-v-b6253ea0] {
  font-size: 32px;
}
.s-36[data-v-b6253ea0] {
  font-size: 36px;
}
.s-40[data-v-b6253ea0] {
  font-size: 40px;
}
.l-8[data-v-b6253ea0] {
  line-height: 8px;
}
.l-10[data-v-b6253ea0] {
  line-height: 10px;
}
.l-12[data-v-b6253ea0] {
  line-height: 12px;
}
.l-13[data-v-b6253ea0] {
  line-height: 13px;
}
.l-14[data-v-b6253ea0] {
  line-height: 14px;
}
.l-16[data-v-b6253ea0] {
  line-height: 16px;
}
.l-18[data-v-b6253ea0] {
  line-height: 18px;
}
.l-20[data-v-b6253ea0] {
  line-height: 20px;
}
.l-22[data-v-b6253ea0] {
  line-height: 22px;
}
.l-24[data-v-b6253ea0] {
  line-height: 24px;
}
.l-32[data-v-b6253ea0] {
  line-height: 32px;
}
.l-36[data-v-b6253ea0] {
  line-height: 36px;
}
.l-40[data-v-b6253ea0] {
  line-height: 40px;
}
.mt-0[data-v-b6253ea0] {
  margin-top: 0px;
}
.mt-1[data-v-b6253ea0] {
  margin-top: 1px;
}
.mt-2[data-v-b6253ea0] {
  margin-top: 2px;
}
.mt-3[data-v-b6253ea0] {
  margin-top: 3px;
}
.mt-4[data-v-b6253ea0] {
  margin-top: 4px;
}
.mt-5[data-v-b6253ea0] {
  margin-top: 5px;
}
.mt-6[data-v-b6253ea0] {
  margin-top: 6px;
}
.mt-7[data-v-b6253ea0] {
  margin-top: 7px;
}
.mt-8[data-v-b6253ea0] {
  margin-top: 8px;
}
.mt-9[data-v-b6253ea0] {
  margin-top: 9px;
}
.mt-10[data-v-b6253ea0] {
  margin-top: 10px;
}
.mt-12[data-v-b6253ea0] {
  margin-top: 12px;
}
.mt-14[data-v-b6253ea0] {
  margin-top: 14px;
}
.mt-16[data-v-b6253ea0] {
  margin-top: 16px;
}
.mt-18[data-v-b6253ea0] {
  margin-top: 18px;
}
.mt-20[data-v-b6253ea0] {
  margin-top: 20px;
}
.mt-22[data-v-b6253ea0] {
  margin-top: 22px;
}
.mt-24[data-v-b6253ea0] {
  margin-top: 24px;
}
.mt-26[data-v-b6253ea0] {
  margin-top: 26px;
}
.mt-28[data-v-b6253ea0] {
  margin-top: 28px;
}
.mt-30[data-v-b6253ea0] {
  margin-top: 30px;
}
.mt-32[data-v-b6253ea0] {
  margin-top: 32px;
}
.mt-34[data-v-b6253ea0] {
  margin-top: 34px;
}
.mt-36[data-v-b6253ea0] {
  margin-top: 36px;
}
.mb-0[data-v-b6253ea0] {
  margin-bottom: 0px;
}
.mb-1[data-v-b6253ea0] {
  margin-bottom: 1px;
}
.mb-2[data-v-b6253ea0] {
  margin-bottom: 2px;
}
.mb-3[data-v-b6253ea0] {
  margin-bottom: 3px;
}
.mb-4[data-v-b6253ea0] {
  margin-bottom: 4px;
}
.mb-5[data-v-b6253ea0] {
  margin-bottom: 5px;
}
.mb-6[data-v-b6253ea0] {
  margin-bottom: 6px;
}
.mb-7[data-v-b6253ea0] {
  margin-bottom: 7px;
}
.mb-8[data-v-b6253ea0] {
  margin-bottom: 8px;
}
.mb-9[data-v-b6253ea0] {
  margin-bottom: 9px;
}
.mb-10[data-v-b6253ea0] {
  margin-bottom: 10px;
}
.mb-12[data-v-b6253ea0] {
  margin-bottom: 12px;
}
.mb-14[data-v-b6253ea0] {
  margin-bottom: 14px;
}
.mb-16[data-v-b6253ea0] {
  margin-bottom: 16px;
}
.mb-18[data-v-b6253ea0] {
  margin-bottom: 18px;
}
.mb-20[data-v-b6253ea0] {
  margin-bottom: 20px;
}
.mb-22[data-v-b6253ea0] {
  margin-bottom: 22px;
}
.mb-24[data-v-b6253ea0] {
  margin-bottom: 24px;
}
.mb-26[data-v-b6253ea0] {
  margin-bottom: 26px;
}
.mb-28[data-v-b6253ea0] {
  margin-bottom: 28px;
}
.mb-30[data-v-b6253ea0] {
  margin-bottom: 30px;
}
.mb-32[data-v-b6253ea0] {
  margin-bottom: 32px;
}
.mb-34[data-v-b6253ea0] {
  margin-bottom: 34px;
}
.mb-36[data-v-b6253ea0] {
  margin-bottom: 36px;
}
.ml-0[data-v-b6253ea0] {
  margin-left: 0px;
}
.ml-1[data-v-b6253ea0] {
  margin-left: 1px;
}
.ml-2[data-v-b6253ea0] {
  margin-left: 2px;
}
.ml-3[data-v-b6253ea0] {
  margin-left: 3px;
}
.ml-4[data-v-b6253ea0] {
  margin-left: 4px;
}
.ml-5[data-v-b6253ea0] {
  margin-left: 5px;
}
.ml-6[data-v-b6253ea0] {
  margin-left: 6px;
}
.ml-7[data-v-b6253ea0] {
  margin-left: 7px;
}
.ml-8[data-v-b6253ea0] {
  margin-left: 8px;
}
.ml-9[data-v-b6253ea0] {
  margin-left: 9px;
}
.ml-10[data-v-b6253ea0] {
  margin-left: 10px;
}
.ml-12[data-v-b6253ea0] {
  margin-left: 12px;
}
.ml-14[data-v-b6253ea0] {
  margin-left: 14px;
}
.ml-16[data-v-b6253ea0] {
  margin-left: 16px;
}
.ml-18[data-v-b6253ea0] {
  margin-left: 18px;
}
.ml-20[data-v-b6253ea0] {
  margin-left: 20px;
}
.ml-22[data-v-b6253ea0] {
  margin-left: 22px;
}
.ml-24[data-v-b6253ea0] {
  margin-left: 24px;
}
.ml-26[data-v-b6253ea0] {
  margin-left: 26px;
}
.ml-28[data-v-b6253ea0] {
  margin-left: 28px;
}
.ml-30[data-v-b6253ea0] {
  margin-left: 30px;
}
.ml-32[data-v-b6253ea0] {
  margin-left: 32px;
}
.ml-34[data-v-b6253ea0] {
  margin-left: 34px;
}
.ml-36[data-v-b6253ea0] {
  margin-left: 36px;
}
.mr-0[data-v-b6253ea0] {
  margin-right: 0px;
}
.mr-1[data-v-b6253ea0] {
  margin-right: 1px;
}
.mr-2[data-v-b6253ea0] {
  margin-right: 2px;
}
.mr-3[data-v-b6253ea0] {
  margin-right: 3px;
}
.mr-4[data-v-b6253ea0] {
  margin-right: 4px;
}
.mr-5[data-v-b6253ea0] {
  margin-right: 5px;
}
.mr-6[data-v-b6253ea0] {
  margin-right: 6px;
}
.mr-7[data-v-b6253ea0] {
  margin-right: 7px;
}
.mr-8[data-v-b6253ea0] {
  margin-right: 8px;
}
.mr-9[data-v-b6253ea0] {
  margin-right: 9px;
}
.mr-10[data-v-b6253ea0] {
  margin-right: 10px;
}
.mr-12[data-v-b6253ea0] {
  margin-right: 12px;
}
.mr-14[data-v-b6253ea0] {
  margin-right: 14px;
}
.mr-16[data-v-b6253ea0] {
  margin-right: 16px;
}
.mr-18[data-v-b6253ea0] {
  margin-right: 18px;
}
.mr-20[data-v-b6253ea0] {
  margin-right: 20px;
}
.mr-22[data-v-b6253ea0] {
  margin-right: 22px;
}
.mr-24[data-v-b6253ea0] {
  margin-right: 24px;
}
.mr-26[data-v-b6253ea0] {
  margin-right: 26px;
}
.mr-28[data-v-b6253ea0] {
  margin-right: 28px;
}
.mr-30[data-v-b6253ea0] {
  margin-right: 30px;
}
.mr-32[data-v-b6253ea0] {
  margin-right: 32px;
}
.mr-34[data-v-b6253ea0] {
  margin-right: 34px;
}
.mr-36[data-v-b6253ea0] {
  margin-right: 36px;
}
.pt-0[data-v-b6253ea0] {
  padding-top: 0px;
}
.pt-1[data-v-b6253ea0] {
  padding-top: 1px;
}
.pt-2[data-v-b6253ea0] {
  padding-top: 2px;
}
.pt-3[data-v-b6253ea0] {
  padding-top: 3px;
}
.pt-4[data-v-b6253ea0] {
  padding-top: 4px;
}
.pt-5[data-v-b6253ea0] {
  padding-top: 5px;
}
.pt-6[data-v-b6253ea0] {
  padding-top: 6px;
}
.pt-7[data-v-b6253ea0] {
  padding-top: 7px;
}
.pt-8[data-v-b6253ea0] {
  padding-top: 8px;
}
.pt-9[data-v-b6253ea0] {
  padding-top: 9px;
}
.pt-10[data-v-b6253ea0] {
  padding-top: 10px;
}
.pt-12[data-v-b6253ea0] {
  padding-top: 12px;
}
.pt-14[data-v-b6253ea0] {
  padding-top: 14px;
}
.pt-16[data-v-b6253ea0] {
  padding-top: 16px;
}
.pt-18[data-v-b6253ea0] {
  padding-top: 18px;
}
.pt-20[data-v-b6253ea0] {
  padding-top: 20px;
}
.pt-22[data-v-b6253ea0] {
  padding-top: 22px;
}
.pt-24[data-v-b6253ea0] {
  padding-top: 24px;
}
.pt-26[data-v-b6253ea0] {
  padding-top: 26px;
}
.pt-28[data-v-b6253ea0] {
  padding-top: 28px;
}
.pt-30[data-v-b6253ea0] {
  padding-top: 30px;
}
.pt-32[data-v-b6253ea0] {
  padding-top: 32px;
}
.pt-34[data-v-b6253ea0] {
  padding-top: 34px;
}
.pt-36[data-v-b6253ea0] {
  padding-top: 36px;
}
.pb-0[data-v-b6253ea0] {
  padding-bottom: 0px;
}
.pb-1[data-v-b6253ea0] {
  padding-bottom: 1px;
}
.pb-2[data-v-b6253ea0] {
  padding-bottom: 2px;
}
.pb-3[data-v-b6253ea0] {
  padding-bottom: 3px;
}
.pb-4[data-v-b6253ea0] {
  padding-bottom: 4px;
}
.pb-5[data-v-b6253ea0] {
  padding-bottom: 5px;
}
.pb-6[data-v-b6253ea0] {
  padding-bottom: 6px;
}
.pb-7[data-v-b6253ea0] {
  padding-bottom: 7px;
}
.pb-8[data-v-b6253ea0] {
  padding-bottom: 8px;
}
.pb-9[data-v-b6253ea0] {
  padding-bottom: 9px;
}
.pb-10[data-v-b6253ea0] {
  padding-bottom: 10px;
}
.pb-12[data-v-b6253ea0] {
  padding-bottom: 12px;
}
.pb-14[data-v-b6253ea0] {
  padding-bottom: 14px;
}
.pb-16[data-v-b6253ea0] {
  padding-bottom: 16px;
}
.pb-18[data-v-b6253ea0] {
  padding-bottom: 18px;
}
.pb-20[data-v-b6253ea0] {
  padding-bottom: 20px;
}
.pb-22[data-v-b6253ea0] {
  padding-bottom: 22px;
}
.pb-24[data-v-b6253ea0] {
  padding-bottom: 24px;
}
.pb-26[data-v-b6253ea0] {
  padding-bottom: 26px;
}
.pb-28[data-v-b6253ea0] {
  padding-bottom: 28px;
}
.pb-30[data-v-b6253ea0] {
  padding-bottom: 30px;
}
.pb-32[data-v-b6253ea0] {
  padding-bottom: 32px;
}
.pb-34[data-v-b6253ea0] {
  padding-bottom: 34px;
}
.pb-36[data-v-b6253ea0] {
  padding-bottom: 36px;
}
.pl-0[data-v-b6253ea0] {
  padding-left: 0px;
}
.pl-1[data-v-b6253ea0] {
  padding-left: 1px;
}
.pl-2[data-v-b6253ea0] {
  padding-left: 2px;
}
.pl-3[data-v-b6253ea0] {
  padding-left: 3px;
}
.pl-4[data-v-b6253ea0] {
  padding-left: 4px;
}
.pl-5[data-v-b6253ea0] {
  padding-left: 5px;
}
.pl-6[data-v-b6253ea0] {
  padding-left: 6px;
}
.pl-7[data-v-b6253ea0] {
  padding-left: 7px;
}
.pl-8[data-v-b6253ea0] {
  padding-left: 8px;
}
.pl-9[data-v-b6253ea0] {
  padding-left: 9px;
}
.pl-10[data-v-b6253ea0] {
  padding-left: 10px;
}
.pl-12[data-v-b6253ea0] {
  padding-left: 12px;
}
.pl-14[data-v-b6253ea0] {
  padding-left: 14px;
}
.pl-16[data-v-b6253ea0] {
  padding-left: 16px;
}
.pl-18[data-v-b6253ea0] {
  padding-left: 18px;
}
.pl-20[data-v-b6253ea0] {
  padding-left: 20px;
}
.pl-22[data-v-b6253ea0] {
  padding-left: 22px;
}
.pl-24[data-v-b6253ea0] {
  padding-left: 24px;
}
.pl-26[data-v-b6253ea0] {
  padding-left: 26px;
}
.pl-28[data-v-b6253ea0] {
  padding-left: 28px;
}
.pl-30[data-v-b6253ea0] {
  padding-left: 30px;
}
.pl-32[data-v-b6253ea0] {
  padding-left: 32px;
}
.pl-34[data-v-b6253ea0] {
  padding-left: 34px;
}
.pl-36[data-v-b6253ea0] {
  padding-left: 36px;
}
.pr-0[data-v-b6253ea0] {
  padding-right: 0px;
}
.pr-1[data-v-b6253ea0] {
  padding-right: 1px;
}
.pr-2[data-v-b6253ea0] {
  padding-right: 2px;
}
.pr-3[data-v-b6253ea0] {
  padding-right: 3px;
}
.pr-4[data-v-b6253ea0] {
  padding-right: 4px;
}
.pr-5[data-v-b6253ea0] {
  padding-right: 5px;
}
.pr-6[data-v-b6253ea0] {
  padding-right: 6px;
}
.pr-7[data-v-b6253ea0] {
  padding-right: 7px;
}
.pr-8[data-v-b6253ea0] {
  padding-right: 8px;
}
.pr-9[data-v-b6253ea0] {
  padding-right: 9px;
}
.pr-10[data-v-b6253ea0] {
  padding-right: 10px;
}
.pr-12[data-v-b6253ea0] {
  padding-right: 12px;
}
.pr-14[data-v-b6253ea0] {
  padding-right: 14px;
}
.pr-16[data-v-b6253ea0] {
  padding-right: 16px;
}
.pr-18[data-v-b6253ea0] {
  padding-right: 18px;
}
.pr-20[data-v-b6253ea0] {
  padding-right: 20px;
}
.pr-22[data-v-b6253ea0] {
  padding-right: 22px;
}
.pr-24[data-v-b6253ea0] {
  padding-right: 24px;
}
.pr-26[data-v-b6253ea0] {
  padding-right: 26px;
}
.pr-28[data-v-b6253ea0] {
  padding-right: 28px;
}
.pr-30[data-v-b6253ea0] {
  padding-right: 30px;
}
.pr-32[data-v-b6253ea0] {
  padding-right: 32px;
}
.pr-34[data-v-b6253ea0] {
  padding-right: 34px;
}
.pr-36[data-v-b6253ea0] {
  padding-right: 36px;
}
html[data-v-b6253ea0] {
  --primary-color: #00703d;
  --primary-disabled-color: #99c6b1;
  --primary-bg-color: #edf8ef;
  --white: white;
  --primary-color-20: #00703d33;
  --brand-4: #00703d22;
  --text-1: #1d2920;
  --text-2: #616961;
  --text-3: #979c98;
  --text-4: #b8bbb8;
  --text-blue: #3c68bf;
  --text-red: #d16559;
  --neutral-fill-1: #f8f9f8;
  --neutral-fill-2: #f1f3f1;
  --neutral-fill-3: #e0e3e0;
  --neutral-border: #f2f2f2;
  --neutral-icon: #696d69;
  --blue-bg-color: #f2f7f9;
  --red-bg-color: #fdf2f0;
  --error-1: #e4000c;
  --error-2: #fff3f4;
  --warn-1: #e88e00;
  --warn-2: #fff6e7;
  --antd-wave-shadow-color: var(--primary-color) !important;
}
span[data-v-b6253ea0] {
  color: var(--text-1);
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
}
.text-1[data-v-b6253ea0] {
  color: var(--text-1);
}
.text-2[data-v-b6253ea0] {
  color: var(--text-2);
}
.text-3[data-v-b6253ea0] {
  color: var(--text-3);
}
.text-4[data-v-b6253ea0] {
  color: var(--text-4);
}
.white[data-v-b6253ea0] {
  color: var(--white);
}
.primary-color[data-v-b6253ea0] {
  color: var(--primary-color);
}
.error-color[data-v-b6253ea0] {
  color: var(--error-1);
}
.neutral-icon[data-v-b6253ea0] {
  color: var(--neutral-icon);
}
.small-icon-button[data-v-b6253ea0] {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  height: 16px;
  cursor: pointer;
}
.small-icon-button[data-v-b6253ea0]:hover {
  scale: 1.05;
}
.w-100[data-v-e2e9113f] {
  font-weight: 100;
}
.w-200[data-v-e2e9113f] {
  font-weight: 200;
}
.w-300[data-v-e2e9113f] {
  font-weight: 300;
}
.w-400[data-v-e2e9113f] {
  font-weight: 400;
}
.w-500[data-v-e2e9113f] {
  font-weight: 500;
}
.w-600[data-v-e2e9113f] {
  font-weight: 600;
}
.w-700[data-v-e2e9113f] {
  font-weight: 700;
}
.w-800[data-v-e2e9113f] {
  font-weight: 800;
}
.w-900[data-v-e2e9113f] {
  font-weight: 900;
}
html[data-v-e2e9113f] {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.s-8[data-v-e2e9113f] {
  font-size: 8px;
}
.s-10[data-v-e2e9113f] {
  font-size: 10px;
}
.s-12[data-v-e2e9113f] {
  font-size: 12px;
}
.s-13[data-v-e2e9113f] {
  font-size: 13px;
}
.s-14[data-v-e2e9113f] {
  font-size: 14px;
}
.s-16[data-v-e2e9113f] {
  font-size: 16px;
}
.s-18[data-v-e2e9113f] {
  font-size: 18px;
}
.s-20[data-v-e2e9113f] {
  font-size: 20px;
}
.s-22[data-v-e2e9113f] {
  font-size: 22px;
}
.s-24[data-v-e2e9113f] {
  font-size: 24px;
}
.s-32[data-v-e2e9113f] {
  font-size: 32px;
}
.s-36[data-v-e2e9113f] {
  font-size: 36px;
}
.s-40[data-v-e2e9113f] {
  font-size: 40px;
}
.l-8[data-v-e2e9113f] {
  line-height: 8px;
}
.l-10[data-v-e2e9113f] {
  line-height: 10px;
}
.l-12[data-v-e2e9113f] {
  line-height: 12px;
}
.l-13[data-v-e2e9113f] {
  line-height: 13px;
}
.l-14[data-v-e2e9113f] {
  line-height: 14px;
}
.l-16[data-v-e2e9113f] {
  line-height: 16px;
}
.l-18[data-v-e2e9113f] {
  line-height: 18px;
}
.l-20[data-v-e2e9113f] {
  line-height: 20px;
}
.l-22[data-v-e2e9113f] {
  line-height: 22px;
}
.l-24[data-v-e2e9113f] {
  line-height: 24px;
}
.l-32[data-v-e2e9113f] {
  line-height: 32px;
}
.l-36[data-v-e2e9113f] {
  line-height: 36px;
}
.l-40[data-v-e2e9113f] {
  line-height: 40px;
}
.mt-0[data-v-e2e9113f] {
  margin-top: 0px;
}
.mt-1[data-v-e2e9113f] {
  margin-top: 1px;
}
.mt-2[data-v-e2e9113f] {
  margin-top: 2px;
}
.mt-3[data-v-e2e9113f] {
  margin-top: 3px;
}
.mt-4[data-v-e2e9113f] {
  margin-top: 4px;
}
.mt-5[data-v-e2e9113f] {
  margin-top: 5px;
}
.mt-6[data-v-e2e9113f] {
  margin-top: 6px;
}
.mt-7[data-v-e2e9113f] {
  margin-top: 7px;
}
.mt-8[data-v-e2e9113f] {
  margin-top: 8px;
}
.mt-9[data-v-e2e9113f] {
  margin-top: 9px;
}
.mt-10[data-v-e2e9113f] {
  margin-top: 10px;
}
.mt-12[data-v-e2e9113f] {
  margin-top: 12px;
}
.mt-14[data-v-e2e9113f] {
  margin-top: 14px;
}
.mt-16[data-v-e2e9113f] {
  margin-top: 16px;
}
.mt-18[data-v-e2e9113f] {
  margin-top: 18px;
}
.mt-20[data-v-e2e9113f] {
  margin-top: 20px;
}
.mt-22[data-v-e2e9113f] {
  margin-top: 22px;
}
.mt-24[data-v-e2e9113f] {
  margin-top: 24px;
}
.mt-26[data-v-e2e9113f] {
  margin-top: 26px;
}
.mt-28[data-v-e2e9113f] {
  margin-top: 28px;
}
.mt-30[data-v-e2e9113f] {
  margin-top: 30px;
}
.mt-32[data-v-e2e9113f] {
  margin-top: 32px;
}
.mt-34[data-v-e2e9113f] {
  margin-top: 34px;
}
.mt-36[data-v-e2e9113f] {
  margin-top: 36px;
}
.mb-0[data-v-e2e9113f] {
  margin-bottom: 0px;
}
.mb-1[data-v-e2e9113f] {
  margin-bottom: 1px;
}
.mb-2[data-v-e2e9113f] {
  margin-bottom: 2px;
}
.mb-3[data-v-e2e9113f] {
  margin-bottom: 3px;
}
.mb-4[data-v-e2e9113f] {
  margin-bottom: 4px;
}
.mb-5[data-v-e2e9113f] {
  margin-bottom: 5px;
}
.mb-6[data-v-e2e9113f] {
  margin-bottom: 6px;
}
.mb-7[data-v-e2e9113f] {
  margin-bottom: 7px;
}
.mb-8[data-v-e2e9113f] {
  margin-bottom: 8px;
}
.mb-9[data-v-e2e9113f] {
  margin-bottom: 9px;
}
.mb-10[data-v-e2e9113f] {
  margin-bottom: 10px;
}
.mb-12[data-v-e2e9113f] {
  margin-bottom: 12px;
}
.mb-14[data-v-e2e9113f] {
  margin-bottom: 14px;
}
.mb-16[data-v-e2e9113f] {
  margin-bottom: 16px;
}
.mb-18[data-v-e2e9113f] {
  margin-bottom: 18px;
}
.mb-20[data-v-e2e9113f] {
  margin-bottom: 20px;
}
.mb-22[data-v-e2e9113f] {
  margin-bottom: 22px;
}
.mb-24[data-v-e2e9113f] {
  margin-bottom: 24px;
}
.mb-26[data-v-e2e9113f] {
  margin-bottom: 26px;
}
.mb-28[data-v-e2e9113f] {
  margin-bottom: 28px;
}
.mb-30[data-v-e2e9113f] {
  margin-bottom: 30px;
}
.mb-32[data-v-e2e9113f] {
  margin-bottom: 32px;
}
.mb-34[data-v-e2e9113f] {
  margin-bottom: 34px;
}
.mb-36[data-v-e2e9113f] {
  margin-bottom: 36px;
}
.ml-0[data-v-e2e9113f] {
  margin-left: 0px;
}
.ml-1[data-v-e2e9113f] {
  margin-left: 1px;
}
.ml-2[data-v-e2e9113f] {
  margin-left: 2px;
}
.ml-3[data-v-e2e9113f] {
  margin-left: 3px;
}
.ml-4[data-v-e2e9113f] {
  margin-left: 4px;
}
.ml-5[data-v-e2e9113f] {
  margin-left: 5px;
}
.ml-6[data-v-e2e9113f] {
  margin-left: 6px;
}
.ml-7[data-v-e2e9113f] {
  margin-left: 7px;
}
.ml-8[data-v-e2e9113f] {
  margin-left: 8px;
}
.ml-9[data-v-e2e9113f] {
  margin-left: 9px;
}
.ml-10[data-v-e2e9113f] {
  margin-left: 10px;
}
.ml-12[data-v-e2e9113f] {
  margin-left: 12px;
}
.ml-14[data-v-e2e9113f] {
  margin-left: 14px;
}
.ml-16[data-v-e2e9113f] {
  margin-left: 16px;
}
.ml-18[data-v-e2e9113f] {
  margin-left: 18px;
}
.ml-20[data-v-e2e9113f] {
  margin-left: 20px;
}
.ml-22[data-v-e2e9113f] {
  margin-left: 22px;
}
.ml-24[data-v-e2e9113f] {
  margin-left: 24px;
}
.ml-26[data-v-e2e9113f] {
  margin-left: 26px;
}
.ml-28[data-v-e2e9113f] {
  margin-left: 28px;
}
.ml-30[data-v-e2e9113f] {
  margin-left: 30px;
}
.ml-32[data-v-e2e9113f] {
  margin-left: 32px;
}
.ml-34[data-v-e2e9113f] {
  margin-left: 34px;
}
.ml-36[data-v-e2e9113f] {
  margin-left: 36px;
}
.mr-0[data-v-e2e9113f] {
  margin-right: 0px;
}
.mr-1[data-v-e2e9113f] {
  margin-right: 1px;
}
.mr-2[data-v-e2e9113f] {
  margin-right: 2px;
}
.mr-3[data-v-e2e9113f] {
  margin-right: 3px;
}
.mr-4[data-v-e2e9113f] {
  margin-right: 4px;
}
.mr-5[data-v-e2e9113f] {
  margin-right: 5px;
}
.mr-6[data-v-e2e9113f] {
  margin-right: 6px;
}
.mr-7[data-v-e2e9113f] {
  margin-right: 7px;
}
.mr-8[data-v-e2e9113f] {
  margin-right: 8px;
}
.mr-9[data-v-e2e9113f] {
  margin-right: 9px;
}
.mr-10[data-v-e2e9113f] {
  margin-right: 10px;
}
.mr-12[data-v-e2e9113f] {
  margin-right: 12px;
}
.mr-14[data-v-e2e9113f] {
  margin-right: 14px;
}
.mr-16[data-v-e2e9113f] {
  margin-right: 16px;
}
.mr-18[data-v-e2e9113f] {
  margin-right: 18px;
}
.mr-20[data-v-e2e9113f] {
  margin-right: 20px;
}
.mr-22[data-v-e2e9113f] {
  margin-right: 22px;
}
.mr-24[data-v-e2e9113f] {
  margin-right: 24px;
}
.mr-26[data-v-e2e9113f] {
  margin-right: 26px;
}
.mr-28[data-v-e2e9113f] {
  margin-right: 28px;
}
.mr-30[data-v-e2e9113f] {
  margin-right: 30px;
}
.mr-32[data-v-e2e9113f] {
  margin-right: 32px;
}
.mr-34[data-v-e2e9113f] {
  margin-right: 34px;
}
.mr-36[data-v-e2e9113f] {
  margin-right: 36px;
}
.pt-0[data-v-e2e9113f] {
  padding-top: 0px;
}
.pt-1[data-v-e2e9113f] {
  padding-top: 1px;
}
.pt-2[data-v-e2e9113f] {
  padding-top: 2px;
}
.pt-3[data-v-e2e9113f] {
  padding-top: 3px;
}
.pt-4[data-v-e2e9113f] {
  padding-top: 4px;
}
.pt-5[data-v-e2e9113f] {
  padding-top: 5px;
}
.pt-6[data-v-e2e9113f] {
  padding-top: 6px;
}
.pt-7[data-v-e2e9113f] {
  padding-top: 7px;
}
.pt-8[data-v-e2e9113f] {
  padding-top: 8px;
}
.pt-9[data-v-e2e9113f] {
  padding-top: 9px;
}
.pt-10[data-v-e2e9113f] {
  padding-top: 10px;
}
.pt-12[data-v-e2e9113f] {
  padding-top: 12px;
}
.pt-14[data-v-e2e9113f] {
  padding-top: 14px;
}
.pt-16[data-v-e2e9113f] {
  padding-top: 16px;
}
.pt-18[data-v-e2e9113f] {
  padding-top: 18px;
}
.pt-20[data-v-e2e9113f] {
  padding-top: 20px;
}
.pt-22[data-v-e2e9113f] {
  padding-top: 22px;
}
.pt-24[data-v-e2e9113f] {
  padding-top: 24px;
}
.pt-26[data-v-e2e9113f] {
  padding-top: 26px;
}
.pt-28[data-v-e2e9113f] {
  padding-top: 28px;
}
.pt-30[data-v-e2e9113f] {
  padding-top: 30px;
}
.pt-32[data-v-e2e9113f] {
  padding-top: 32px;
}
.pt-34[data-v-e2e9113f] {
  padding-top: 34px;
}
.pt-36[data-v-e2e9113f] {
  padding-top: 36px;
}
.pb-0[data-v-e2e9113f] {
  padding-bottom: 0px;
}
.pb-1[data-v-e2e9113f] {
  padding-bottom: 1px;
}
.pb-2[data-v-e2e9113f] {
  padding-bottom: 2px;
}
.pb-3[data-v-e2e9113f] {
  padding-bottom: 3px;
}
.pb-4[data-v-e2e9113f] {
  padding-bottom: 4px;
}
.pb-5[data-v-e2e9113f] {
  padding-bottom: 5px;
}
.pb-6[data-v-e2e9113f] {
  padding-bottom: 6px;
}
.pb-7[data-v-e2e9113f] {
  padding-bottom: 7px;
}
.pb-8[data-v-e2e9113f] {
  padding-bottom: 8px;
}
.pb-9[data-v-e2e9113f] {
  padding-bottom: 9px;
}
.pb-10[data-v-e2e9113f] {
  padding-bottom: 10px;
}
.pb-12[data-v-e2e9113f] {
  padding-bottom: 12px;
}
.pb-14[data-v-e2e9113f] {
  padding-bottom: 14px;
}
.pb-16[data-v-e2e9113f] {
  padding-bottom: 16px;
}
.pb-18[data-v-e2e9113f] {
  padding-bottom: 18px;
}
.pb-20[data-v-e2e9113f] {
  padding-bottom: 20px;
}
.pb-22[data-v-e2e9113f] {
  padding-bottom: 22px;
}
.pb-24[data-v-e2e9113f] {
  padding-bottom: 24px;
}
.pb-26[data-v-e2e9113f] {
  padding-bottom: 26px;
}
.pb-28[data-v-e2e9113f] {
  padding-bottom: 28px;
}
.pb-30[data-v-e2e9113f] {
  padding-bottom: 30px;
}
.pb-32[data-v-e2e9113f] {
  padding-bottom: 32px;
}
.pb-34[data-v-e2e9113f] {
  padding-bottom: 34px;
}
.pb-36[data-v-e2e9113f] {
  padding-bottom: 36px;
}
.pl-0[data-v-e2e9113f] {
  padding-left: 0px;
}
.pl-1[data-v-e2e9113f] {
  padding-left: 1px;
}
.pl-2[data-v-e2e9113f] {
  padding-left: 2px;
}
.pl-3[data-v-e2e9113f] {
  padding-left: 3px;
}
.pl-4[data-v-e2e9113f] {
  padding-left: 4px;
}
.pl-5[data-v-e2e9113f] {
  padding-left: 5px;
}
.pl-6[data-v-e2e9113f] {
  padding-left: 6px;
}
.pl-7[data-v-e2e9113f] {
  padding-left: 7px;
}
.pl-8[data-v-e2e9113f] {
  padding-left: 8px;
}
.pl-9[data-v-e2e9113f] {
  padding-left: 9px;
}
.pl-10[data-v-e2e9113f] {
  padding-left: 10px;
}
.pl-12[data-v-e2e9113f] {
  padding-left: 12px;
}
.pl-14[data-v-e2e9113f] {
  padding-left: 14px;
}
.pl-16[data-v-e2e9113f] {
  padding-left: 16px;
}
.pl-18[data-v-e2e9113f] {
  padding-left: 18px;
}
.pl-20[data-v-e2e9113f] {
  padding-left: 20px;
}
.pl-22[data-v-e2e9113f] {
  padding-left: 22px;
}
.pl-24[data-v-e2e9113f] {
  padding-left: 24px;
}
.pl-26[data-v-e2e9113f] {
  padding-left: 26px;
}
.pl-28[data-v-e2e9113f] {
  padding-left: 28px;
}
.pl-30[data-v-e2e9113f] {
  padding-left: 30px;
}
.pl-32[data-v-e2e9113f] {
  padding-left: 32px;
}
.pl-34[data-v-e2e9113f] {
  padding-left: 34px;
}
.pl-36[data-v-e2e9113f] {
  padding-left: 36px;
}
.pr-0[data-v-e2e9113f] {
  padding-right: 0px;
}
.pr-1[data-v-e2e9113f] {
  padding-right: 1px;
}
.pr-2[data-v-e2e9113f] {
  padding-right: 2px;
}
.pr-3[data-v-e2e9113f] {
  padding-right: 3px;
}
.pr-4[data-v-e2e9113f] {
  padding-right: 4px;
}
.pr-5[data-v-e2e9113f] {
  padding-right: 5px;
}
.pr-6[data-v-e2e9113f] {
  padding-right: 6px;
}
.pr-7[data-v-e2e9113f] {
  padding-right: 7px;
}
.pr-8[data-v-e2e9113f] {
  padding-right: 8px;
}
.pr-9[data-v-e2e9113f] {
  padding-right: 9px;
}
.pr-10[data-v-e2e9113f] {
  padding-right: 10px;
}
.pr-12[data-v-e2e9113f] {
  padding-right: 12px;
}
.pr-14[data-v-e2e9113f] {
  padding-right: 14px;
}
.pr-16[data-v-e2e9113f] {
  padding-right: 16px;
}
.pr-18[data-v-e2e9113f] {
  padding-right: 18px;
}
.pr-20[data-v-e2e9113f] {
  padding-right: 20px;
}
.pr-22[data-v-e2e9113f] {
  padding-right: 22px;
}
.pr-24[data-v-e2e9113f] {
  padding-right: 24px;
}
.pr-26[data-v-e2e9113f] {
  padding-right: 26px;
}
.pr-28[data-v-e2e9113f] {
  padding-right: 28px;
}
.pr-30[data-v-e2e9113f] {
  padding-right: 30px;
}
.pr-32[data-v-e2e9113f] {
  padding-right: 32px;
}
.pr-34[data-v-e2e9113f] {
  padding-right: 34px;
}
.pr-36[data-v-e2e9113f] {
  padding-right: 36px;
}
html[data-v-e2e9113f] {
  --primary-color: #00703d;
  --primary-disabled-color: #99c6b1;
  --primary-bg-color: #edf8ef;
  --white: white;
  --primary-color-20: #00703d33;
  --brand-4: #00703d22;
  --text-1: #1d2920;
  --text-2: #616961;
  --text-3: #979c98;
  --text-4: #b8bbb8;
  --text-blue: #3c68bf;
  --text-red: #d16559;
  --neutral-fill-1: #f8f9f8;
  --neutral-fill-2: #f1f3f1;
  --neutral-fill-3: #e0e3e0;
  --neutral-border: #f2f2f2;
  --neutral-icon: #696d69;
  --blue-bg-color: #f2f7f9;
  --red-bg-color: #fdf2f0;
  --error-1: #e4000c;
  --error-2: #fff3f4;
  --warn-1: #e88e00;
  --warn-2: #fff6e7;
  --antd-wave-shadow-color: var(--primary-color) !important;
}
span[data-v-e2e9113f] {
  color: var(--text-1);
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
}
.text-1[data-v-e2e9113f] {
  color: var(--text-1);
}
.text-2[data-v-e2e9113f] {
  color: var(--text-2);
}
.text-3[data-v-e2e9113f] {
  color: var(--text-3);
}
.text-4[data-v-e2e9113f] {
  color: var(--text-4);
}
.white[data-v-e2e9113f] {
  color: var(--white);
}
.primary-color[data-v-e2e9113f] {
  color: var(--primary-color);
}
.error-color[data-v-e2e9113f] {
  color: var(--error-1);
}
.neutral-icon[data-v-e2e9113f] {
  color: var(--neutral-icon);
}
.chat-input-toolbar[data-v-e2e9113f] {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.chat-input-toolbar-left[data-v-e2e9113f] {
  display: flex;
  align-items: center;
  gap: 12px;
}
.chat-input-toolbar-right[data-v-e2e9113f] {
  display: flex;
  align-items: center;
  gap: 12px;
}
.chat-input-toolbar-right > .text-button[data-v-e2e9113f] {
  font-weight: 400;
  font-size: 12px;
  line-height: 20px;
  color: #616961;
  cursor: pointer;
}
.chat-input-toolbar-right > .text-button[data-v-e2e9113f]:hover {
  scale: 1.05;
}
.w-100[data-v-b7664f0f] {
  font-weight: 100;
}
.w-200[data-v-b7664f0f] {
  font-weight: 200;
}
.w-300[data-v-b7664f0f] {
  font-weight: 300;
}
.w-400[data-v-b7664f0f] {
  font-weight: 400;
}
.w-500[data-v-b7664f0f] {
  font-weight: 500;
}
.w-600[data-v-b7664f0f] {
  font-weight: 600;
}
.w-700[data-v-b7664f0f] {
  font-weight: 700;
}
.w-800[data-v-b7664f0f] {
  font-weight: 800;
}
.w-900[data-v-b7664f0f] {
  font-weight: 900;
}
html[data-v-b7664f0f] {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.s-8[data-v-b7664f0f] {
  font-size: 8px;
}
.s-10[data-v-b7664f0f] {
  font-size: 10px;
}
.s-12[data-v-b7664f0f] {
  font-size: 12px;
}
.s-13[data-v-b7664f0f] {
  font-size: 13px;
}
.s-14[data-v-b7664f0f] {
  font-size: 14px;
}
.s-16[data-v-b7664f0f] {
  font-size: 16px;
}
.s-18[data-v-b7664f0f] {
  font-size: 18px;
}
.s-20[data-v-b7664f0f] {
  font-size: 20px;
}
.s-22[data-v-b7664f0f] {
  font-size: 22px;
}
.s-24[data-v-b7664f0f] {
  font-size: 24px;
}
.s-32[data-v-b7664f0f] {
  font-size: 32px;
}
.s-36[data-v-b7664f0f] {
  font-size: 36px;
}
.s-40[data-v-b7664f0f] {
  font-size: 40px;
}
.l-8[data-v-b7664f0f] {
  line-height: 8px;
}
.l-10[data-v-b7664f0f] {
  line-height: 10px;
}
.l-12[data-v-b7664f0f] {
  line-height: 12px;
}
.l-13[data-v-b7664f0f] {
  line-height: 13px;
}
.l-14[data-v-b7664f0f] {
  line-height: 14px;
}
.l-16[data-v-b7664f0f] {
  line-height: 16px;
}
.l-18[data-v-b7664f0f] {
  line-height: 18px;
}
.l-20[data-v-b7664f0f] {
  line-height: 20px;
}
.l-22[data-v-b7664f0f] {
  line-height: 22px;
}
.l-24[data-v-b7664f0f] {
  line-height: 24px;
}
.l-32[data-v-b7664f0f] {
  line-height: 32px;
}
.l-36[data-v-b7664f0f] {
  line-height: 36px;
}
.l-40[data-v-b7664f0f] {
  line-height: 40px;
}
.mt-0[data-v-b7664f0f] {
  margin-top: 0px;
}
.mt-1[data-v-b7664f0f] {
  margin-top: 1px;
}
.mt-2[data-v-b7664f0f] {
  margin-top: 2px;
}
.mt-3[data-v-b7664f0f] {
  margin-top: 3px;
}
.mt-4[data-v-b7664f0f] {
  margin-top: 4px;
}
.mt-5[data-v-b7664f0f] {
  margin-top: 5px;
}
.mt-6[data-v-b7664f0f] {
  margin-top: 6px;
}
.mt-7[data-v-b7664f0f] {
  margin-top: 7px;
}
.mt-8[data-v-b7664f0f] {
  margin-top: 8px;
}
.mt-9[data-v-b7664f0f] {
  margin-top: 9px;
}
.mt-10[data-v-b7664f0f] {
  margin-top: 10px;
}
.mt-12[data-v-b7664f0f] {
  margin-top: 12px;
}
.mt-14[data-v-b7664f0f] {
  margin-top: 14px;
}
.mt-16[data-v-b7664f0f] {
  margin-top: 16px;
}
.mt-18[data-v-b7664f0f] {
  margin-top: 18px;
}
.mt-20[data-v-b7664f0f] {
  margin-top: 20px;
}
.mt-22[data-v-b7664f0f] {
  margin-top: 22px;
}
.mt-24[data-v-b7664f0f] {
  margin-top: 24px;
}
.mt-26[data-v-b7664f0f] {
  margin-top: 26px;
}
.mt-28[data-v-b7664f0f] {
  margin-top: 28px;
}
.mt-30[data-v-b7664f0f] {
  margin-top: 30px;
}
.mt-32[data-v-b7664f0f] {
  margin-top: 32px;
}
.mt-34[data-v-b7664f0f] {
  margin-top: 34px;
}
.mt-36[data-v-b7664f0f] {
  margin-top: 36px;
}
.mb-0[data-v-b7664f0f] {
  margin-bottom: 0px;
}
.mb-1[data-v-b7664f0f] {
  margin-bottom: 1px;
}
.mb-2[data-v-b7664f0f] {
  margin-bottom: 2px;
}
.mb-3[data-v-b7664f0f] {
  margin-bottom: 3px;
}
.mb-4[data-v-b7664f0f] {
  margin-bottom: 4px;
}
.mb-5[data-v-b7664f0f] {
  margin-bottom: 5px;
}
.mb-6[data-v-b7664f0f] {
  margin-bottom: 6px;
}
.mb-7[data-v-b7664f0f] {
  margin-bottom: 7px;
}
.mb-8[data-v-b7664f0f] {
  margin-bottom: 8px;
}
.mb-9[data-v-b7664f0f] {
  margin-bottom: 9px;
}
.mb-10[data-v-b7664f0f] {
  margin-bottom: 10px;
}
.mb-12[data-v-b7664f0f] {
  margin-bottom: 12px;
}
.mb-14[data-v-b7664f0f] {
  margin-bottom: 14px;
}
.mb-16[data-v-b7664f0f] {
  margin-bottom: 16px;
}
.mb-18[data-v-b7664f0f] {
  margin-bottom: 18px;
}
.mb-20[data-v-b7664f0f] {
  margin-bottom: 20px;
}
.mb-22[data-v-b7664f0f] {
  margin-bottom: 22px;
}
.mb-24[data-v-b7664f0f] {
  margin-bottom: 24px;
}
.mb-26[data-v-b7664f0f] {
  margin-bottom: 26px;
}
.mb-28[data-v-b7664f0f] {
  margin-bottom: 28px;
}
.mb-30[data-v-b7664f0f] {
  margin-bottom: 30px;
}
.mb-32[data-v-b7664f0f] {
  margin-bottom: 32px;
}
.mb-34[data-v-b7664f0f] {
  margin-bottom: 34px;
}
.mb-36[data-v-b7664f0f] {
  margin-bottom: 36px;
}
.ml-0[data-v-b7664f0f] {
  margin-left: 0px;
}
.ml-1[data-v-b7664f0f] {
  margin-left: 1px;
}
.ml-2[data-v-b7664f0f] {
  margin-left: 2px;
}
.ml-3[data-v-b7664f0f] {
  margin-left: 3px;
}
.ml-4[data-v-b7664f0f] {
  margin-left: 4px;
}
.ml-5[data-v-b7664f0f] {
  margin-left: 5px;
}
.ml-6[data-v-b7664f0f] {
  margin-left: 6px;
}
.ml-7[data-v-b7664f0f] {
  margin-left: 7px;
}
.ml-8[data-v-b7664f0f] {
  margin-left: 8px;
}
.ml-9[data-v-b7664f0f] {
  margin-left: 9px;
}
.ml-10[data-v-b7664f0f] {
  margin-left: 10px;
}
.ml-12[data-v-b7664f0f] {
  margin-left: 12px;
}
.ml-14[data-v-b7664f0f] {
  margin-left: 14px;
}
.ml-16[data-v-b7664f0f] {
  margin-left: 16px;
}
.ml-18[data-v-b7664f0f] {
  margin-left: 18px;
}
.ml-20[data-v-b7664f0f] {
  margin-left: 20px;
}
.ml-22[data-v-b7664f0f] {
  margin-left: 22px;
}
.ml-24[data-v-b7664f0f] {
  margin-left: 24px;
}
.ml-26[data-v-b7664f0f] {
  margin-left: 26px;
}
.ml-28[data-v-b7664f0f] {
  margin-left: 28px;
}
.ml-30[data-v-b7664f0f] {
  margin-left: 30px;
}
.ml-32[data-v-b7664f0f] {
  margin-left: 32px;
}
.ml-34[data-v-b7664f0f] {
  margin-left: 34px;
}
.ml-36[data-v-b7664f0f] {
  margin-left: 36px;
}
.mr-0[data-v-b7664f0f] {
  margin-right: 0px;
}
.mr-1[data-v-b7664f0f] {
  margin-right: 1px;
}
.mr-2[data-v-b7664f0f] {
  margin-right: 2px;
}
.mr-3[data-v-b7664f0f] {
  margin-right: 3px;
}
.mr-4[data-v-b7664f0f] {
  margin-right: 4px;
}
.mr-5[data-v-b7664f0f] {
  margin-right: 5px;
}
.mr-6[data-v-b7664f0f] {
  margin-right: 6px;
}
.mr-7[data-v-b7664f0f] {
  margin-right: 7px;
}
.mr-8[data-v-b7664f0f] {
  margin-right: 8px;
}
.mr-9[data-v-b7664f0f] {
  margin-right: 9px;
}
.mr-10[data-v-b7664f0f] {
  margin-right: 10px;
}
.mr-12[data-v-b7664f0f] {
  margin-right: 12px;
}
.mr-14[data-v-b7664f0f] {
  margin-right: 14px;
}
.mr-16[data-v-b7664f0f] {
  margin-right: 16px;
}
.mr-18[data-v-b7664f0f] {
  margin-right: 18px;
}
.mr-20[data-v-b7664f0f] {
  margin-right: 20px;
}
.mr-22[data-v-b7664f0f] {
  margin-right: 22px;
}
.mr-24[data-v-b7664f0f] {
  margin-right: 24px;
}
.mr-26[data-v-b7664f0f] {
  margin-right: 26px;
}
.mr-28[data-v-b7664f0f] {
  margin-right: 28px;
}
.mr-30[data-v-b7664f0f] {
  margin-right: 30px;
}
.mr-32[data-v-b7664f0f] {
  margin-right: 32px;
}
.mr-34[data-v-b7664f0f] {
  margin-right: 34px;
}
.mr-36[data-v-b7664f0f] {
  margin-right: 36px;
}
.pt-0[data-v-b7664f0f] {
  padding-top: 0px;
}
.pt-1[data-v-b7664f0f] {
  padding-top: 1px;
}
.pt-2[data-v-b7664f0f] {
  padding-top: 2px;
}
.pt-3[data-v-b7664f0f] {
  padding-top: 3px;
}
.pt-4[data-v-b7664f0f] {
  padding-top: 4px;
}
.pt-5[data-v-b7664f0f] {
  padding-top: 5px;
}
.pt-6[data-v-b7664f0f] {
  padding-top: 6px;
}
.pt-7[data-v-b7664f0f] {
  padding-top: 7px;
}
.pt-8[data-v-b7664f0f] {
  padding-top: 8px;
}
.pt-9[data-v-b7664f0f] {
  padding-top: 9px;
}
.pt-10[data-v-b7664f0f] {
  padding-top: 10px;
}
.pt-12[data-v-b7664f0f] {
  padding-top: 12px;
}
.pt-14[data-v-b7664f0f] {
  padding-top: 14px;
}
.pt-16[data-v-b7664f0f] {
  padding-top: 16px;
}
.pt-18[data-v-b7664f0f] {
  padding-top: 18px;
}
.pt-20[data-v-b7664f0f] {
  padding-top: 20px;
}
.pt-22[data-v-b7664f0f] {
  padding-top: 22px;
}
.pt-24[data-v-b7664f0f] {
  padding-top: 24px;
}
.pt-26[data-v-b7664f0f] {
  padding-top: 26px;
}
.pt-28[data-v-b7664f0f] {
  padding-top: 28px;
}
.pt-30[data-v-b7664f0f] {
  padding-top: 30px;
}
.pt-32[data-v-b7664f0f] {
  padding-top: 32px;
}
.pt-34[data-v-b7664f0f] {
  padding-top: 34px;
}
.pt-36[data-v-b7664f0f] {
  padding-top: 36px;
}
.pb-0[data-v-b7664f0f] {
  padding-bottom: 0px;
}
.pb-1[data-v-b7664f0f] {
  padding-bottom: 1px;
}
.pb-2[data-v-b7664f0f] {
  padding-bottom: 2px;
}
.pb-3[data-v-b7664f0f] {
  padding-bottom: 3px;
}
.pb-4[data-v-b7664f0f] {
  padding-bottom: 4px;
}
.pb-5[data-v-b7664f0f] {
  padding-bottom: 5px;
}
.pb-6[data-v-b7664f0f] {
  padding-bottom: 6px;
}
.pb-7[data-v-b7664f0f] {
  padding-bottom: 7px;
}
.pb-8[data-v-b7664f0f] {
  padding-bottom: 8px;
}
.pb-9[data-v-b7664f0f] {
  padding-bottom: 9px;
}
.pb-10[data-v-b7664f0f] {
  padding-bottom: 10px;
}
.pb-12[data-v-b7664f0f] {
  padding-bottom: 12px;
}
.pb-14[data-v-b7664f0f] {
  padding-bottom: 14px;
}
.pb-16[data-v-b7664f0f] {
  padding-bottom: 16px;
}
.pb-18[data-v-b7664f0f] {
  padding-bottom: 18px;
}
.pb-20[data-v-b7664f0f] {
  padding-bottom: 20px;
}
.pb-22[data-v-b7664f0f] {
  padding-bottom: 22px;
}
.pb-24[data-v-b7664f0f] {
  padding-bottom: 24px;
}
.pb-26[data-v-b7664f0f] {
  padding-bottom: 26px;
}
.pb-28[data-v-b7664f0f] {
  padding-bottom: 28px;
}
.pb-30[data-v-b7664f0f] {
  padding-bottom: 30px;
}
.pb-32[data-v-b7664f0f] {
  padding-bottom: 32px;
}
.pb-34[data-v-b7664f0f] {
  padding-bottom: 34px;
}
.pb-36[data-v-b7664f0f] {
  padding-bottom: 36px;
}
.pl-0[data-v-b7664f0f] {
  padding-left: 0px;
}
.pl-1[data-v-b7664f0f] {
  padding-left: 1px;
}
.pl-2[data-v-b7664f0f] {
  padding-left: 2px;
}
.pl-3[data-v-b7664f0f] {
  padding-left: 3px;
}
.pl-4[data-v-b7664f0f] {
  padding-left: 4px;
}
.pl-5[data-v-b7664f0f] {
  padding-left: 5px;
}
.pl-6[data-v-b7664f0f] {
  padding-left: 6px;
}
.pl-7[data-v-b7664f0f] {
  padding-left: 7px;
}
.pl-8[data-v-b7664f0f] {
  padding-left: 8px;
}
.pl-9[data-v-b7664f0f] {
  padding-left: 9px;
}
.pl-10[data-v-b7664f0f] {
  padding-left: 10px;
}
.pl-12[data-v-b7664f0f] {
  padding-left: 12px;
}
.pl-14[data-v-b7664f0f] {
  padding-left: 14px;
}
.pl-16[data-v-b7664f0f] {
  padding-left: 16px;
}
.pl-18[data-v-b7664f0f] {
  padding-left: 18px;
}
.pl-20[data-v-b7664f0f] {
  padding-left: 20px;
}
.pl-22[data-v-b7664f0f] {
  padding-left: 22px;
}
.pl-24[data-v-b7664f0f] {
  padding-left: 24px;
}
.pl-26[data-v-b7664f0f] {
  padding-left: 26px;
}
.pl-28[data-v-b7664f0f] {
  padding-left: 28px;
}
.pl-30[data-v-b7664f0f] {
  padding-left: 30px;
}
.pl-32[data-v-b7664f0f] {
  padding-left: 32px;
}
.pl-34[data-v-b7664f0f] {
  padding-left: 34px;
}
.pl-36[data-v-b7664f0f] {
  padding-left: 36px;
}
.pr-0[data-v-b7664f0f] {
  padding-right: 0px;
}
.pr-1[data-v-b7664f0f] {
  padding-right: 1px;
}
.pr-2[data-v-b7664f0f] {
  padding-right: 2px;
}
.pr-3[data-v-b7664f0f] {
  padding-right: 3px;
}
.pr-4[data-v-b7664f0f] {
  padding-right: 4px;
}
.pr-5[data-v-b7664f0f] {
  padding-right: 5px;
}
.pr-6[data-v-b7664f0f] {
  padding-right: 6px;
}
.pr-7[data-v-b7664f0f] {
  padding-right: 7px;
}
.pr-8[data-v-b7664f0f] {
  padding-right: 8px;
}
.pr-9[data-v-b7664f0f] {
  padding-right: 9px;
}
.pr-10[data-v-b7664f0f] {
  padding-right: 10px;
}
.pr-12[data-v-b7664f0f] {
  padding-right: 12px;
}
.pr-14[data-v-b7664f0f] {
  padding-right: 14px;
}
.pr-16[data-v-b7664f0f] {
  padding-right: 16px;
}
.pr-18[data-v-b7664f0f] {
  padding-right: 18px;
}
.pr-20[data-v-b7664f0f] {
  padding-right: 20px;
}
.pr-22[data-v-b7664f0f] {
  padding-right: 22px;
}
.pr-24[data-v-b7664f0f] {
  padding-right: 24px;
}
.pr-26[data-v-b7664f0f] {
  padding-right: 26px;
}
.pr-28[data-v-b7664f0f] {
  padding-right: 28px;
}
.pr-30[data-v-b7664f0f] {
  padding-right: 30px;
}
.pr-32[data-v-b7664f0f] {
  padding-right: 32px;
}
.pr-34[data-v-b7664f0f] {
  padding-right: 34px;
}
.pr-36[data-v-b7664f0f] {
  padding-right: 36px;
}
html[data-v-b7664f0f] {
  --primary-color: #00703d;
  --primary-disabled-color: #99c6b1;
  --primary-bg-color: #edf8ef;
  --white: white;
  --primary-color-20: #00703d33;
  --brand-4: #00703d22;
  --text-1: #1d2920;
  --text-2: #616961;
  --text-3: #979c98;
  --text-4: #b8bbb8;
  --text-blue: #3c68bf;
  --text-red: #d16559;
  --neutral-fill-1: #f8f9f8;
  --neutral-fill-2: #f1f3f1;
  --neutral-fill-3: #e0e3e0;
  --neutral-border: #f2f2f2;
  --neutral-icon: #696d69;
  --blue-bg-color: #f2f7f9;
  --red-bg-color: #fdf2f0;
  --error-1: #e4000c;
  --error-2: #fff3f4;
  --warn-1: #e88e00;
  --warn-2: #fff6e7;
  --antd-wave-shadow-color: var(--primary-color) !important;
}
span[data-v-b7664f0f] {
  color: var(--text-1);
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
}
.text-1[data-v-b7664f0f] {
  color: var(--text-1);
}
.text-2[data-v-b7664f0f] {
  color: var(--text-2);
}
.text-3[data-v-b7664f0f] {
  color: var(--text-3);
}
.text-4[data-v-b7664f0f] {
  color: var(--text-4);
}
.white[data-v-b7664f0f] {
  color: var(--white);
}
.primary-color[data-v-b7664f0f] {
  color: var(--primary-color);
}
.error-color[data-v-b7664f0f] {
  color: var(--error-1);
}
.neutral-icon[data-v-b7664f0f] {
  color: var(--neutral-icon);
}
.primary-button[data-v-b7664f0f] {
  background-color: #00703d;
  padding: 7px 20px;
  border-radius: 2px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  gap: 8px;
}
.primary-button.big[data-v-b7664f0f] {
  padding: 10px 20px;
}
.primary-button.small[data-v-b7664f0f] {
  padding: 5px 16px;
}
.primary-button[data-v-b7664f0f]:hover,
.primary-button[data-v-b7664f0f]:focus {
  transform: translateY(-2px);
}
.primary-button[data-v-b7664f0f]:active {
  transform: translate(0px);
}
.primary-button.full-width[data-v-b7664f0f] {
  width: 100%;
}
.primary-button.disabled[data-v-b7664f0f] {
  background-color: #99c6b1;
}
.primary-button.disabled[data-v-b7664f0f]:hover,
.primary-button.disabled[data-v-b7664f0f]:focus {
  transform: translate(0px);
  cursor: not-allowed;
}
.primary-button.ghost[data-v-b7664f0f] {
  background-color: #f1f3f1;
}
.primary-button.ghost.disabled[data-v-b7664f0f] {
  background-color: #f8f9f8;
}
.primary-button.ghost.disabled[data-v-b7664f0f]:hover,
.primary-button.ghost.disabled[data-v-b7664f0f]:focus {
  transform: translate(0px);
  cursor: not-allowed;
}
.primary-button.error[data-v-b7664f0f] {
  background-color: #e4000c;
}
.primary-button.error.disabled[data-v-b7664f0f] {
  background-color: #fff3f4;
}
.primary-button.error.disabled[data-v-b7664f0f]:hover,
.primary-button.error.disabled[data-v-b7664f0f]:focus {
  transform: translate(0px);
  cursor: not-allowed;
}
.primary-button-label[data-v-b7664f0f] {
  color: white;
  line-height: 22px;
  user-select: none;
  white-space: nowrap;
  transition: all 0.2s ease;
}
.primary-button-label.ghost[data-v-b7664f0f] {
  color: #616961;
}
.primary-button-label.ghost.disabled[data-v-b7664f0f] {
  color: #b8bbb8;
}
.ant-spin-spinning[data-v-b7664f0f] {
  display: inline-flex;
}
.w-100[data-v-ddc49f7e] {
  font-weight: 100;
}
.w-200[data-v-ddc49f7e] {
  font-weight: 200;
}
.w-300[data-v-ddc49f7e] {
  font-weight: 300;
}
.w-400[data-v-ddc49f7e] {
  font-weight: 400;
}
.w-500[data-v-ddc49f7e] {
  font-weight: 500;
}
.w-600[data-v-ddc49f7e] {
  font-weight: 600;
}
.w-700[data-v-ddc49f7e] {
  font-weight: 700;
}
.w-800[data-v-ddc49f7e] {
  font-weight: 800;
}
.w-900[data-v-ddc49f7e] {
  font-weight: 900;
}
html[data-v-ddc49f7e] {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.s-8[data-v-ddc49f7e] {
  font-size: 8px;
}
.s-10[data-v-ddc49f7e] {
  font-size: 10px;
}
.s-12[data-v-ddc49f7e] {
  font-size: 12px;
}
.s-13[data-v-ddc49f7e] {
  font-size: 13px;
}
.s-14[data-v-ddc49f7e] {
  font-size: 14px;
}
.s-16[data-v-ddc49f7e] {
  font-size: 16px;
}
.s-18[data-v-ddc49f7e] {
  font-size: 18px;
}
.s-20[data-v-ddc49f7e] {
  font-size: 20px;
}
.s-22[data-v-ddc49f7e] {
  font-size: 22px;
}
.s-24[data-v-ddc49f7e] {
  font-size: 24px;
}
.s-32[data-v-ddc49f7e] {
  font-size: 32px;
}
.s-36[data-v-ddc49f7e] {
  font-size: 36px;
}
.s-40[data-v-ddc49f7e] {
  font-size: 40px;
}
.l-8[data-v-ddc49f7e] {
  line-height: 8px;
}
.l-10[data-v-ddc49f7e] {
  line-height: 10px;
}
.l-12[data-v-ddc49f7e] {
  line-height: 12px;
}
.l-13[data-v-ddc49f7e] {
  line-height: 13px;
}
.l-14[data-v-ddc49f7e] {
  line-height: 14px;
}
.l-16[data-v-ddc49f7e] {
  line-height: 16px;
}
.l-18[data-v-ddc49f7e] {
  line-height: 18px;
}
.l-20[data-v-ddc49f7e] {
  line-height: 20px;
}
.l-22[data-v-ddc49f7e] {
  line-height: 22px;
}
.l-24[data-v-ddc49f7e] {
  line-height: 24px;
}
.l-32[data-v-ddc49f7e] {
  line-height: 32px;
}
.l-36[data-v-ddc49f7e] {
  line-height: 36px;
}
.l-40[data-v-ddc49f7e] {
  line-height: 40px;
}
.mt-0[data-v-ddc49f7e] {
  margin-top: 0px;
}
.mt-1[data-v-ddc49f7e] {
  margin-top: 1px;
}
.mt-2[data-v-ddc49f7e] {
  margin-top: 2px;
}
.mt-3[data-v-ddc49f7e] {
  margin-top: 3px;
}
.mt-4[data-v-ddc49f7e] {
  margin-top: 4px;
}
.mt-5[data-v-ddc49f7e] {
  margin-top: 5px;
}
.mt-6[data-v-ddc49f7e] {
  margin-top: 6px;
}
.mt-7[data-v-ddc49f7e] {
  margin-top: 7px;
}
.mt-8[data-v-ddc49f7e] {
  margin-top: 8px;
}
.mt-9[data-v-ddc49f7e] {
  margin-top: 9px;
}
.mt-10[data-v-ddc49f7e] {
  margin-top: 10px;
}
.mt-12[data-v-ddc49f7e] {
  margin-top: 12px;
}
.mt-14[data-v-ddc49f7e] {
  margin-top: 14px;
}
.mt-16[data-v-ddc49f7e] {
  margin-top: 16px;
}
.mt-18[data-v-ddc49f7e] {
  margin-top: 18px;
}
.mt-20[data-v-ddc49f7e] {
  margin-top: 20px;
}
.mt-22[data-v-ddc49f7e] {
  margin-top: 22px;
}
.mt-24[data-v-ddc49f7e] {
  margin-top: 24px;
}
.mt-26[data-v-ddc49f7e] {
  margin-top: 26px;
}
.mt-28[data-v-ddc49f7e] {
  margin-top: 28px;
}
.mt-30[data-v-ddc49f7e] {
  margin-top: 30px;
}
.mt-32[data-v-ddc49f7e] {
  margin-top: 32px;
}
.mt-34[data-v-ddc49f7e] {
  margin-top: 34px;
}
.mt-36[data-v-ddc49f7e] {
  margin-top: 36px;
}
.mb-0[data-v-ddc49f7e] {
  margin-bottom: 0px;
}
.mb-1[data-v-ddc49f7e] {
  margin-bottom: 1px;
}
.mb-2[data-v-ddc49f7e] {
  margin-bottom: 2px;
}
.mb-3[data-v-ddc49f7e] {
  margin-bottom: 3px;
}
.mb-4[data-v-ddc49f7e] {
  margin-bottom: 4px;
}
.mb-5[data-v-ddc49f7e] {
  margin-bottom: 5px;
}
.mb-6[data-v-ddc49f7e] {
  margin-bottom: 6px;
}
.mb-7[data-v-ddc49f7e] {
  margin-bottom: 7px;
}
.mb-8[data-v-ddc49f7e] {
  margin-bottom: 8px;
}
.mb-9[data-v-ddc49f7e] {
  margin-bottom: 9px;
}
.mb-10[data-v-ddc49f7e] {
  margin-bottom: 10px;
}
.mb-12[data-v-ddc49f7e] {
  margin-bottom: 12px;
}
.mb-14[data-v-ddc49f7e] {
  margin-bottom: 14px;
}
.mb-16[data-v-ddc49f7e] {
  margin-bottom: 16px;
}
.mb-18[data-v-ddc49f7e] {
  margin-bottom: 18px;
}
.mb-20[data-v-ddc49f7e] {
  margin-bottom: 20px;
}
.mb-22[data-v-ddc49f7e] {
  margin-bottom: 22px;
}
.mb-24[data-v-ddc49f7e] {
  margin-bottom: 24px;
}
.mb-26[data-v-ddc49f7e] {
  margin-bottom: 26px;
}
.mb-28[data-v-ddc49f7e] {
  margin-bottom: 28px;
}
.mb-30[data-v-ddc49f7e] {
  margin-bottom: 30px;
}
.mb-32[data-v-ddc49f7e] {
  margin-bottom: 32px;
}
.mb-34[data-v-ddc49f7e] {
  margin-bottom: 34px;
}
.mb-36[data-v-ddc49f7e] {
  margin-bottom: 36px;
}
.ml-0[data-v-ddc49f7e] {
  margin-left: 0px;
}
.ml-1[data-v-ddc49f7e] {
  margin-left: 1px;
}
.ml-2[data-v-ddc49f7e] {
  margin-left: 2px;
}
.ml-3[data-v-ddc49f7e] {
  margin-left: 3px;
}
.ml-4[data-v-ddc49f7e] {
  margin-left: 4px;
}
.ml-5[data-v-ddc49f7e] {
  margin-left: 5px;
}
.ml-6[data-v-ddc49f7e] {
  margin-left: 6px;
}
.ml-7[data-v-ddc49f7e] {
  margin-left: 7px;
}
.ml-8[data-v-ddc49f7e] {
  margin-left: 8px;
}
.ml-9[data-v-ddc49f7e] {
  margin-left: 9px;
}
.ml-10[data-v-ddc49f7e] {
  margin-left: 10px;
}
.ml-12[data-v-ddc49f7e] {
  margin-left: 12px;
}
.ml-14[data-v-ddc49f7e] {
  margin-left: 14px;
}
.ml-16[data-v-ddc49f7e] {
  margin-left: 16px;
}
.ml-18[data-v-ddc49f7e] {
  margin-left: 18px;
}
.ml-20[data-v-ddc49f7e] {
  margin-left: 20px;
}
.ml-22[data-v-ddc49f7e] {
  margin-left: 22px;
}
.ml-24[data-v-ddc49f7e] {
  margin-left: 24px;
}
.ml-26[data-v-ddc49f7e] {
  margin-left: 26px;
}
.ml-28[data-v-ddc49f7e] {
  margin-left: 28px;
}
.ml-30[data-v-ddc49f7e] {
  margin-left: 30px;
}
.ml-32[data-v-ddc49f7e] {
  margin-left: 32px;
}
.ml-34[data-v-ddc49f7e] {
  margin-left: 34px;
}
.ml-36[data-v-ddc49f7e] {
  margin-left: 36px;
}
.mr-0[data-v-ddc49f7e] {
  margin-right: 0px;
}
.mr-1[data-v-ddc49f7e] {
  margin-right: 1px;
}
.mr-2[data-v-ddc49f7e] {
  margin-right: 2px;
}
.mr-3[data-v-ddc49f7e] {
  margin-right: 3px;
}
.mr-4[data-v-ddc49f7e] {
  margin-right: 4px;
}
.mr-5[data-v-ddc49f7e] {
  margin-right: 5px;
}
.mr-6[data-v-ddc49f7e] {
  margin-right: 6px;
}
.mr-7[data-v-ddc49f7e] {
  margin-right: 7px;
}
.mr-8[data-v-ddc49f7e] {
  margin-right: 8px;
}
.mr-9[data-v-ddc49f7e] {
  margin-right: 9px;
}
.mr-10[data-v-ddc49f7e] {
  margin-right: 10px;
}
.mr-12[data-v-ddc49f7e] {
  margin-right: 12px;
}
.mr-14[data-v-ddc49f7e] {
  margin-right: 14px;
}
.mr-16[data-v-ddc49f7e] {
  margin-right: 16px;
}
.mr-18[data-v-ddc49f7e] {
  margin-right: 18px;
}
.mr-20[data-v-ddc49f7e] {
  margin-right: 20px;
}
.mr-22[data-v-ddc49f7e] {
  margin-right: 22px;
}
.mr-24[data-v-ddc49f7e] {
  margin-right: 24px;
}
.mr-26[data-v-ddc49f7e] {
  margin-right: 26px;
}
.mr-28[data-v-ddc49f7e] {
  margin-right: 28px;
}
.mr-30[data-v-ddc49f7e] {
  margin-right: 30px;
}
.mr-32[data-v-ddc49f7e] {
  margin-right: 32px;
}
.mr-34[data-v-ddc49f7e] {
  margin-right: 34px;
}
.mr-36[data-v-ddc49f7e] {
  margin-right: 36px;
}
.pt-0[data-v-ddc49f7e] {
  padding-top: 0px;
}
.pt-1[data-v-ddc49f7e] {
  padding-top: 1px;
}
.pt-2[data-v-ddc49f7e] {
  padding-top: 2px;
}
.pt-3[data-v-ddc49f7e] {
  padding-top: 3px;
}
.pt-4[data-v-ddc49f7e] {
  padding-top: 4px;
}
.pt-5[data-v-ddc49f7e] {
  padding-top: 5px;
}
.pt-6[data-v-ddc49f7e] {
  padding-top: 6px;
}
.pt-7[data-v-ddc49f7e] {
  padding-top: 7px;
}
.pt-8[data-v-ddc49f7e] {
  padding-top: 8px;
}
.pt-9[data-v-ddc49f7e] {
  padding-top: 9px;
}
.pt-10[data-v-ddc49f7e] {
  padding-top: 10px;
}
.pt-12[data-v-ddc49f7e] {
  padding-top: 12px;
}
.pt-14[data-v-ddc49f7e] {
  padding-top: 14px;
}
.pt-16[data-v-ddc49f7e] {
  padding-top: 16px;
}
.pt-18[data-v-ddc49f7e] {
  padding-top: 18px;
}
.pt-20[data-v-ddc49f7e] {
  padding-top: 20px;
}
.pt-22[data-v-ddc49f7e] {
  padding-top: 22px;
}
.pt-24[data-v-ddc49f7e] {
  padding-top: 24px;
}
.pt-26[data-v-ddc49f7e] {
  padding-top: 26px;
}
.pt-28[data-v-ddc49f7e] {
  padding-top: 28px;
}
.pt-30[data-v-ddc49f7e] {
  padding-top: 30px;
}
.pt-32[data-v-ddc49f7e] {
  padding-top: 32px;
}
.pt-34[data-v-ddc49f7e] {
  padding-top: 34px;
}
.pt-36[data-v-ddc49f7e] {
  padding-top: 36px;
}
.pb-0[data-v-ddc49f7e] {
  padding-bottom: 0px;
}
.pb-1[data-v-ddc49f7e] {
  padding-bottom: 1px;
}
.pb-2[data-v-ddc49f7e] {
  padding-bottom: 2px;
}
.pb-3[data-v-ddc49f7e] {
  padding-bottom: 3px;
}
.pb-4[data-v-ddc49f7e] {
  padding-bottom: 4px;
}
.pb-5[data-v-ddc49f7e] {
  padding-bottom: 5px;
}
.pb-6[data-v-ddc49f7e] {
  padding-bottom: 6px;
}
.pb-7[data-v-ddc49f7e] {
  padding-bottom: 7px;
}
.pb-8[data-v-ddc49f7e] {
  padding-bottom: 8px;
}
.pb-9[data-v-ddc49f7e] {
  padding-bottom: 9px;
}
.pb-10[data-v-ddc49f7e] {
  padding-bottom: 10px;
}
.pb-12[data-v-ddc49f7e] {
  padding-bottom: 12px;
}
.pb-14[data-v-ddc49f7e] {
  padding-bottom: 14px;
}
.pb-16[data-v-ddc49f7e] {
  padding-bottom: 16px;
}
.pb-18[data-v-ddc49f7e] {
  padding-bottom: 18px;
}
.pb-20[data-v-ddc49f7e] {
  padding-bottom: 20px;
}
.pb-22[data-v-ddc49f7e] {
  padding-bottom: 22px;
}
.pb-24[data-v-ddc49f7e] {
  padding-bottom: 24px;
}
.pb-26[data-v-ddc49f7e] {
  padding-bottom: 26px;
}
.pb-28[data-v-ddc49f7e] {
  padding-bottom: 28px;
}
.pb-30[data-v-ddc49f7e] {
  padding-bottom: 30px;
}
.pb-32[data-v-ddc49f7e] {
  padding-bottom: 32px;
}
.pb-34[data-v-ddc49f7e] {
  padding-bottom: 34px;
}
.pb-36[data-v-ddc49f7e] {
  padding-bottom: 36px;
}
.pl-0[data-v-ddc49f7e] {
  padding-left: 0px;
}
.pl-1[data-v-ddc49f7e] {
  padding-left: 1px;
}
.pl-2[data-v-ddc49f7e] {
  padding-left: 2px;
}
.pl-3[data-v-ddc49f7e] {
  padding-left: 3px;
}
.pl-4[data-v-ddc49f7e] {
  padding-left: 4px;
}
.pl-5[data-v-ddc49f7e] {
  padding-left: 5px;
}
.pl-6[data-v-ddc49f7e] {
  padding-left: 6px;
}
.pl-7[data-v-ddc49f7e] {
  padding-left: 7px;
}
.pl-8[data-v-ddc49f7e] {
  padding-left: 8px;
}
.pl-9[data-v-ddc49f7e] {
  padding-left: 9px;
}
.pl-10[data-v-ddc49f7e] {
  padding-left: 10px;
}
.pl-12[data-v-ddc49f7e] {
  padding-left: 12px;
}
.pl-14[data-v-ddc49f7e] {
  padding-left: 14px;
}
.pl-16[data-v-ddc49f7e] {
  padding-left: 16px;
}
.pl-18[data-v-ddc49f7e] {
  padding-left: 18px;
}
.pl-20[data-v-ddc49f7e] {
  padding-left: 20px;
}
.pl-22[data-v-ddc49f7e] {
  padding-left: 22px;
}
.pl-24[data-v-ddc49f7e] {
  padding-left: 24px;
}
.pl-26[data-v-ddc49f7e] {
  padding-left: 26px;
}
.pl-28[data-v-ddc49f7e] {
  padding-left: 28px;
}
.pl-30[data-v-ddc49f7e] {
  padding-left: 30px;
}
.pl-32[data-v-ddc49f7e] {
  padding-left: 32px;
}
.pl-34[data-v-ddc49f7e] {
  padding-left: 34px;
}
.pl-36[data-v-ddc49f7e] {
  padding-left: 36px;
}
.pr-0[data-v-ddc49f7e] {
  padding-right: 0px;
}
.pr-1[data-v-ddc49f7e] {
  padding-right: 1px;
}
.pr-2[data-v-ddc49f7e] {
  padding-right: 2px;
}
.pr-3[data-v-ddc49f7e] {
  padding-right: 3px;
}
.pr-4[data-v-ddc49f7e] {
  padding-right: 4px;
}
.pr-5[data-v-ddc49f7e] {
  padding-right: 5px;
}
.pr-6[data-v-ddc49f7e] {
  padding-right: 6px;
}
.pr-7[data-v-ddc49f7e] {
  padding-right: 7px;
}
.pr-8[data-v-ddc49f7e] {
  padding-right: 8px;
}
.pr-9[data-v-ddc49f7e] {
  padding-right: 9px;
}
.pr-10[data-v-ddc49f7e] {
  padding-right: 10px;
}
.pr-12[data-v-ddc49f7e] {
  padding-right: 12px;
}
.pr-14[data-v-ddc49f7e] {
  padding-right: 14px;
}
.pr-16[data-v-ddc49f7e] {
  padding-right: 16px;
}
.pr-18[data-v-ddc49f7e] {
  padding-right: 18px;
}
.pr-20[data-v-ddc49f7e] {
  padding-right: 20px;
}
.pr-22[data-v-ddc49f7e] {
  padding-right: 22px;
}
.pr-24[data-v-ddc49f7e] {
  padding-right: 24px;
}
.pr-26[data-v-ddc49f7e] {
  padding-right: 26px;
}
.pr-28[data-v-ddc49f7e] {
  padding-right: 28px;
}
.pr-30[data-v-ddc49f7e] {
  padding-right: 30px;
}
.pr-32[data-v-ddc49f7e] {
  padding-right: 32px;
}
.pr-34[data-v-ddc49f7e] {
  padding-right: 34px;
}
.pr-36[data-v-ddc49f7e] {
  padding-right: 36px;
}
html[data-v-ddc49f7e] {
  --primary-color: #00703d;
  --primary-disabled-color: #99c6b1;
  --primary-bg-color: #edf8ef;
  --white: white;
  --primary-color-20: #00703d33;
  --brand-4: #00703d22;
  --text-1: #1d2920;
  --text-2: #616961;
  --text-3: #979c98;
  --text-4: #b8bbb8;
  --text-blue: #3c68bf;
  --text-red: #d16559;
  --neutral-fill-1: #f8f9f8;
  --neutral-fill-2: #f1f3f1;
  --neutral-fill-3: #e0e3e0;
  --neutral-border: #f2f2f2;
  --neutral-icon: #696d69;
  --blue-bg-color: #f2f7f9;
  --red-bg-color: #fdf2f0;
  --error-1: #e4000c;
  --error-2: #fff3f4;
  --warn-1: #e88e00;
  --warn-2: #fff6e7;
  --antd-wave-shadow-color: var(--primary-color) !important;
}
span[data-v-ddc49f7e] {
  color: var(--text-1);
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
}
.text-1[data-v-ddc49f7e] {
  color: var(--text-1);
}
.text-2[data-v-ddc49f7e] {
  color: var(--text-2);
}
.text-3[data-v-ddc49f7e] {
  color: var(--text-3);
}
.text-4[data-v-ddc49f7e] {
  color: var(--text-4);
}
.white[data-v-ddc49f7e] {
  color: var(--white);
}
.primary-color[data-v-ddc49f7e] {
  color: var(--primary-color);
}
.error-color[data-v-ddc49f7e] {
  color: var(--error-1);
}
.neutral-icon[data-v-ddc49f7e] {
  color: var(--neutral-icon);
}
.chat-input-card[data-v-ddc49f7e] {
  position: relative;
  border-radius: 4px;
  width: calc(100% - 40px);
  height: 172px;
  margin: 8px;
  padding: 10px 12px;
  background-color: white;
}
.disable-mask[data-v-ddc49f7e] {
  position: absolute;
  width: 100%;
  height: 100%;
  z-index: 1;
  background-color: #00000019;
  top: 0;
  left: 0;
}
.send-button-container[data-v-ddc49f7e] {
  display: flex;
  align-items: center;
  justify-content: end;
  gap: 8px;
}
.chat-textarea[data-v-ddc49f7e] {
  flex: 1;
  border: none;
  resize: none;
  font-family: inherit;
  font-size: 14px;
  line-height: 22px;
  min-height: 116px;
  max-height: 200px;
  padding: 0px;
  margin-top: 4px;
  width: 100%;
  overflow-y: auto;
  transition: height 0.2s ease;
}
.chat-textarea[data-v-ddc49f7e]:focus {
  outline: none;
}
.chat-textarea[data-v-ddc49f7e]::placeholder {
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
  color: #b8bbb8;
}
.w-100[data-v-f8d6588a] {
  font-weight: 100;
}
.w-200[data-v-f8d6588a] {
  font-weight: 200;
}
.w-300[data-v-f8d6588a] {
  font-weight: 300;
}
.w-400[data-v-f8d6588a] {
  font-weight: 400;
}
.w-500[data-v-f8d6588a] {
  font-weight: 500;
}
.w-600[data-v-f8d6588a] {
  font-weight: 600;
}
.w-700[data-v-f8d6588a] {
  font-weight: 700;
}
.w-800[data-v-f8d6588a] {
  font-weight: 800;
}
.w-900[data-v-f8d6588a] {
  font-weight: 900;
}
html[data-v-f8d6588a] {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.s-8[data-v-f8d6588a] {
  font-size: 8px;
}
.s-10[data-v-f8d6588a] {
  font-size: 10px;
}
.s-12[data-v-f8d6588a] {
  font-size: 12px;
}
.s-13[data-v-f8d6588a] {
  font-size: 13px;
}
.s-14[data-v-f8d6588a] {
  font-size: 14px;
}
.s-16[data-v-f8d6588a] {
  font-size: 16px;
}
.s-18[data-v-f8d6588a] {
  font-size: 18px;
}
.s-20[data-v-f8d6588a] {
  font-size: 20px;
}
.s-22[data-v-f8d6588a] {
  font-size: 22px;
}
.s-24[data-v-f8d6588a] {
  font-size: 24px;
}
.s-32[data-v-f8d6588a] {
  font-size: 32px;
}
.s-36[data-v-f8d6588a] {
  font-size: 36px;
}
.s-40[data-v-f8d6588a] {
  font-size: 40px;
}
.l-8[data-v-f8d6588a] {
  line-height: 8px;
}
.l-10[data-v-f8d6588a] {
  line-height: 10px;
}
.l-12[data-v-f8d6588a] {
  line-height: 12px;
}
.l-13[data-v-f8d6588a] {
  line-height: 13px;
}
.l-14[data-v-f8d6588a] {
  line-height: 14px;
}
.l-16[data-v-f8d6588a] {
  line-height: 16px;
}
.l-18[data-v-f8d6588a] {
  line-height: 18px;
}
.l-20[data-v-f8d6588a] {
  line-height: 20px;
}
.l-22[data-v-f8d6588a] {
  line-height: 22px;
}
.l-24[data-v-f8d6588a] {
  line-height: 24px;
}
.l-32[data-v-f8d6588a] {
  line-height: 32px;
}
.l-36[data-v-f8d6588a] {
  line-height: 36px;
}
.l-40[data-v-f8d6588a] {
  line-height: 40px;
}
.mt-0[data-v-f8d6588a] {
  margin-top: 0px;
}
.mt-1[data-v-f8d6588a] {
  margin-top: 1px;
}
.mt-2[data-v-f8d6588a] {
  margin-top: 2px;
}
.mt-3[data-v-f8d6588a] {
  margin-top: 3px;
}
.mt-4[data-v-f8d6588a] {
  margin-top: 4px;
}
.mt-5[data-v-f8d6588a] {
  margin-top: 5px;
}
.mt-6[data-v-f8d6588a] {
  margin-top: 6px;
}
.mt-7[data-v-f8d6588a] {
  margin-top: 7px;
}
.mt-8[data-v-f8d6588a] {
  margin-top: 8px;
}
.mt-9[data-v-f8d6588a] {
  margin-top: 9px;
}
.mt-10[data-v-f8d6588a] {
  margin-top: 10px;
}
.mt-12[data-v-f8d6588a] {
  margin-top: 12px;
}
.mt-14[data-v-f8d6588a] {
  margin-top: 14px;
}
.mt-16[data-v-f8d6588a] {
  margin-top: 16px;
}
.mt-18[data-v-f8d6588a] {
  margin-top: 18px;
}
.mt-20[data-v-f8d6588a] {
  margin-top: 20px;
}
.mt-22[data-v-f8d6588a] {
  margin-top: 22px;
}
.mt-24[data-v-f8d6588a] {
  margin-top: 24px;
}
.mt-26[data-v-f8d6588a] {
  margin-top: 26px;
}
.mt-28[data-v-f8d6588a] {
  margin-top: 28px;
}
.mt-30[data-v-f8d6588a] {
  margin-top: 30px;
}
.mt-32[data-v-f8d6588a] {
  margin-top: 32px;
}
.mt-34[data-v-f8d6588a] {
  margin-top: 34px;
}
.mt-36[data-v-f8d6588a] {
  margin-top: 36px;
}
.mb-0[data-v-f8d6588a] {
  margin-bottom: 0px;
}
.mb-1[data-v-f8d6588a] {
  margin-bottom: 1px;
}
.mb-2[data-v-f8d6588a] {
  margin-bottom: 2px;
}
.mb-3[data-v-f8d6588a] {
  margin-bottom: 3px;
}
.mb-4[data-v-f8d6588a] {
  margin-bottom: 4px;
}
.mb-5[data-v-f8d6588a] {
  margin-bottom: 5px;
}
.mb-6[data-v-f8d6588a] {
  margin-bottom: 6px;
}
.mb-7[data-v-f8d6588a] {
  margin-bottom: 7px;
}
.mb-8[data-v-f8d6588a] {
  margin-bottom: 8px;
}
.mb-9[data-v-f8d6588a] {
  margin-bottom: 9px;
}
.mb-10[data-v-f8d6588a] {
  margin-bottom: 10px;
}
.mb-12[data-v-f8d6588a] {
  margin-bottom: 12px;
}
.mb-14[data-v-f8d6588a] {
  margin-bottom: 14px;
}
.mb-16[data-v-f8d6588a] {
  margin-bottom: 16px;
}
.mb-18[data-v-f8d6588a] {
  margin-bottom: 18px;
}
.mb-20[data-v-f8d6588a] {
  margin-bottom: 20px;
}
.mb-22[data-v-f8d6588a] {
  margin-bottom: 22px;
}
.mb-24[data-v-f8d6588a] {
  margin-bottom: 24px;
}
.mb-26[data-v-f8d6588a] {
  margin-bottom: 26px;
}
.mb-28[data-v-f8d6588a] {
  margin-bottom: 28px;
}
.mb-30[data-v-f8d6588a] {
  margin-bottom: 30px;
}
.mb-32[data-v-f8d6588a] {
  margin-bottom: 32px;
}
.mb-34[data-v-f8d6588a] {
  margin-bottom: 34px;
}
.mb-36[data-v-f8d6588a] {
  margin-bottom: 36px;
}
.ml-0[data-v-f8d6588a] {
  margin-left: 0px;
}
.ml-1[data-v-f8d6588a] {
  margin-left: 1px;
}
.ml-2[data-v-f8d6588a] {
  margin-left: 2px;
}
.ml-3[data-v-f8d6588a] {
  margin-left: 3px;
}
.ml-4[data-v-f8d6588a] {
  margin-left: 4px;
}
.ml-5[data-v-f8d6588a] {
  margin-left: 5px;
}
.ml-6[data-v-f8d6588a] {
  margin-left: 6px;
}
.ml-7[data-v-f8d6588a] {
  margin-left: 7px;
}
.ml-8[data-v-f8d6588a] {
  margin-left: 8px;
}
.ml-9[data-v-f8d6588a] {
  margin-left: 9px;
}
.ml-10[data-v-f8d6588a] {
  margin-left: 10px;
}
.ml-12[data-v-f8d6588a] {
  margin-left: 12px;
}
.ml-14[data-v-f8d6588a] {
  margin-left: 14px;
}
.ml-16[data-v-f8d6588a] {
  margin-left: 16px;
}
.ml-18[data-v-f8d6588a] {
  margin-left: 18px;
}
.ml-20[data-v-f8d6588a] {
  margin-left: 20px;
}
.ml-22[data-v-f8d6588a] {
  margin-left: 22px;
}
.ml-24[data-v-f8d6588a] {
  margin-left: 24px;
}
.ml-26[data-v-f8d6588a] {
  margin-left: 26px;
}
.ml-28[data-v-f8d6588a] {
  margin-left: 28px;
}
.ml-30[data-v-f8d6588a] {
  margin-left: 30px;
}
.ml-32[data-v-f8d6588a] {
  margin-left: 32px;
}
.ml-34[data-v-f8d6588a] {
  margin-left: 34px;
}
.ml-36[data-v-f8d6588a] {
  margin-left: 36px;
}
.mr-0[data-v-f8d6588a] {
  margin-right: 0px;
}
.mr-1[data-v-f8d6588a] {
  margin-right: 1px;
}
.mr-2[data-v-f8d6588a] {
  margin-right: 2px;
}
.mr-3[data-v-f8d6588a] {
  margin-right: 3px;
}
.mr-4[data-v-f8d6588a] {
  margin-right: 4px;
}
.mr-5[data-v-f8d6588a] {
  margin-right: 5px;
}
.mr-6[data-v-f8d6588a] {
  margin-right: 6px;
}
.mr-7[data-v-f8d6588a] {
  margin-right: 7px;
}
.mr-8[data-v-f8d6588a] {
  margin-right: 8px;
}
.mr-9[data-v-f8d6588a] {
  margin-right: 9px;
}
.mr-10[data-v-f8d6588a] {
  margin-right: 10px;
}
.mr-12[data-v-f8d6588a] {
  margin-right: 12px;
}
.mr-14[data-v-f8d6588a] {
  margin-right: 14px;
}
.mr-16[data-v-f8d6588a] {
  margin-right: 16px;
}
.mr-18[data-v-f8d6588a] {
  margin-right: 18px;
}
.mr-20[data-v-f8d6588a] {
  margin-right: 20px;
}
.mr-22[data-v-f8d6588a] {
  margin-right: 22px;
}
.mr-24[data-v-f8d6588a] {
  margin-right: 24px;
}
.mr-26[data-v-f8d6588a] {
  margin-right: 26px;
}
.mr-28[data-v-f8d6588a] {
  margin-right: 28px;
}
.mr-30[data-v-f8d6588a] {
  margin-right: 30px;
}
.mr-32[data-v-f8d6588a] {
  margin-right: 32px;
}
.mr-34[data-v-f8d6588a] {
  margin-right: 34px;
}
.mr-36[data-v-f8d6588a] {
  margin-right: 36px;
}
.pt-0[data-v-f8d6588a] {
  padding-top: 0px;
}
.pt-1[data-v-f8d6588a] {
  padding-top: 1px;
}
.pt-2[data-v-f8d6588a] {
  padding-top: 2px;
}
.pt-3[data-v-f8d6588a] {
  padding-top: 3px;
}
.pt-4[data-v-f8d6588a] {
  padding-top: 4px;
}
.pt-5[data-v-f8d6588a] {
  padding-top: 5px;
}
.pt-6[data-v-f8d6588a] {
  padding-top: 6px;
}
.pt-7[data-v-f8d6588a] {
  padding-top: 7px;
}
.pt-8[data-v-f8d6588a] {
  padding-top: 8px;
}
.pt-9[data-v-f8d6588a] {
  padding-top: 9px;
}
.pt-10[data-v-f8d6588a] {
  padding-top: 10px;
}
.pt-12[data-v-f8d6588a] {
  padding-top: 12px;
}
.pt-14[data-v-f8d6588a] {
  padding-top: 14px;
}
.pt-16[data-v-f8d6588a] {
  padding-top: 16px;
}
.pt-18[data-v-f8d6588a] {
  padding-top: 18px;
}
.pt-20[data-v-f8d6588a] {
  padding-top: 20px;
}
.pt-22[data-v-f8d6588a] {
  padding-top: 22px;
}
.pt-24[data-v-f8d6588a] {
  padding-top: 24px;
}
.pt-26[data-v-f8d6588a] {
  padding-top: 26px;
}
.pt-28[data-v-f8d6588a] {
  padding-top: 28px;
}
.pt-30[data-v-f8d6588a] {
  padding-top: 30px;
}
.pt-32[data-v-f8d6588a] {
  padding-top: 32px;
}
.pt-34[data-v-f8d6588a] {
  padding-top: 34px;
}
.pt-36[data-v-f8d6588a] {
  padding-top: 36px;
}
.pb-0[data-v-f8d6588a] {
  padding-bottom: 0px;
}
.pb-1[data-v-f8d6588a] {
  padding-bottom: 1px;
}
.pb-2[data-v-f8d6588a] {
  padding-bottom: 2px;
}
.pb-3[data-v-f8d6588a] {
  padding-bottom: 3px;
}
.pb-4[data-v-f8d6588a] {
  padding-bottom: 4px;
}
.pb-5[data-v-f8d6588a] {
  padding-bottom: 5px;
}
.pb-6[data-v-f8d6588a] {
  padding-bottom: 6px;
}
.pb-7[data-v-f8d6588a] {
  padding-bottom: 7px;
}
.pb-8[data-v-f8d6588a] {
  padding-bottom: 8px;
}
.pb-9[data-v-f8d6588a] {
  padding-bottom: 9px;
}
.pb-10[data-v-f8d6588a] {
  padding-bottom: 10px;
}
.pb-12[data-v-f8d6588a] {
  padding-bottom: 12px;
}
.pb-14[data-v-f8d6588a] {
  padding-bottom: 14px;
}
.pb-16[data-v-f8d6588a] {
  padding-bottom: 16px;
}
.pb-18[data-v-f8d6588a] {
  padding-bottom: 18px;
}
.pb-20[data-v-f8d6588a] {
  padding-bottom: 20px;
}
.pb-22[data-v-f8d6588a] {
  padding-bottom: 22px;
}
.pb-24[data-v-f8d6588a] {
  padding-bottom: 24px;
}
.pb-26[data-v-f8d6588a] {
  padding-bottom: 26px;
}
.pb-28[data-v-f8d6588a] {
  padding-bottom: 28px;
}
.pb-30[data-v-f8d6588a] {
  padding-bottom: 30px;
}
.pb-32[data-v-f8d6588a] {
  padding-bottom: 32px;
}
.pb-34[data-v-f8d6588a] {
  padding-bottom: 34px;
}
.pb-36[data-v-f8d6588a] {
  padding-bottom: 36px;
}
.pl-0[data-v-f8d6588a] {
  padding-left: 0px;
}
.pl-1[data-v-f8d6588a] {
  padding-left: 1px;
}
.pl-2[data-v-f8d6588a] {
  padding-left: 2px;
}
.pl-3[data-v-f8d6588a] {
  padding-left: 3px;
}
.pl-4[data-v-f8d6588a] {
  padding-left: 4px;
}
.pl-5[data-v-f8d6588a] {
  padding-left: 5px;
}
.pl-6[data-v-f8d6588a] {
  padding-left: 6px;
}
.pl-7[data-v-f8d6588a] {
  padding-left: 7px;
}
.pl-8[data-v-f8d6588a] {
  padding-left: 8px;
}
.pl-9[data-v-f8d6588a] {
  padding-left: 9px;
}
.pl-10[data-v-f8d6588a] {
  padding-left: 10px;
}
.pl-12[data-v-f8d6588a] {
  padding-left: 12px;
}
.pl-14[data-v-f8d6588a] {
  padding-left: 14px;
}
.pl-16[data-v-f8d6588a] {
  padding-left: 16px;
}
.pl-18[data-v-f8d6588a] {
  padding-left: 18px;
}
.pl-20[data-v-f8d6588a] {
  padding-left: 20px;
}
.pl-22[data-v-f8d6588a] {
  padding-left: 22px;
}
.pl-24[data-v-f8d6588a] {
  padding-left: 24px;
}
.pl-26[data-v-f8d6588a] {
  padding-left: 26px;
}
.pl-28[data-v-f8d6588a] {
  padding-left: 28px;
}
.pl-30[data-v-f8d6588a] {
  padding-left: 30px;
}
.pl-32[data-v-f8d6588a] {
  padding-left: 32px;
}
.pl-34[data-v-f8d6588a] {
  padding-left: 34px;
}
.pl-36[data-v-f8d6588a] {
  padding-left: 36px;
}
.pr-0[data-v-f8d6588a] {
  padding-right: 0px;
}
.pr-1[data-v-f8d6588a] {
  padding-right: 1px;
}
.pr-2[data-v-f8d6588a] {
  padding-right: 2px;
}
.pr-3[data-v-f8d6588a] {
  padding-right: 3px;
}
.pr-4[data-v-f8d6588a] {
  padding-right: 4px;
}
.pr-5[data-v-f8d6588a] {
  padding-right: 5px;
}
.pr-6[data-v-f8d6588a] {
  padding-right: 6px;
}
.pr-7[data-v-f8d6588a] {
  padding-right: 7px;
}
.pr-8[data-v-f8d6588a] {
  padding-right: 8px;
}
.pr-9[data-v-f8d6588a] {
  padding-right: 9px;
}
.pr-10[data-v-f8d6588a] {
  padding-right: 10px;
}
.pr-12[data-v-f8d6588a] {
  padding-right: 12px;
}
.pr-14[data-v-f8d6588a] {
  padding-right: 14px;
}
.pr-16[data-v-f8d6588a] {
  padding-right: 16px;
}
.pr-18[data-v-f8d6588a] {
  padding-right: 18px;
}
.pr-20[data-v-f8d6588a] {
  padding-right: 20px;
}
.pr-22[data-v-f8d6588a] {
  padding-right: 22px;
}
.pr-24[data-v-f8d6588a] {
  padding-right: 24px;
}
.pr-26[data-v-f8d6588a] {
  padding-right: 26px;
}
.pr-28[data-v-f8d6588a] {
  padding-right: 28px;
}
.pr-30[data-v-f8d6588a] {
  padding-right: 30px;
}
.pr-32[data-v-f8d6588a] {
  padding-right: 32px;
}
.pr-34[data-v-f8d6588a] {
  padding-right: 34px;
}
.pr-36[data-v-f8d6588a] {
  padding-right: 36px;
}
html[data-v-f8d6588a] {
  --primary-color: #00703d;
  --primary-disabled-color: #99c6b1;
  --primary-bg-color: #edf8ef;
  --white: white;
  --primary-color-20: #00703d33;
  --brand-4: #00703d22;
  --text-1: #1d2920;
  --text-2: #616961;
  --text-3: #979c98;
  --text-4: #b8bbb8;
  --text-blue: #3c68bf;
  --text-red: #d16559;
  --neutral-fill-1: #f8f9f8;
  --neutral-fill-2: #f1f3f1;
  --neutral-fill-3: #e0e3e0;
  --neutral-border: #f2f2f2;
  --neutral-icon: #696d69;
  --blue-bg-color: #f2f7f9;
  --red-bg-color: #fdf2f0;
  --error-1: #e4000c;
  --error-2: #fff3f4;
  --warn-1: #e88e00;
  --warn-2: #fff6e7;
  --antd-wave-shadow-color: var(--primary-color) !important;
}
span[data-v-f8d6588a] {
  color: var(--text-1);
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
}
.text-1[data-v-f8d6588a] {
  color: var(--text-1);
}
.text-2[data-v-f8d6588a] {
  color: var(--text-2);
}
.text-3[data-v-f8d6588a] {
  color: var(--text-3);
}
.text-4[data-v-f8d6588a] {
  color: var(--text-4);
}
.white[data-v-f8d6588a] {
  color: var(--white);
}
.primary-color[data-v-f8d6588a] {
  color: var(--primary-color);
}
.error-color[data-v-f8d6588a] {
  color: var(--error-1);
}
.neutral-icon[data-v-f8d6588a] {
  color: var(--neutral-icon);
}
.time-stamp[data-v-f8d6588a] {
  text-align: center;
  margin-top: 24px;
}
.w-100[data-v-6e21cf61] {
  font-weight: 100;
}
.w-200[data-v-6e21cf61] {
  font-weight: 200;
}
.w-300[data-v-6e21cf61] {
  font-weight: 300;
}
.w-400[data-v-6e21cf61] {
  font-weight: 400;
}
.w-500[data-v-6e21cf61] {
  font-weight: 500;
}
.w-600[data-v-6e21cf61] {
  font-weight: 600;
}
.w-700[data-v-6e21cf61] {
  font-weight: 700;
}
.w-800[data-v-6e21cf61] {
  font-weight: 800;
}
.w-900[data-v-6e21cf61] {
  font-weight: 900;
}
html[data-v-6e21cf61] {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.s-8[data-v-6e21cf61] {
  font-size: 8px;
}
.s-10[data-v-6e21cf61] {
  font-size: 10px;
}
.s-12[data-v-6e21cf61] {
  font-size: 12px;
}
.s-13[data-v-6e21cf61] {
  font-size: 13px;
}
.s-14[data-v-6e21cf61] {
  font-size: 14px;
}
.s-16[data-v-6e21cf61] {
  font-size: 16px;
}
.s-18[data-v-6e21cf61] {
  font-size: 18px;
}
.s-20[data-v-6e21cf61] {
  font-size: 20px;
}
.s-22[data-v-6e21cf61] {
  font-size: 22px;
}
.s-24[data-v-6e21cf61] {
  font-size: 24px;
}
.s-32[data-v-6e21cf61] {
  font-size: 32px;
}
.s-36[data-v-6e21cf61] {
  font-size: 36px;
}
.s-40[data-v-6e21cf61] {
  font-size: 40px;
}
.l-8[data-v-6e21cf61] {
  line-height: 8px;
}
.l-10[data-v-6e21cf61] {
  line-height: 10px;
}
.l-12[data-v-6e21cf61] {
  line-height: 12px;
}
.l-13[data-v-6e21cf61] {
  line-height: 13px;
}
.l-14[data-v-6e21cf61] {
  line-height: 14px;
}
.l-16[data-v-6e21cf61] {
  line-height: 16px;
}
.l-18[data-v-6e21cf61] {
  line-height: 18px;
}
.l-20[data-v-6e21cf61] {
  line-height: 20px;
}
.l-22[data-v-6e21cf61] {
  line-height: 22px;
}
.l-24[data-v-6e21cf61] {
  line-height: 24px;
}
.l-32[data-v-6e21cf61] {
  line-height: 32px;
}
.l-36[data-v-6e21cf61] {
  line-height: 36px;
}
.l-40[data-v-6e21cf61] {
  line-height: 40px;
}
.mt-0[data-v-6e21cf61] {
  margin-top: 0px;
}
.mt-1[data-v-6e21cf61] {
  margin-top: 1px;
}
.mt-2[data-v-6e21cf61] {
  margin-top: 2px;
}
.mt-3[data-v-6e21cf61] {
  margin-top: 3px;
}
.mt-4[data-v-6e21cf61] {
  margin-top: 4px;
}
.mt-5[data-v-6e21cf61] {
  margin-top: 5px;
}
.mt-6[data-v-6e21cf61] {
  margin-top: 6px;
}
.mt-7[data-v-6e21cf61] {
  margin-top: 7px;
}
.mt-8[data-v-6e21cf61] {
  margin-top: 8px;
}
.mt-9[data-v-6e21cf61] {
  margin-top: 9px;
}
.mt-10[data-v-6e21cf61] {
  margin-top: 10px;
}
.mt-12[data-v-6e21cf61] {
  margin-top: 12px;
}
.mt-14[data-v-6e21cf61] {
  margin-top: 14px;
}
.mt-16[data-v-6e21cf61] {
  margin-top: 16px;
}
.mt-18[data-v-6e21cf61] {
  margin-top: 18px;
}
.mt-20[data-v-6e21cf61] {
  margin-top: 20px;
}
.mt-22[data-v-6e21cf61] {
  margin-top: 22px;
}
.mt-24[data-v-6e21cf61] {
  margin-top: 24px;
}
.mt-26[data-v-6e21cf61] {
  margin-top: 26px;
}
.mt-28[data-v-6e21cf61] {
  margin-top: 28px;
}
.mt-30[data-v-6e21cf61] {
  margin-top: 30px;
}
.mt-32[data-v-6e21cf61] {
  margin-top: 32px;
}
.mt-34[data-v-6e21cf61] {
  margin-top: 34px;
}
.mt-36[data-v-6e21cf61] {
  margin-top: 36px;
}
.mb-0[data-v-6e21cf61] {
  margin-bottom: 0px;
}
.mb-1[data-v-6e21cf61] {
  margin-bottom: 1px;
}
.mb-2[data-v-6e21cf61] {
  margin-bottom: 2px;
}
.mb-3[data-v-6e21cf61] {
  margin-bottom: 3px;
}
.mb-4[data-v-6e21cf61] {
  margin-bottom: 4px;
}
.mb-5[data-v-6e21cf61] {
  margin-bottom: 5px;
}
.mb-6[data-v-6e21cf61] {
  margin-bottom: 6px;
}
.mb-7[data-v-6e21cf61] {
  margin-bottom: 7px;
}
.mb-8[data-v-6e21cf61] {
  margin-bottom: 8px;
}
.mb-9[data-v-6e21cf61] {
  margin-bottom: 9px;
}
.mb-10[data-v-6e21cf61] {
  margin-bottom: 10px;
}
.mb-12[data-v-6e21cf61] {
  margin-bottom: 12px;
}
.mb-14[data-v-6e21cf61] {
  margin-bottom: 14px;
}
.mb-16[data-v-6e21cf61] {
  margin-bottom: 16px;
}
.mb-18[data-v-6e21cf61] {
  margin-bottom: 18px;
}
.mb-20[data-v-6e21cf61] {
  margin-bottom: 20px;
}
.mb-22[data-v-6e21cf61] {
  margin-bottom: 22px;
}
.mb-24[data-v-6e21cf61] {
  margin-bottom: 24px;
}
.mb-26[data-v-6e21cf61] {
  margin-bottom: 26px;
}
.mb-28[data-v-6e21cf61] {
  margin-bottom: 28px;
}
.mb-30[data-v-6e21cf61] {
  margin-bottom: 30px;
}
.mb-32[data-v-6e21cf61] {
  margin-bottom: 32px;
}
.mb-34[data-v-6e21cf61] {
  margin-bottom: 34px;
}
.mb-36[data-v-6e21cf61] {
  margin-bottom: 36px;
}
.ml-0[data-v-6e21cf61] {
  margin-left: 0px;
}
.ml-1[data-v-6e21cf61] {
  margin-left: 1px;
}
.ml-2[data-v-6e21cf61] {
  margin-left: 2px;
}
.ml-3[data-v-6e21cf61] {
  margin-left: 3px;
}
.ml-4[data-v-6e21cf61] {
  margin-left: 4px;
}
.ml-5[data-v-6e21cf61] {
  margin-left: 5px;
}
.ml-6[data-v-6e21cf61] {
  margin-left: 6px;
}
.ml-7[data-v-6e21cf61] {
  margin-left: 7px;
}
.ml-8[data-v-6e21cf61] {
  margin-left: 8px;
}
.ml-9[data-v-6e21cf61] {
  margin-left: 9px;
}
.ml-10[data-v-6e21cf61] {
  margin-left: 10px;
}
.ml-12[data-v-6e21cf61] {
  margin-left: 12px;
}
.ml-14[data-v-6e21cf61] {
  margin-left: 14px;
}
.ml-16[data-v-6e21cf61] {
  margin-left: 16px;
}
.ml-18[data-v-6e21cf61] {
  margin-left: 18px;
}
.ml-20[data-v-6e21cf61] {
  margin-left: 20px;
}
.ml-22[data-v-6e21cf61] {
  margin-left: 22px;
}
.ml-24[data-v-6e21cf61] {
  margin-left: 24px;
}
.ml-26[data-v-6e21cf61] {
  margin-left: 26px;
}
.ml-28[data-v-6e21cf61] {
  margin-left: 28px;
}
.ml-30[data-v-6e21cf61] {
  margin-left: 30px;
}
.ml-32[data-v-6e21cf61] {
  margin-left: 32px;
}
.ml-34[data-v-6e21cf61] {
  margin-left: 34px;
}
.ml-36[data-v-6e21cf61] {
  margin-left: 36px;
}
.mr-0[data-v-6e21cf61] {
  margin-right: 0px;
}
.mr-1[data-v-6e21cf61] {
  margin-right: 1px;
}
.mr-2[data-v-6e21cf61] {
  margin-right: 2px;
}
.mr-3[data-v-6e21cf61] {
  margin-right: 3px;
}
.mr-4[data-v-6e21cf61] {
  margin-right: 4px;
}
.mr-5[data-v-6e21cf61] {
  margin-right: 5px;
}
.mr-6[data-v-6e21cf61] {
  margin-right: 6px;
}
.mr-7[data-v-6e21cf61] {
  margin-right: 7px;
}
.mr-8[data-v-6e21cf61] {
  margin-right: 8px;
}
.mr-9[data-v-6e21cf61] {
  margin-right: 9px;
}
.mr-10[data-v-6e21cf61] {
  margin-right: 10px;
}
.mr-12[data-v-6e21cf61] {
  margin-right: 12px;
}
.mr-14[data-v-6e21cf61] {
  margin-right: 14px;
}
.mr-16[data-v-6e21cf61] {
  margin-right: 16px;
}
.mr-18[data-v-6e21cf61] {
  margin-right: 18px;
}
.mr-20[data-v-6e21cf61] {
  margin-right: 20px;
}
.mr-22[data-v-6e21cf61] {
  margin-right: 22px;
}
.mr-24[data-v-6e21cf61] {
  margin-right: 24px;
}
.mr-26[data-v-6e21cf61] {
  margin-right: 26px;
}
.mr-28[data-v-6e21cf61] {
  margin-right: 28px;
}
.mr-30[data-v-6e21cf61] {
  margin-right: 30px;
}
.mr-32[data-v-6e21cf61] {
  margin-right: 32px;
}
.mr-34[data-v-6e21cf61] {
  margin-right: 34px;
}
.mr-36[data-v-6e21cf61] {
  margin-right: 36px;
}
.pt-0[data-v-6e21cf61] {
  padding-top: 0px;
}
.pt-1[data-v-6e21cf61] {
  padding-top: 1px;
}
.pt-2[data-v-6e21cf61] {
  padding-top: 2px;
}
.pt-3[data-v-6e21cf61] {
  padding-top: 3px;
}
.pt-4[data-v-6e21cf61] {
  padding-top: 4px;
}
.pt-5[data-v-6e21cf61] {
  padding-top: 5px;
}
.pt-6[data-v-6e21cf61] {
  padding-top: 6px;
}
.pt-7[data-v-6e21cf61] {
  padding-top: 7px;
}
.pt-8[data-v-6e21cf61] {
  padding-top: 8px;
}
.pt-9[data-v-6e21cf61] {
  padding-top: 9px;
}
.pt-10[data-v-6e21cf61] {
  padding-top: 10px;
}
.pt-12[data-v-6e21cf61] {
  padding-top: 12px;
}
.pt-14[data-v-6e21cf61] {
  padding-top: 14px;
}
.pt-16[data-v-6e21cf61] {
  padding-top: 16px;
}
.pt-18[data-v-6e21cf61] {
  padding-top: 18px;
}
.pt-20[data-v-6e21cf61] {
  padding-top: 20px;
}
.pt-22[data-v-6e21cf61] {
  padding-top: 22px;
}
.pt-24[data-v-6e21cf61] {
  padding-top: 24px;
}
.pt-26[data-v-6e21cf61] {
  padding-top: 26px;
}
.pt-28[data-v-6e21cf61] {
  padding-top: 28px;
}
.pt-30[data-v-6e21cf61] {
  padding-top: 30px;
}
.pt-32[data-v-6e21cf61] {
  padding-top: 32px;
}
.pt-34[data-v-6e21cf61] {
  padding-top: 34px;
}
.pt-36[data-v-6e21cf61] {
  padding-top: 36px;
}
.pb-0[data-v-6e21cf61] {
  padding-bottom: 0px;
}
.pb-1[data-v-6e21cf61] {
  padding-bottom: 1px;
}
.pb-2[data-v-6e21cf61] {
  padding-bottom: 2px;
}
.pb-3[data-v-6e21cf61] {
  padding-bottom: 3px;
}
.pb-4[data-v-6e21cf61] {
  padding-bottom: 4px;
}
.pb-5[data-v-6e21cf61] {
  padding-bottom: 5px;
}
.pb-6[data-v-6e21cf61] {
  padding-bottom: 6px;
}
.pb-7[data-v-6e21cf61] {
  padding-bottom: 7px;
}
.pb-8[data-v-6e21cf61] {
  padding-bottom: 8px;
}
.pb-9[data-v-6e21cf61] {
  padding-bottom: 9px;
}
.pb-10[data-v-6e21cf61] {
  padding-bottom: 10px;
}
.pb-12[data-v-6e21cf61] {
  padding-bottom: 12px;
}
.pb-14[data-v-6e21cf61] {
  padding-bottom: 14px;
}
.pb-16[data-v-6e21cf61] {
  padding-bottom: 16px;
}
.pb-18[data-v-6e21cf61] {
  padding-bottom: 18px;
}
.pb-20[data-v-6e21cf61] {
  padding-bottom: 20px;
}
.pb-22[data-v-6e21cf61] {
  padding-bottom: 22px;
}
.pb-24[data-v-6e21cf61] {
  padding-bottom: 24px;
}
.pb-26[data-v-6e21cf61] {
  padding-bottom: 26px;
}
.pb-28[data-v-6e21cf61] {
  padding-bottom: 28px;
}
.pb-30[data-v-6e21cf61] {
  padding-bottom: 30px;
}
.pb-32[data-v-6e21cf61] {
  padding-bottom: 32px;
}
.pb-34[data-v-6e21cf61] {
  padding-bottom: 34px;
}
.pb-36[data-v-6e21cf61] {
  padding-bottom: 36px;
}
.pl-0[data-v-6e21cf61] {
  padding-left: 0px;
}
.pl-1[data-v-6e21cf61] {
  padding-left: 1px;
}
.pl-2[data-v-6e21cf61] {
  padding-left: 2px;
}
.pl-3[data-v-6e21cf61] {
  padding-left: 3px;
}
.pl-4[data-v-6e21cf61] {
  padding-left: 4px;
}
.pl-5[data-v-6e21cf61] {
  padding-left: 5px;
}
.pl-6[data-v-6e21cf61] {
  padding-left: 6px;
}
.pl-7[data-v-6e21cf61] {
  padding-left: 7px;
}
.pl-8[data-v-6e21cf61] {
  padding-left: 8px;
}
.pl-9[data-v-6e21cf61] {
  padding-left: 9px;
}
.pl-10[data-v-6e21cf61] {
  padding-left: 10px;
}
.pl-12[data-v-6e21cf61] {
  padding-left: 12px;
}
.pl-14[data-v-6e21cf61] {
  padding-left: 14px;
}
.pl-16[data-v-6e21cf61] {
  padding-left: 16px;
}
.pl-18[data-v-6e21cf61] {
  padding-left: 18px;
}
.pl-20[data-v-6e21cf61] {
  padding-left: 20px;
}
.pl-22[data-v-6e21cf61] {
  padding-left: 22px;
}
.pl-24[data-v-6e21cf61] {
  padding-left: 24px;
}
.pl-26[data-v-6e21cf61] {
  padding-left: 26px;
}
.pl-28[data-v-6e21cf61] {
  padding-left: 28px;
}
.pl-30[data-v-6e21cf61] {
  padding-left: 30px;
}
.pl-32[data-v-6e21cf61] {
  padding-left: 32px;
}
.pl-34[data-v-6e21cf61] {
  padding-left: 34px;
}
.pl-36[data-v-6e21cf61] {
  padding-left: 36px;
}
.pr-0[data-v-6e21cf61] {
  padding-right: 0px;
}
.pr-1[data-v-6e21cf61] {
  padding-right: 1px;
}
.pr-2[data-v-6e21cf61] {
  padding-right: 2px;
}
.pr-3[data-v-6e21cf61] {
  padding-right: 3px;
}
.pr-4[data-v-6e21cf61] {
  padding-right: 4px;
}
.pr-5[data-v-6e21cf61] {
  padding-right: 5px;
}
.pr-6[data-v-6e21cf61] {
  padding-right: 6px;
}
.pr-7[data-v-6e21cf61] {
  padding-right: 7px;
}
.pr-8[data-v-6e21cf61] {
  padding-right: 8px;
}
.pr-9[data-v-6e21cf61] {
  padding-right: 9px;
}
.pr-10[data-v-6e21cf61] {
  padding-right: 10px;
}
.pr-12[data-v-6e21cf61] {
  padding-right: 12px;
}
.pr-14[data-v-6e21cf61] {
  padding-right: 14px;
}
.pr-16[data-v-6e21cf61] {
  padding-right: 16px;
}
.pr-18[data-v-6e21cf61] {
  padding-right: 18px;
}
.pr-20[data-v-6e21cf61] {
  padding-right: 20px;
}
.pr-22[data-v-6e21cf61] {
  padding-right: 22px;
}
.pr-24[data-v-6e21cf61] {
  padding-right: 24px;
}
.pr-26[data-v-6e21cf61] {
  padding-right: 26px;
}
.pr-28[data-v-6e21cf61] {
  padding-right: 28px;
}
.pr-30[data-v-6e21cf61] {
  padding-right: 30px;
}
.pr-32[data-v-6e21cf61] {
  padding-right: 32px;
}
.pr-34[data-v-6e21cf61] {
  padding-right: 34px;
}
.pr-36[data-v-6e21cf61] {
  padding-right: 36px;
}
html[data-v-6e21cf61] {
  --primary-color: #00703d;
  --primary-disabled-color: #99c6b1;
  --primary-bg-color: #edf8ef;
  --white: white;
  --primary-color-20: #00703d33;
  --brand-4: #00703d22;
  --text-1: #1d2920;
  --text-2: #616961;
  --text-3: #979c98;
  --text-4: #b8bbb8;
  --text-blue: #3c68bf;
  --text-red: #d16559;
  --neutral-fill-1: #f8f9f8;
  --neutral-fill-2: #f1f3f1;
  --neutral-fill-3: #e0e3e0;
  --neutral-border: #f2f2f2;
  --neutral-icon: #696d69;
  --blue-bg-color: #f2f7f9;
  --red-bg-color: #fdf2f0;
  --error-1: #e4000c;
  --error-2: #fff3f4;
  --warn-1: #e88e00;
  --warn-2: #fff6e7;
  --antd-wave-shadow-color: var(--primary-color) !important;
}
span[data-v-6e21cf61] {
  color: var(--text-1);
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
}
.text-1[data-v-6e21cf61] {
  color: var(--text-1);
}
.text-2[data-v-6e21cf61] {
  color: var(--text-2);
}
.text-3[data-v-6e21cf61] {
  color: var(--text-3);
}
.text-4[data-v-6e21cf61] {
  color: var(--text-4);
}
.white[data-v-6e21cf61] {
  color: var(--white);
}
.primary-color[data-v-6e21cf61] {
  color: var(--primary-color);
}
.error-color[data-v-6e21cf61] {
  color: var(--error-1);
}
.neutral-icon[data-v-6e21cf61] {
  color: var(--neutral-icon);
}
.channel-avatar[data-v-6e21cf61] {
  position: relative;
  width: 40px;
  height: 40px;
}
.channel-avatar-content[data-v-6e21cf61] {
  border-radius: 50%;
  overflow: hidden;
  width: 40px;
  height: 40px;
}
.channel-avatar-badge[data-v-6e21cf61] {
  position: absolute;
  display: flex;
  padding: 1px;
  background-color: white;
  border-radius: 50%;
  right: 0;
  bottom: 0;
  width: 12px;
  height: 12px;
}
.w-100[data-v-d1e6fcc1] {
  font-weight: 100;
}
.w-200[data-v-d1e6fcc1] {
  font-weight: 200;
}
.w-300[data-v-d1e6fcc1] {
  font-weight: 300;
}
.w-400[data-v-d1e6fcc1] {
  font-weight: 400;
}
.w-500[data-v-d1e6fcc1] {
  font-weight: 500;
}
.w-600[data-v-d1e6fcc1] {
  font-weight: 600;
}
.w-700[data-v-d1e6fcc1] {
  font-weight: 700;
}
.w-800[data-v-d1e6fcc1] {
  font-weight: 800;
}
.w-900[data-v-d1e6fcc1] {
  font-weight: 900;
}
html[data-v-d1e6fcc1] {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.s-8[data-v-d1e6fcc1] {
  font-size: 8px;
}
.s-10[data-v-d1e6fcc1] {
  font-size: 10px;
}
.s-12[data-v-d1e6fcc1] {
  font-size: 12px;
}
.s-13[data-v-d1e6fcc1] {
  font-size: 13px;
}
.s-14[data-v-d1e6fcc1] {
  font-size: 14px;
}
.s-16[data-v-d1e6fcc1] {
  font-size: 16px;
}
.s-18[data-v-d1e6fcc1] {
  font-size: 18px;
}
.s-20[data-v-d1e6fcc1] {
  font-size: 20px;
}
.s-22[data-v-d1e6fcc1] {
  font-size: 22px;
}
.s-24[data-v-d1e6fcc1] {
  font-size: 24px;
}
.s-32[data-v-d1e6fcc1] {
  font-size: 32px;
}
.s-36[data-v-d1e6fcc1] {
  font-size: 36px;
}
.s-40[data-v-d1e6fcc1] {
  font-size: 40px;
}
.l-8[data-v-d1e6fcc1] {
  line-height: 8px;
}
.l-10[data-v-d1e6fcc1] {
  line-height: 10px;
}
.l-12[data-v-d1e6fcc1] {
  line-height: 12px;
}
.l-13[data-v-d1e6fcc1] {
  line-height: 13px;
}
.l-14[data-v-d1e6fcc1] {
  line-height: 14px;
}
.l-16[data-v-d1e6fcc1] {
  line-height: 16px;
}
.l-18[data-v-d1e6fcc1] {
  line-height: 18px;
}
.l-20[data-v-d1e6fcc1] {
  line-height: 20px;
}
.l-22[data-v-d1e6fcc1] {
  line-height: 22px;
}
.l-24[data-v-d1e6fcc1] {
  line-height: 24px;
}
.l-32[data-v-d1e6fcc1] {
  line-height: 32px;
}
.l-36[data-v-d1e6fcc1] {
  line-height: 36px;
}
.l-40[data-v-d1e6fcc1] {
  line-height: 40px;
}
.mt-0[data-v-d1e6fcc1] {
  margin-top: 0px;
}
.mt-1[data-v-d1e6fcc1] {
  margin-top: 1px;
}
.mt-2[data-v-d1e6fcc1] {
  margin-top: 2px;
}
.mt-3[data-v-d1e6fcc1] {
  margin-top: 3px;
}
.mt-4[data-v-d1e6fcc1] {
  margin-top: 4px;
}
.mt-5[data-v-d1e6fcc1] {
  margin-top: 5px;
}
.mt-6[data-v-d1e6fcc1] {
  margin-top: 6px;
}
.mt-7[data-v-d1e6fcc1] {
  margin-top: 7px;
}
.mt-8[data-v-d1e6fcc1] {
  margin-top: 8px;
}
.mt-9[data-v-d1e6fcc1] {
  margin-top: 9px;
}
.mt-10[data-v-d1e6fcc1] {
  margin-top: 10px;
}
.mt-12[data-v-d1e6fcc1] {
  margin-top: 12px;
}
.mt-14[data-v-d1e6fcc1] {
  margin-top: 14px;
}
.mt-16[data-v-d1e6fcc1] {
  margin-top: 16px;
}
.mt-18[data-v-d1e6fcc1] {
  margin-top: 18px;
}
.mt-20[data-v-d1e6fcc1] {
  margin-top: 20px;
}
.mt-22[data-v-d1e6fcc1] {
  margin-top: 22px;
}
.mt-24[data-v-d1e6fcc1] {
  margin-top: 24px;
}
.mt-26[data-v-d1e6fcc1] {
  margin-top: 26px;
}
.mt-28[data-v-d1e6fcc1] {
  margin-top: 28px;
}
.mt-30[data-v-d1e6fcc1] {
  margin-top: 30px;
}
.mt-32[data-v-d1e6fcc1] {
  margin-top: 32px;
}
.mt-34[data-v-d1e6fcc1] {
  margin-top: 34px;
}
.mt-36[data-v-d1e6fcc1] {
  margin-top: 36px;
}
.mb-0[data-v-d1e6fcc1] {
  margin-bottom: 0px;
}
.mb-1[data-v-d1e6fcc1] {
  margin-bottom: 1px;
}
.mb-2[data-v-d1e6fcc1] {
  margin-bottom: 2px;
}
.mb-3[data-v-d1e6fcc1] {
  margin-bottom: 3px;
}
.mb-4[data-v-d1e6fcc1] {
  margin-bottom: 4px;
}
.mb-5[data-v-d1e6fcc1] {
  margin-bottom: 5px;
}
.mb-6[data-v-d1e6fcc1] {
  margin-bottom: 6px;
}
.mb-7[data-v-d1e6fcc1] {
  margin-bottom: 7px;
}
.mb-8[data-v-d1e6fcc1] {
  margin-bottom: 8px;
}
.mb-9[data-v-d1e6fcc1] {
  margin-bottom: 9px;
}
.mb-10[data-v-d1e6fcc1] {
  margin-bottom: 10px;
}
.mb-12[data-v-d1e6fcc1] {
  margin-bottom: 12px;
}
.mb-14[data-v-d1e6fcc1] {
  margin-bottom: 14px;
}
.mb-16[data-v-d1e6fcc1] {
  margin-bottom: 16px;
}
.mb-18[data-v-d1e6fcc1] {
  margin-bottom: 18px;
}
.mb-20[data-v-d1e6fcc1] {
  margin-bottom: 20px;
}
.mb-22[data-v-d1e6fcc1] {
  margin-bottom: 22px;
}
.mb-24[data-v-d1e6fcc1] {
  margin-bottom: 24px;
}
.mb-26[data-v-d1e6fcc1] {
  margin-bottom: 26px;
}
.mb-28[data-v-d1e6fcc1] {
  margin-bottom: 28px;
}
.mb-30[data-v-d1e6fcc1] {
  margin-bottom: 30px;
}
.mb-32[data-v-d1e6fcc1] {
  margin-bottom: 32px;
}
.mb-34[data-v-d1e6fcc1] {
  margin-bottom: 34px;
}
.mb-36[data-v-d1e6fcc1] {
  margin-bottom: 36px;
}
.ml-0[data-v-d1e6fcc1] {
  margin-left: 0px;
}
.ml-1[data-v-d1e6fcc1] {
  margin-left: 1px;
}
.ml-2[data-v-d1e6fcc1] {
  margin-left: 2px;
}
.ml-3[data-v-d1e6fcc1] {
  margin-left: 3px;
}
.ml-4[data-v-d1e6fcc1] {
  margin-left: 4px;
}
.ml-5[data-v-d1e6fcc1] {
  margin-left: 5px;
}
.ml-6[data-v-d1e6fcc1] {
  margin-left: 6px;
}
.ml-7[data-v-d1e6fcc1] {
  margin-left: 7px;
}
.ml-8[data-v-d1e6fcc1] {
  margin-left: 8px;
}
.ml-9[data-v-d1e6fcc1] {
  margin-left: 9px;
}
.ml-10[data-v-d1e6fcc1] {
  margin-left: 10px;
}
.ml-12[data-v-d1e6fcc1] {
  margin-left: 12px;
}
.ml-14[data-v-d1e6fcc1] {
  margin-left: 14px;
}
.ml-16[data-v-d1e6fcc1] {
  margin-left: 16px;
}
.ml-18[data-v-d1e6fcc1] {
  margin-left: 18px;
}
.ml-20[data-v-d1e6fcc1] {
  margin-left: 20px;
}
.ml-22[data-v-d1e6fcc1] {
  margin-left: 22px;
}
.ml-24[data-v-d1e6fcc1] {
  margin-left: 24px;
}
.ml-26[data-v-d1e6fcc1] {
  margin-left: 26px;
}
.ml-28[data-v-d1e6fcc1] {
  margin-left: 28px;
}
.ml-30[data-v-d1e6fcc1] {
  margin-left: 30px;
}
.ml-32[data-v-d1e6fcc1] {
  margin-left: 32px;
}
.ml-34[data-v-d1e6fcc1] {
  margin-left: 34px;
}
.ml-36[data-v-d1e6fcc1] {
  margin-left: 36px;
}
.mr-0[data-v-d1e6fcc1] {
  margin-right: 0px;
}
.mr-1[data-v-d1e6fcc1] {
  margin-right: 1px;
}
.mr-2[data-v-d1e6fcc1] {
  margin-right: 2px;
}
.mr-3[data-v-d1e6fcc1] {
  margin-right: 3px;
}
.mr-4[data-v-d1e6fcc1] {
  margin-right: 4px;
}
.mr-5[data-v-d1e6fcc1] {
  margin-right: 5px;
}
.mr-6[data-v-d1e6fcc1] {
  margin-right: 6px;
}
.mr-7[data-v-d1e6fcc1] {
  margin-right: 7px;
}
.mr-8[data-v-d1e6fcc1] {
  margin-right: 8px;
}
.mr-9[data-v-d1e6fcc1] {
  margin-right: 9px;
}
.mr-10[data-v-d1e6fcc1] {
  margin-right: 10px;
}
.mr-12[data-v-d1e6fcc1] {
  margin-right: 12px;
}
.mr-14[data-v-d1e6fcc1] {
  margin-right: 14px;
}
.mr-16[data-v-d1e6fcc1] {
  margin-right: 16px;
}
.mr-18[data-v-d1e6fcc1] {
  margin-right: 18px;
}
.mr-20[data-v-d1e6fcc1] {
  margin-right: 20px;
}
.mr-22[data-v-d1e6fcc1] {
  margin-right: 22px;
}
.mr-24[data-v-d1e6fcc1] {
  margin-right: 24px;
}
.mr-26[data-v-d1e6fcc1] {
  margin-right: 26px;
}
.mr-28[data-v-d1e6fcc1] {
  margin-right: 28px;
}
.mr-30[data-v-d1e6fcc1] {
  margin-right: 30px;
}
.mr-32[data-v-d1e6fcc1] {
  margin-right: 32px;
}
.mr-34[data-v-d1e6fcc1] {
  margin-right: 34px;
}
.mr-36[data-v-d1e6fcc1] {
  margin-right: 36px;
}
.pt-0[data-v-d1e6fcc1] {
  padding-top: 0px;
}
.pt-1[data-v-d1e6fcc1] {
  padding-top: 1px;
}
.pt-2[data-v-d1e6fcc1] {
  padding-top: 2px;
}
.pt-3[data-v-d1e6fcc1] {
  padding-top: 3px;
}
.pt-4[data-v-d1e6fcc1] {
  padding-top: 4px;
}
.pt-5[data-v-d1e6fcc1] {
  padding-top: 5px;
}
.pt-6[data-v-d1e6fcc1] {
  padding-top: 6px;
}
.pt-7[data-v-d1e6fcc1] {
  padding-top: 7px;
}
.pt-8[data-v-d1e6fcc1] {
  padding-top: 8px;
}
.pt-9[data-v-d1e6fcc1] {
  padding-top: 9px;
}
.pt-10[data-v-d1e6fcc1] {
  padding-top: 10px;
}
.pt-12[data-v-d1e6fcc1] {
  padding-top: 12px;
}
.pt-14[data-v-d1e6fcc1] {
  padding-top: 14px;
}
.pt-16[data-v-d1e6fcc1] {
  padding-top: 16px;
}
.pt-18[data-v-d1e6fcc1] {
  padding-top: 18px;
}
.pt-20[data-v-d1e6fcc1] {
  padding-top: 20px;
}
.pt-22[data-v-d1e6fcc1] {
  padding-top: 22px;
}
.pt-24[data-v-d1e6fcc1] {
  padding-top: 24px;
}
.pt-26[data-v-d1e6fcc1] {
  padding-top: 26px;
}
.pt-28[data-v-d1e6fcc1] {
  padding-top: 28px;
}
.pt-30[data-v-d1e6fcc1] {
  padding-top: 30px;
}
.pt-32[data-v-d1e6fcc1] {
  padding-top: 32px;
}
.pt-34[data-v-d1e6fcc1] {
  padding-top: 34px;
}
.pt-36[data-v-d1e6fcc1] {
  padding-top: 36px;
}
.pb-0[data-v-d1e6fcc1] {
  padding-bottom: 0px;
}
.pb-1[data-v-d1e6fcc1] {
  padding-bottom: 1px;
}
.pb-2[data-v-d1e6fcc1] {
  padding-bottom: 2px;
}
.pb-3[data-v-d1e6fcc1] {
  padding-bottom: 3px;
}
.pb-4[data-v-d1e6fcc1] {
  padding-bottom: 4px;
}
.pb-5[data-v-d1e6fcc1] {
  padding-bottom: 5px;
}
.pb-6[data-v-d1e6fcc1] {
  padding-bottom: 6px;
}
.pb-7[data-v-d1e6fcc1] {
  padding-bottom: 7px;
}
.pb-8[data-v-d1e6fcc1] {
  padding-bottom: 8px;
}
.pb-9[data-v-d1e6fcc1] {
  padding-bottom: 9px;
}
.pb-10[data-v-d1e6fcc1] {
  padding-bottom: 10px;
}
.pb-12[data-v-d1e6fcc1] {
  padding-bottom: 12px;
}
.pb-14[data-v-d1e6fcc1] {
  padding-bottom: 14px;
}
.pb-16[data-v-d1e6fcc1] {
  padding-bottom: 16px;
}
.pb-18[data-v-d1e6fcc1] {
  padding-bottom: 18px;
}
.pb-20[data-v-d1e6fcc1] {
  padding-bottom: 20px;
}
.pb-22[data-v-d1e6fcc1] {
  padding-bottom: 22px;
}
.pb-24[data-v-d1e6fcc1] {
  padding-bottom: 24px;
}
.pb-26[data-v-d1e6fcc1] {
  padding-bottom: 26px;
}
.pb-28[data-v-d1e6fcc1] {
  padding-bottom: 28px;
}
.pb-30[data-v-d1e6fcc1] {
  padding-bottom: 30px;
}
.pb-32[data-v-d1e6fcc1] {
  padding-bottom: 32px;
}
.pb-34[data-v-d1e6fcc1] {
  padding-bottom: 34px;
}
.pb-36[data-v-d1e6fcc1] {
  padding-bottom: 36px;
}
.pl-0[data-v-d1e6fcc1] {
  padding-left: 0px;
}
.pl-1[data-v-d1e6fcc1] {
  padding-left: 1px;
}
.pl-2[data-v-d1e6fcc1] {
  padding-left: 2px;
}
.pl-3[data-v-d1e6fcc1] {
  padding-left: 3px;
}
.pl-4[data-v-d1e6fcc1] {
  padding-left: 4px;
}
.pl-5[data-v-d1e6fcc1] {
  padding-left: 5px;
}
.pl-6[data-v-d1e6fcc1] {
  padding-left: 6px;
}
.pl-7[data-v-d1e6fcc1] {
  padding-left: 7px;
}
.pl-8[data-v-d1e6fcc1] {
  padding-left: 8px;
}
.pl-9[data-v-d1e6fcc1] {
  padding-left: 9px;
}
.pl-10[data-v-d1e6fcc1] {
  padding-left: 10px;
}
.pl-12[data-v-d1e6fcc1] {
  padding-left: 12px;
}
.pl-14[data-v-d1e6fcc1] {
  padding-left: 14px;
}
.pl-16[data-v-d1e6fcc1] {
  padding-left: 16px;
}
.pl-18[data-v-d1e6fcc1] {
  padding-left: 18px;
}
.pl-20[data-v-d1e6fcc1] {
  padding-left: 20px;
}
.pl-22[data-v-d1e6fcc1] {
  padding-left: 22px;
}
.pl-24[data-v-d1e6fcc1] {
  padding-left: 24px;
}
.pl-26[data-v-d1e6fcc1] {
  padding-left: 26px;
}
.pl-28[data-v-d1e6fcc1] {
  padding-left: 28px;
}
.pl-30[data-v-d1e6fcc1] {
  padding-left: 30px;
}
.pl-32[data-v-d1e6fcc1] {
  padding-left: 32px;
}
.pl-34[data-v-d1e6fcc1] {
  padding-left: 34px;
}
.pl-36[data-v-d1e6fcc1] {
  padding-left: 36px;
}
.pr-0[data-v-d1e6fcc1] {
  padding-right: 0px;
}
.pr-1[data-v-d1e6fcc1] {
  padding-right: 1px;
}
.pr-2[data-v-d1e6fcc1] {
  padding-right: 2px;
}
.pr-3[data-v-d1e6fcc1] {
  padding-right: 3px;
}
.pr-4[data-v-d1e6fcc1] {
  padding-right: 4px;
}
.pr-5[data-v-d1e6fcc1] {
  padding-right: 5px;
}
.pr-6[data-v-d1e6fcc1] {
  padding-right: 6px;
}
.pr-7[data-v-d1e6fcc1] {
  padding-right: 7px;
}
.pr-8[data-v-d1e6fcc1] {
  padding-right: 8px;
}
.pr-9[data-v-d1e6fcc1] {
  padding-right: 9px;
}
.pr-10[data-v-d1e6fcc1] {
  padding-right: 10px;
}
.pr-12[data-v-d1e6fcc1] {
  padding-right: 12px;
}
.pr-14[data-v-d1e6fcc1] {
  padding-right: 14px;
}
.pr-16[data-v-d1e6fcc1] {
  padding-right: 16px;
}
.pr-18[data-v-d1e6fcc1] {
  padding-right: 18px;
}
.pr-20[data-v-d1e6fcc1] {
  padding-right: 20px;
}
.pr-22[data-v-d1e6fcc1] {
  padding-right: 22px;
}
.pr-24[data-v-d1e6fcc1] {
  padding-right: 24px;
}
.pr-26[data-v-d1e6fcc1] {
  padding-right: 26px;
}
.pr-28[data-v-d1e6fcc1] {
  padding-right: 28px;
}
.pr-30[data-v-d1e6fcc1] {
  padding-right: 30px;
}
.pr-32[data-v-d1e6fcc1] {
  padding-right: 32px;
}
.pr-34[data-v-d1e6fcc1] {
  padding-right: 34px;
}
.pr-36[data-v-d1e6fcc1] {
  padding-right: 36px;
}
html[data-v-d1e6fcc1] {
  --primary-color: #00703d;
  --primary-disabled-color: #99c6b1;
  --primary-bg-color: #edf8ef;
  --white: white;
  --primary-color-20: #00703d33;
  --brand-4: #00703d22;
  --text-1: #1d2920;
  --text-2: #616961;
  --text-3: #979c98;
  --text-4: #b8bbb8;
  --text-blue: #3c68bf;
  --text-red: #d16559;
  --neutral-fill-1: #f8f9f8;
  --neutral-fill-2: #f1f3f1;
  --neutral-fill-3: #e0e3e0;
  --neutral-border: #f2f2f2;
  --neutral-icon: #696d69;
  --blue-bg-color: #f2f7f9;
  --red-bg-color: #fdf2f0;
  --error-1: #e4000c;
  --error-2: #fff3f4;
  --warn-1: #e88e00;
  --warn-2: #fff6e7;
  --antd-wave-shadow-color: var(--primary-color) !important;
}
span[data-v-d1e6fcc1] {
  color: var(--text-1);
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
}
.text-1[data-v-d1e6fcc1] {
  color: var(--text-1);
}
.text-2[data-v-d1e6fcc1] {
  color: var(--text-2);
}
.text-3[data-v-d1e6fcc1] {
  color: var(--text-3);
}
.text-4[data-v-d1e6fcc1] {
  color: var(--text-4);
}
.white[data-v-d1e6fcc1] {
  color: var(--white);
}
.primary-color[data-v-d1e6fcc1] {
  color: var(--primary-color);
}
.error-color[data-v-d1e6fcc1] {
  color: var(--error-1);
}
.neutral-icon[data-v-d1e6fcc1] {
  color: var(--neutral-icon);
}
.chat-content[data-v-d1e6fcc1] {
  display: flex;
  flex-direction: column;
}
.main-chat[data-v-d1e6fcc1] {
  display: flex;
  gap: 12px;
  margin-right: 48px;
  margin-top: 8px;
}
.main-chat-wrapper[data-v-d1e6fcc1] {
  display: flex;
  flex-direction: column;
  align-items: start;
}
.main-chat-bubble[data-v-d1e6fcc1] {
  padding: 8px 12px;
  background-color: white;
  border-radius: 4px;
  width: fit-content;
  height: fit-content;
  margin-left: 52px;
}
.main-chat-bubble.my-chat[data-v-d1e6fcc1] {
  background-color: var(--bubble-color);
  margin-right: 52px;
  margin-left: 0px;
}
.main-chat-bubble.first-chat[data-v-d1e6fcc1] {
  margin-inline: 0px;
}
.main-chat.my-chat[data-v-d1e6fcc1] {
  flex-direction: row-reverse;
  margin-right: 0px;
  margin-left: 48px;
}
.main-chat.first-chat[data-v-d1e6fcc1] {
  margin-top: 24px;
}
.username-label[data-v-d1e6fcc1] {
  color: #616961;
}
.w-100[data-v-0bd73be3] {
  font-weight: 100;
}
.w-200[data-v-0bd73be3] {
  font-weight: 200;
}
.w-300[data-v-0bd73be3] {
  font-weight: 300;
}
.w-400[data-v-0bd73be3] {
  font-weight: 400;
}
.w-500[data-v-0bd73be3] {
  font-weight: 500;
}
.w-600[data-v-0bd73be3] {
  font-weight: 600;
}
.w-700[data-v-0bd73be3] {
  font-weight: 700;
}
.w-800[data-v-0bd73be3] {
  font-weight: 800;
}
.w-900[data-v-0bd73be3] {
  font-weight: 900;
}
html[data-v-0bd73be3] {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.s-8[data-v-0bd73be3] {
  font-size: 8px;
}
.s-10[data-v-0bd73be3] {
  font-size: 10px;
}
.s-12[data-v-0bd73be3] {
  font-size: 12px;
}
.s-13[data-v-0bd73be3] {
  font-size: 13px;
}
.s-14[data-v-0bd73be3] {
  font-size: 14px;
}
.s-16[data-v-0bd73be3] {
  font-size: 16px;
}
.s-18[data-v-0bd73be3] {
  font-size: 18px;
}
.s-20[data-v-0bd73be3] {
  font-size: 20px;
}
.s-22[data-v-0bd73be3] {
  font-size: 22px;
}
.s-24[data-v-0bd73be3] {
  font-size: 24px;
}
.s-32[data-v-0bd73be3] {
  font-size: 32px;
}
.s-36[data-v-0bd73be3] {
  font-size: 36px;
}
.s-40[data-v-0bd73be3] {
  font-size: 40px;
}
.l-8[data-v-0bd73be3] {
  line-height: 8px;
}
.l-10[data-v-0bd73be3] {
  line-height: 10px;
}
.l-12[data-v-0bd73be3] {
  line-height: 12px;
}
.l-13[data-v-0bd73be3] {
  line-height: 13px;
}
.l-14[data-v-0bd73be3] {
  line-height: 14px;
}
.l-16[data-v-0bd73be3] {
  line-height: 16px;
}
.l-18[data-v-0bd73be3] {
  line-height: 18px;
}
.l-20[data-v-0bd73be3] {
  line-height: 20px;
}
.l-22[data-v-0bd73be3] {
  line-height: 22px;
}
.l-24[data-v-0bd73be3] {
  line-height: 24px;
}
.l-32[data-v-0bd73be3] {
  line-height: 32px;
}
.l-36[data-v-0bd73be3] {
  line-height: 36px;
}
.l-40[data-v-0bd73be3] {
  line-height: 40px;
}
.mt-0[data-v-0bd73be3] {
  margin-top: 0px;
}
.mt-1[data-v-0bd73be3] {
  margin-top: 1px;
}
.mt-2[data-v-0bd73be3] {
  margin-top: 2px;
}
.mt-3[data-v-0bd73be3] {
  margin-top: 3px;
}
.mt-4[data-v-0bd73be3] {
  margin-top: 4px;
}
.mt-5[data-v-0bd73be3] {
  margin-top: 5px;
}
.mt-6[data-v-0bd73be3] {
  margin-top: 6px;
}
.mt-7[data-v-0bd73be3] {
  margin-top: 7px;
}
.mt-8[data-v-0bd73be3] {
  margin-top: 8px;
}
.mt-9[data-v-0bd73be3] {
  margin-top: 9px;
}
.mt-10[data-v-0bd73be3] {
  margin-top: 10px;
}
.mt-12[data-v-0bd73be3] {
  margin-top: 12px;
}
.mt-14[data-v-0bd73be3] {
  margin-top: 14px;
}
.mt-16[data-v-0bd73be3] {
  margin-top: 16px;
}
.mt-18[data-v-0bd73be3] {
  margin-top: 18px;
}
.mt-20[data-v-0bd73be3] {
  margin-top: 20px;
}
.mt-22[data-v-0bd73be3] {
  margin-top: 22px;
}
.mt-24[data-v-0bd73be3] {
  margin-top: 24px;
}
.mt-26[data-v-0bd73be3] {
  margin-top: 26px;
}
.mt-28[data-v-0bd73be3] {
  margin-top: 28px;
}
.mt-30[data-v-0bd73be3] {
  margin-top: 30px;
}
.mt-32[data-v-0bd73be3] {
  margin-top: 32px;
}
.mt-34[data-v-0bd73be3] {
  margin-top: 34px;
}
.mt-36[data-v-0bd73be3] {
  margin-top: 36px;
}
.mb-0[data-v-0bd73be3] {
  margin-bottom: 0px;
}
.mb-1[data-v-0bd73be3] {
  margin-bottom: 1px;
}
.mb-2[data-v-0bd73be3] {
  margin-bottom: 2px;
}
.mb-3[data-v-0bd73be3] {
  margin-bottom: 3px;
}
.mb-4[data-v-0bd73be3] {
  margin-bottom: 4px;
}
.mb-5[data-v-0bd73be3] {
  margin-bottom: 5px;
}
.mb-6[data-v-0bd73be3] {
  margin-bottom: 6px;
}
.mb-7[data-v-0bd73be3] {
  margin-bottom: 7px;
}
.mb-8[data-v-0bd73be3] {
  margin-bottom: 8px;
}
.mb-9[data-v-0bd73be3] {
  margin-bottom: 9px;
}
.mb-10[data-v-0bd73be3] {
  margin-bottom: 10px;
}
.mb-12[data-v-0bd73be3] {
  margin-bottom: 12px;
}
.mb-14[data-v-0bd73be3] {
  margin-bottom: 14px;
}
.mb-16[data-v-0bd73be3] {
  margin-bottom: 16px;
}
.mb-18[data-v-0bd73be3] {
  margin-bottom: 18px;
}
.mb-20[data-v-0bd73be3] {
  margin-bottom: 20px;
}
.mb-22[data-v-0bd73be3] {
  margin-bottom: 22px;
}
.mb-24[data-v-0bd73be3] {
  margin-bottom: 24px;
}
.mb-26[data-v-0bd73be3] {
  margin-bottom: 26px;
}
.mb-28[data-v-0bd73be3] {
  margin-bottom: 28px;
}
.mb-30[data-v-0bd73be3] {
  margin-bottom: 30px;
}
.mb-32[data-v-0bd73be3] {
  margin-bottom: 32px;
}
.mb-34[data-v-0bd73be3] {
  margin-bottom: 34px;
}
.mb-36[data-v-0bd73be3] {
  margin-bottom: 36px;
}
.ml-0[data-v-0bd73be3] {
  margin-left: 0px;
}
.ml-1[data-v-0bd73be3] {
  margin-left: 1px;
}
.ml-2[data-v-0bd73be3] {
  margin-left: 2px;
}
.ml-3[data-v-0bd73be3] {
  margin-left: 3px;
}
.ml-4[data-v-0bd73be3] {
  margin-left: 4px;
}
.ml-5[data-v-0bd73be3] {
  margin-left: 5px;
}
.ml-6[data-v-0bd73be3] {
  margin-left: 6px;
}
.ml-7[data-v-0bd73be3] {
  margin-left: 7px;
}
.ml-8[data-v-0bd73be3] {
  margin-left: 8px;
}
.ml-9[data-v-0bd73be3] {
  margin-left: 9px;
}
.ml-10[data-v-0bd73be3] {
  margin-left: 10px;
}
.ml-12[data-v-0bd73be3] {
  margin-left: 12px;
}
.ml-14[data-v-0bd73be3] {
  margin-left: 14px;
}
.ml-16[data-v-0bd73be3] {
  margin-left: 16px;
}
.ml-18[data-v-0bd73be3] {
  margin-left: 18px;
}
.ml-20[data-v-0bd73be3] {
  margin-left: 20px;
}
.ml-22[data-v-0bd73be3] {
  margin-left: 22px;
}
.ml-24[data-v-0bd73be3] {
  margin-left: 24px;
}
.ml-26[data-v-0bd73be3] {
  margin-left: 26px;
}
.ml-28[data-v-0bd73be3] {
  margin-left: 28px;
}
.ml-30[data-v-0bd73be3] {
  margin-left: 30px;
}
.ml-32[data-v-0bd73be3] {
  margin-left: 32px;
}
.ml-34[data-v-0bd73be3] {
  margin-left: 34px;
}
.ml-36[data-v-0bd73be3] {
  margin-left: 36px;
}
.mr-0[data-v-0bd73be3] {
  margin-right: 0px;
}
.mr-1[data-v-0bd73be3] {
  margin-right: 1px;
}
.mr-2[data-v-0bd73be3] {
  margin-right: 2px;
}
.mr-3[data-v-0bd73be3] {
  margin-right: 3px;
}
.mr-4[data-v-0bd73be3] {
  margin-right: 4px;
}
.mr-5[data-v-0bd73be3] {
  margin-right: 5px;
}
.mr-6[data-v-0bd73be3] {
  margin-right: 6px;
}
.mr-7[data-v-0bd73be3] {
  margin-right: 7px;
}
.mr-8[data-v-0bd73be3] {
  margin-right: 8px;
}
.mr-9[data-v-0bd73be3] {
  margin-right: 9px;
}
.mr-10[data-v-0bd73be3] {
  margin-right: 10px;
}
.mr-12[data-v-0bd73be3] {
  margin-right: 12px;
}
.mr-14[data-v-0bd73be3] {
  margin-right: 14px;
}
.mr-16[data-v-0bd73be3] {
  margin-right: 16px;
}
.mr-18[data-v-0bd73be3] {
  margin-right: 18px;
}
.mr-20[data-v-0bd73be3] {
  margin-right: 20px;
}
.mr-22[data-v-0bd73be3] {
  margin-right: 22px;
}
.mr-24[data-v-0bd73be3] {
  margin-right: 24px;
}
.mr-26[data-v-0bd73be3] {
  margin-right: 26px;
}
.mr-28[data-v-0bd73be3] {
  margin-right: 28px;
}
.mr-30[data-v-0bd73be3] {
  margin-right: 30px;
}
.mr-32[data-v-0bd73be3] {
  margin-right: 32px;
}
.mr-34[data-v-0bd73be3] {
  margin-right: 34px;
}
.mr-36[data-v-0bd73be3] {
  margin-right: 36px;
}
.pt-0[data-v-0bd73be3] {
  padding-top: 0px;
}
.pt-1[data-v-0bd73be3] {
  padding-top: 1px;
}
.pt-2[data-v-0bd73be3] {
  padding-top: 2px;
}
.pt-3[data-v-0bd73be3] {
  padding-top: 3px;
}
.pt-4[data-v-0bd73be3] {
  padding-top: 4px;
}
.pt-5[data-v-0bd73be3] {
  padding-top: 5px;
}
.pt-6[data-v-0bd73be3] {
  padding-top: 6px;
}
.pt-7[data-v-0bd73be3] {
  padding-top: 7px;
}
.pt-8[data-v-0bd73be3] {
  padding-top: 8px;
}
.pt-9[data-v-0bd73be3] {
  padding-top: 9px;
}
.pt-10[data-v-0bd73be3] {
  padding-top: 10px;
}
.pt-12[data-v-0bd73be3] {
  padding-top: 12px;
}
.pt-14[data-v-0bd73be3] {
  padding-top: 14px;
}
.pt-16[data-v-0bd73be3] {
  padding-top: 16px;
}
.pt-18[data-v-0bd73be3] {
  padding-top: 18px;
}
.pt-20[data-v-0bd73be3] {
  padding-top: 20px;
}
.pt-22[data-v-0bd73be3] {
  padding-top: 22px;
}
.pt-24[data-v-0bd73be3] {
  padding-top: 24px;
}
.pt-26[data-v-0bd73be3] {
  padding-top: 26px;
}
.pt-28[data-v-0bd73be3] {
  padding-top: 28px;
}
.pt-30[data-v-0bd73be3] {
  padding-top: 30px;
}
.pt-32[data-v-0bd73be3] {
  padding-top: 32px;
}
.pt-34[data-v-0bd73be3] {
  padding-top: 34px;
}
.pt-36[data-v-0bd73be3] {
  padding-top: 36px;
}
.pb-0[data-v-0bd73be3] {
  padding-bottom: 0px;
}
.pb-1[data-v-0bd73be3] {
  padding-bottom: 1px;
}
.pb-2[data-v-0bd73be3] {
  padding-bottom: 2px;
}
.pb-3[data-v-0bd73be3] {
  padding-bottom: 3px;
}
.pb-4[data-v-0bd73be3] {
  padding-bottom: 4px;
}
.pb-5[data-v-0bd73be3] {
  padding-bottom: 5px;
}
.pb-6[data-v-0bd73be3] {
  padding-bottom: 6px;
}
.pb-7[data-v-0bd73be3] {
  padding-bottom: 7px;
}
.pb-8[data-v-0bd73be3] {
  padding-bottom: 8px;
}
.pb-9[data-v-0bd73be3] {
  padding-bottom: 9px;
}
.pb-10[data-v-0bd73be3] {
  padding-bottom: 10px;
}
.pb-12[data-v-0bd73be3] {
  padding-bottom: 12px;
}
.pb-14[data-v-0bd73be3] {
  padding-bottom: 14px;
}
.pb-16[data-v-0bd73be3] {
  padding-bottom: 16px;
}
.pb-18[data-v-0bd73be3] {
  padding-bottom: 18px;
}
.pb-20[data-v-0bd73be3] {
  padding-bottom: 20px;
}
.pb-22[data-v-0bd73be3] {
  padding-bottom: 22px;
}
.pb-24[data-v-0bd73be3] {
  padding-bottom: 24px;
}
.pb-26[data-v-0bd73be3] {
  padding-bottom: 26px;
}
.pb-28[data-v-0bd73be3] {
  padding-bottom: 28px;
}
.pb-30[data-v-0bd73be3] {
  padding-bottom: 30px;
}
.pb-32[data-v-0bd73be3] {
  padding-bottom: 32px;
}
.pb-34[data-v-0bd73be3] {
  padding-bottom: 34px;
}
.pb-36[data-v-0bd73be3] {
  padding-bottom: 36px;
}
.pl-0[data-v-0bd73be3] {
  padding-left: 0px;
}
.pl-1[data-v-0bd73be3] {
  padding-left: 1px;
}
.pl-2[data-v-0bd73be3] {
  padding-left: 2px;
}
.pl-3[data-v-0bd73be3] {
  padding-left: 3px;
}
.pl-4[data-v-0bd73be3] {
  padding-left: 4px;
}
.pl-5[data-v-0bd73be3] {
  padding-left: 5px;
}
.pl-6[data-v-0bd73be3] {
  padding-left: 6px;
}
.pl-7[data-v-0bd73be3] {
  padding-left: 7px;
}
.pl-8[data-v-0bd73be3] {
  padding-left: 8px;
}
.pl-9[data-v-0bd73be3] {
  padding-left: 9px;
}
.pl-10[data-v-0bd73be3] {
  padding-left: 10px;
}
.pl-12[data-v-0bd73be3] {
  padding-left: 12px;
}
.pl-14[data-v-0bd73be3] {
  padding-left: 14px;
}
.pl-16[data-v-0bd73be3] {
  padding-left: 16px;
}
.pl-18[data-v-0bd73be3] {
  padding-left: 18px;
}
.pl-20[data-v-0bd73be3] {
  padding-left: 20px;
}
.pl-22[data-v-0bd73be3] {
  padding-left: 22px;
}
.pl-24[data-v-0bd73be3] {
  padding-left: 24px;
}
.pl-26[data-v-0bd73be3] {
  padding-left: 26px;
}
.pl-28[data-v-0bd73be3] {
  padding-left: 28px;
}
.pl-30[data-v-0bd73be3] {
  padding-left: 30px;
}
.pl-32[data-v-0bd73be3] {
  padding-left: 32px;
}
.pl-34[data-v-0bd73be3] {
  padding-left: 34px;
}
.pl-36[data-v-0bd73be3] {
  padding-left: 36px;
}
.pr-0[data-v-0bd73be3] {
  padding-right: 0px;
}
.pr-1[data-v-0bd73be3] {
  padding-right: 1px;
}
.pr-2[data-v-0bd73be3] {
  padding-right: 2px;
}
.pr-3[data-v-0bd73be3] {
  padding-right: 3px;
}
.pr-4[data-v-0bd73be3] {
  padding-right: 4px;
}
.pr-5[data-v-0bd73be3] {
  padding-right: 5px;
}
.pr-6[data-v-0bd73be3] {
  padding-right: 6px;
}
.pr-7[data-v-0bd73be3] {
  padding-right: 7px;
}
.pr-8[data-v-0bd73be3] {
  padding-right: 8px;
}
.pr-9[data-v-0bd73be3] {
  padding-right: 9px;
}
.pr-10[data-v-0bd73be3] {
  padding-right: 10px;
}
.pr-12[data-v-0bd73be3] {
  padding-right: 12px;
}
.pr-14[data-v-0bd73be3] {
  padding-right: 14px;
}
.pr-16[data-v-0bd73be3] {
  padding-right: 16px;
}
.pr-18[data-v-0bd73be3] {
  padding-right: 18px;
}
.pr-20[data-v-0bd73be3] {
  padding-right: 20px;
}
.pr-22[data-v-0bd73be3] {
  padding-right: 22px;
}
.pr-24[data-v-0bd73be3] {
  padding-right: 24px;
}
.pr-26[data-v-0bd73be3] {
  padding-right: 26px;
}
.pr-28[data-v-0bd73be3] {
  padding-right: 28px;
}
.pr-30[data-v-0bd73be3] {
  padding-right: 30px;
}
.pr-32[data-v-0bd73be3] {
  padding-right: 32px;
}
.pr-34[data-v-0bd73be3] {
  padding-right: 34px;
}
.pr-36[data-v-0bd73be3] {
  padding-right: 36px;
}
html[data-v-0bd73be3] {
  --primary-color: #00703d;
  --primary-disabled-color: #99c6b1;
  --primary-bg-color: #edf8ef;
  --white: white;
  --primary-color-20: #00703d33;
  --brand-4: #00703d22;
  --text-1: #1d2920;
  --text-2: #616961;
  --text-3: #979c98;
  --text-4: #b8bbb8;
  --text-blue: #3c68bf;
  --text-red: #d16559;
  --neutral-fill-1: #f8f9f8;
  --neutral-fill-2: #f1f3f1;
  --neutral-fill-3: #e0e3e0;
  --neutral-border: #f2f2f2;
  --neutral-icon: #696d69;
  --blue-bg-color: #f2f7f9;
  --red-bg-color: #fdf2f0;
  --error-1: #e4000c;
  --error-2: #fff3f4;
  --warn-1: #e88e00;
  --warn-2: #fff6e7;
  --antd-wave-shadow-color: var(--primary-color) !important;
}
span[data-v-0bd73be3] {
  color: var(--text-1);
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
}
.text-1[data-v-0bd73be3] {
  color: var(--text-1);
}
.text-2[data-v-0bd73be3] {
  color: var(--text-2);
}
.text-3[data-v-0bd73be3] {
  color: var(--text-3);
}
.text-4[data-v-0bd73be3] {
  color: var(--text-4);
}
.white[data-v-0bd73be3] {
  color: var(--white);
}
.primary-color[data-v-0bd73be3] {
  color: var(--primary-color);
}
.error-color[data-v-0bd73be3] {
  color: var(--error-1);
}
.neutral-icon[data-v-0bd73be3] {
  color: var(--neutral-icon);
}
.chat-container[data-v-0bd73be3] {
  display: grid;
  grid-template-rows: 1fr auto;
  height: calc(100% - 278px);
  padding-inline: 20px;
  overflow: auto;
}
.chat-container[data-v-0bd73be3]::-webkit-scrollbar {
  width: 0px;
}
.w-100[data-v-7366b548] {
  font-weight: 100;
}
.w-200[data-v-7366b548] {
  font-weight: 200;
}
.w-300[data-v-7366b548] {
  font-weight: 300;
}
.w-400[data-v-7366b548] {
  font-weight: 400;
}
.w-500[data-v-7366b548] {
  font-weight: 500;
}
.w-600[data-v-7366b548] {
  font-weight: 600;
}
.w-700[data-v-7366b548] {
  font-weight: 700;
}
.w-800[data-v-7366b548] {
  font-weight: 800;
}
.w-900[data-v-7366b548] {
  font-weight: 900;
}
html[data-v-7366b548] {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.s-8[data-v-7366b548] {
  font-size: 8px;
}
.s-10[data-v-7366b548] {
  font-size: 10px;
}
.s-12[data-v-7366b548] {
  font-size: 12px;
}
.s-13[data-v-7366b548] {
  font-size: 13px;
}
.s-14[data-v-7366b548] {
  font-size: 14px;
}
.s-16[data-v-7366b548] {
  font-size: 16px;
}
.s-18[data-v-7366b548] {
  font-size: 18px;
}
.s-20[data-v-7366b548] {
  font-size: 20px;
}
.s-22[data-v-7366b548] {
  font-size: 22px;
}
.s-24[data-v-7366b548] {
  font-size: 24px;
}
.s-32[data-v-7366b548] {
  font-size: 32px;
}
.s-36[data-v-7366b548] {
  font-size: 36px;
}
.s-40[data-v-7366b548] {
  font-size: 40px;
}
.l-8[data-v-7366b548] {
  line-height: 8px;
}
.l-10[data-v-7366b548] {
  line-height: 10px;
}
.l-12[data-v-7366b548] {
  line-height: 12px;
}
.l-13[data-v-7366b548] {
  line-height: 13px;
}
.l-14[data-v-7366b548] {
  line-height: 14px;
}
.l-16[data-v-7366b548] {
  line-height: 16px;
}
.l-18[data-v-7366b548] {
  line-height: 18px;
}
.l-20[data-v-7366b548] {
  line-height: 20px;
}
.l-22[data-v-7366b548] {
  line-height: 22px;
}
.l-24[data-v-7366b548] {
  line-height: 24px;
}
.l-32[data-v-7366b548] {
  line-height: 32px;
}
.l-36[data-v-7366b548] {
  line-height: 36px;
}
.l-40[data-v-7366b548] {
  line-height: 40px;
}
.mt-0[data-v-7366b548] {
  margin-top: 0px;
}
.mt-1[data-v-7366b548] {
  margin-top: 1px;
}
.mt-2[data-v-7366b548] {
  margin-top: 2px;
}
.mt-3[data-v-7366b548] {
  margin-top: 3px;
}
.mt-4[data-v-7366b548] {
  margin-top: 4px;
}
.mt-5[data-v-7366b548] {
  margin-top: 5px;
}
.mt-6[data-v-7366b548] {
  margin-top: 6px;
}
.mt-7[data-v-7366b548] {
  margin-top: 7px;
}
.mt-8[data-v-7366b548] {
  margin-top: 8px;
}
.mt-9[data-v-7366b548] {
  margin-top: 9px;
}
.mt-10[data-v-7366b548] {
  margin-top: 10px;
}
.mt-12[data-v-7366b548] {
  margin-top: 12px;
}
.mt-14[data-v-7366b548] {
  margin-top: 14px;
}
.mt-16[data-v-7366b548] {
  margin-top: 16px;
}
.mt-18[data-v-7366b548] {
  margin-top: 18px;
}
.mt-20[data-v-7366b548] {
  margin-top: 20px;
}
.mt-22[data-v-7366b548] {
  margin-top: 22px;
}
.mt-24[data-v-7366b548] {
  margin-top: 24px;
}
.mt-26[data-v-7366b548] {
  margin-top: 26px;
}
.mt-28[data-v-7366b548] {
  margin-top: 28px;
}
.mt-30[data-v-7366b548] {
  margin-top: 30px;
}
.mt-32[data-v-7366b548] {
  margin-top: 32px;
}
.mt-34[data-v-7366b548] {
  margin-top: 34px;
}
.mt-36[data-v-7366b548] {
  margin-top: 36px;
}
.mb-0[data-v-7366b548] {
  margin-bottom: 0px;
}
.mb-1[data-v-7366b548] {
  margin-bottom: 1px;
}
.mb-2[data-v-7366b548] {
  margin-bottom: 2px;
}
.mb-3[data-v-7366b548] {
  margin-bottom: 3px;
}
.mb-4[data-v-7366b548] {
  margin-bottom: 4px;
}
.mb-5[data-v-7366b548] {
  margin-bottom: 5px;
}
.mb-6[data-v-7366b548] {
  margin-bottom: 6px;
}
.mb-7[data-v-7366b548] {
  margin-bottom: 7px;
}
.mb-8[data-v-7366b548] {
  margin-bottom: 8px;
}
.mb-9[data-v-7366b548] {
  margin-bottom: 9px;
}
.mb-10[data-v-7366b548] {
  margin-bottom: 10px;
}
.mb-12[data-v-7366b548] {
  margin-bottom: 12px;
}
.mb-14[data-v-7366b548] {
  margin-bottom: 14px;
}
.mb-16[data-v-7366b548] {
  margin-bottom: 16px;
}
.mb-18[data-v-7366b548] {
  margin-bottom: 18px;
}
.mb-20[data-v-7366b548] {
  margin-bottom: 20px;
}
.mb-22[data-v-7366b548] {
  margin-bottom: 22px;
}
.mb-24[data-v-7366b548] {
  margin-bottom: 24px;
}
.mb-26[data-v-7366b548] {
  margin-bottom: 26px;
}
.mb-28[data-v-7366b548] {
  margin-bottom: 28px;
}
.mb-30[data-v-7366b548] {
  margin-bottom: 30px;
}
.mb-32[data-v-7366b548] {
  margin-bottom: 32px;
}
.mb-34[data-v-7366b548] {
  margin-bottom: 34px;
}
.mb-36[data-v-7366b548] {
  margin-bottom: 36px;
}
.ml-0[data-v-7366b548] {
  margin-left: 0px;
}
.ml-1[data-v-7366b548] {
  margin-left: 1px;
}
.ml-2[data-v-7366b548] {
  margin-left: 2px;
}
.ml-3[data-v-7366b548] {
  margin-left: 3px;
}
.ml-4[data-v-7366b548] {
  margin-left: 4px;
}
.ml-5[data-v-7366b548] {
  margin-left: 5px;
}
.ml-6[data-v-7366b548] {
  margin-left: 6px;
}
.ml-7[data-v-7366b548] {
  margin-left: 7px;
}
.ml-8[data-v-7366b548] {
  margin-left: 8px;
}
.ml-9[data-v-7366b548] {
  margin-left: 9px;
}
.ml-10[data-v-7366b548] {
  margin-left: 10px;
}
.ml-12[data-v-7366b548] {
  margin-left: 12px;
}
.ml-14[data-v-7366b548] {
  margin-left: 14px;
}
.ml-16[data-v-7366b548] {
  margin-left: 16px;
}
.ml-18[data-v-7366b548] {
  margin-left: 18px;
}
.ml-20[data-v-7366b548] {
  margin-left: 20px;
}
.ml-22[data-v-7366b548] {
  margin-left: 22px;
}
.ml-24[data-v-7366b548] {
  margin-left: 24px;
}
.ml-26[data-v-7366b548] {
  margin-left: 26px;
}
.ml-28[data-v-7366b548] {
  margin-left: 28px;
}
.ml-30[data-v-7366b548] {
  margin-left: 30px;
}
.ml-32[data-v-7366b548] {
  margin-left: 32px;
}
.ml-34[data-v-7366b548] {
  margin-left: 34px;
}
.ml-36[data-v-7366b548] {
  margin-left: 36px;
}
.mr-0[data-v-7366b548] {
  margin-right: 0px;
}
.mr-1[data-v-7366b548] {
  margin-right: 1px;
}
.mr-2[data-v-7366b548] {
  margin-right: 2px;
}
.mr-3[data-v-7366b548] {
  margin-right: 3px;
}
.mr-4[data-v-7366b548] {
  margin-right: 4px;
}
.mr-5[data-v-7366b548] {
  margin-right: 5px;
}
.mr-6[data-v-7366b548] {
  margin-right: 6px;
}
.mr-7[data-v-7366b548] {
  margin-right: 7px;
}
.mr-8[data-v-7366b548] {
  margin-right: 8px;
}
.mr-9[data-v-7366b548] {
  margin-right: 9px;
}
.mr-10[data-v-7366b548] {
  margin-right: 10px;
}
.mr-12[data-v-7366b548] {
  margin-right: 12px;
}
.mr-14[data-v-7366b548] {
  margin-right: 14px;
}
.mr-16[data-v-7366b548] {
  margin-right: 16px;
}
.mr-18[data-v-7366b548] {
  margin-right: 18px;
}
.mr-20[data-v-7366b548] {
  margin-right: 20px;
}
.mr-22[data-v-7366b548] {
  margin-right: 22px;
}
.mr-24[data-v-7366b548] {
  margin-right: 24px;
}
.mr-26[data-v-7366b548] {
  margin-right: 26px;
}
.mr-28[data-v-7366b548] {
  margin-right: 28px;
}
.mr-30[data-v-7366b548] {
  margin-right: 30px;
}
.mr-32[data-v-7366b548] {
  margin-right: 32px;
}
.mr-34[data-v-7366b548] {
  margin-right: 34px;
}
.mr-36[data-v-7366b548] {
  margin-right: 36px;
}
.pt-0[data-v-7366b548] {
  padding-top: 0px;
}
.pt-1[data-v-7366b548] {
  padding-top: 1px;
}
.pt-2[data-v-7366b548] {
  padding-top: 2px;
}
.pt-3[data-v-7366b548] {
  padding-top: 3px;
}
.pt-4[data-v-7366b548] {
  padding-top: 4px;
}
.pt-5[data-v-7366b548] {
  padding-top: 5px;
}
.pt-6[data-v-7366b548] {
  padding-top: 6px;
}
.pt-7[data-v-7366b548] {
  padding-top: 7px;
}
.pt-8[data-v-7366b548] {
  padding-top: 8px;
}
.pt-9[data-v-7366b548] {
  padding-top: 9px;
}
.pt-10[data-v-7366b548] {
  padding-top: 10px;
}
.pt-12[data-v-7366b548] {
  padding-top: 12px;
}
.pt-14[data-v-7366b548] {
  padding-top: 14px;
}
.pt-16[data-v-7366b548] {
  padding-top: 16px;
}
.pt-18[data-v-7366b548] {
  padding-top: 18px;
}
.pt-20[data-v-7366b548] {
  padding-top: 20px;
}
.pt-22[data-v-7366b548] {
  padding-top: 22px;
}
.pt-24[data-v-7366b548] {
  padding-top: 24px;
}
.pt-26[data-v-7366b548] {
  padding-top: 26px;
}
.pt-28[data-v-7366b548] {
  padding-top: 28px;
}
.pt-30[data-v-7366b548] {
  padding-top: 30px;
}
.pt-32[data-v-7366b548] {
  padding-top: 32px;
}
.pt-34[data-v-7366b548] {
  padding-top: 34px;
}
.pt-36[data-v-7366b548] {
  padding-top: 36px;
}
.pb-0[data-v-7366b548] {
  padding-bottom: 0px;
}
.pb-1[data-v-7366b548] {
  padding-bottom: 1px;
}
.pb-2[data-v-7366b548] {
  padding-bottom: 2px;
}
.pb-3[data-v-7366b548] {
  padding-bottom: 3px;
}
.pb-4[data-v-7366b548] {
  padding-bottom: 4px;
}
.pb-5[data-v-7366b548] {
  padding-bottom: 5px;
}
.pb-6[data-v-7366b548] {
  padding-bottom: 6px;
}
.pb-7[data-v-7366b548] {
  padding-bottom: 7px;
}
.pb-8[data-v-7366b548] {
  padding-bottom: 8px;
}
.pb-9[data-v-7366b548] {
  padding-bottom: 9px;
}
.pb-10[data-v-7366b548] {
  padding-bottom: 10px;
}
.pb-12[data-v-7366b548] {
  padding-bottom: 12px;
}
.pb-14[data-v-7366b548] {
  padding-bottom: 14px;
}
.pb-16[data-v-7366b548] {
  padding-bottom: 16px;
}
.pb-18[data-v-7366b548] {
  padding-bottom: 18px;
}
.pb-20[data-v-7366b548] {
  padding-bottom: 20px;
}
.pb-22[data-v-7366b548] {
  padding-bottom: 22px;
}
.pb-24[data-v-7366b548] {
  padding-bottom: 24px;
}
.pb-26[data-v-7366b548] {
  padding-bottom: 26px;
}
.pb-28[data-v-7366b548] {
  padding-bottom: 28px;
}
.pb-30[data-v-7366b548] {
  padding-bottom: 30px;
}
.pb-32[data-v-7366b548] {
  padding-bottom: 32px;
}
.pb-34[data-v-7366b548] {
  padding-bottom: 34px;
}
.pb-36[data-v-7366b548] {
  padding-bottom: 36px;
}
.pl-0[data-v-7366b548] {
  padding-left: 0px;
}
.pl-1[data-v-7366b548] {
  padding-left: 1px;
}
.pl-2[data-v-7366b548] {
  padding-left: 2px;
}
.pl-3[data-v-7366b548] {
  padding-left: 3px;
}
.pl-4[data-v-7366b548] {
  padding-left: 4px;
}
.pl-5[data-v-7366b548] {
  padding-left: 5px;
}
.pl-6[data-v-7366b548] {
  padding-left: 6px;
}
.pl-7[data-v-7366b548] {
  padding-left: 7px;
}
.pl-8[data-v-7366b548] {
  padding-left: 8px;
}
.pl-9[data-v-7366b548] {
  padding-left: 9px;
}
.pl-10[data-v-7366b548] {
  padding-left: 10px;
}
.pl-12[data-v-7366b548] {
  padding-left: 12px;
}
.pl-14[data-v-7366b548] {
  padding-left: 14px;
}
.pl-16[data-v-7366b548] {
  padding-left: 16px;
}
.pl-18[data-v-7366b548] {
  padding-left: 18px;
}
.pl-20[data-v-7366b548] {
  padding-left: 20px;
}
.pl-22[data-v-7366b548] {
  padding-left: 22px;
}
.pl-24[data-v-7366b548] {
  padding-left: 24px;
}
.pl-26[data-v-7366b548] {
  padding-left: 26px;
}
.pl-28[data-v-7366b548] {
  padding-left: 28px;
}
.pl-30[data-v-7366b548] {
  padding-left: 30px;
}
.pl-32[data-v-7366b548] {
  padding-left: 32px;
}
.pl-34[data-v-7366b548] {
  padding-left: 34px;
}
.pl-36[data-v-7366b548] {
  padding-left: 36px;
}
.pr-0[data-v-7366b548] {
  padding-right: 0px;
}
.pr-1[data-v-7366b548] {
  padding-right: 1px;
}
.pr-2[data-v-7366b548] {
  padding-right: 2px;
}
.pr-3[data-v-7366b548] {
  padding-right: 3px;
}
.pr-4[data-v-7366b548] {
  padding-right: 4px;
}
.pr-5[data-v-7366b548] {
  padding-right: 5px;
}
.pr-6[data-v-7366b548] {
  padding-right: 6px;
}
.pr-7[data-v-7366b548] {
  padding-right: 7px;
}
.pr-8[data-v-7366b548] {
  padding-right: 8px;
}
.pr-9[data-v-7366b548] {
  padding-right: 9px;
}
.pr-10[data-v-7366b548] {
  padding-right: 10px;
}
.pr-12[data-v-7366b548] {
  padding-right: 12px;
}
.pr-14[data-v-7366b548] {
  padding-right: 14px;
}
.pr-16[data-v-7366b548] {
  padding-right: 16px;
}
.pr-18[data-v-7366b548] {
  padding-right: 18px;
}
.pr-20[data-v-7366b548] {
  padding-right: 20px;
}
.pr-22[data-v-7366b548] {
  padding-right: 22px;
}
.pr-24[data-v-7366b548] {
  padding-right: 24px;
}
.pr-26[data-v-7366b548] {
  padding-right: 26px;
}
.pr-28[data-v-7366b548] {
  padding-right: 28px;
}
.pr-30[data-v-7366b548] {
  padding-right: 30px;
}
.pr-32[data-v-7366b548] {
  padding-right: 32px;
}
.pr-34[data-v-7366b548] {
  padding-right: 34px;
}
.pr-36[data-v-7366b548] {
  padding-right: 36px;
}
html[data-v-7366b548] {
  --primary-color: #00703d;
  --primary-disabled-color: #99c6b1;
  --primary-bg-color: #edf8ef;
  --white: white;
  --primary-color-20: #00703d33;
  --brand-4: #00703d22;
  --text-1: #1d2920;
  --text-2: #616961;
  --text-3: #979c98;
  --text-4: #b8bbb8;
  --text-blue: #3c68bf;
  --text-red: #d16559;
  --neutral-fill-1: #f8f9f8;
  --neutral-fill-2: #f1f3f1;
  --neutral-fill-3: #e0e3e0;
  --neutral-border: #f2f2f2;
  --neutral-icon: #696d69;
  --blue-bg-color: #f2f7f9;
  --red-bg-color: #fdf2f0;
  --error-1: #e4000c;
  --error-2: #fff3f4;
  --warn-1: #e88e00;
  --warn-2: #fff6e7;
  --antd-wave-shadow-color: var(--primary-color) !important;
}
span[data-v-7366b548] {
  color: var(--text-1);
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
}
.text-1[data-v-7366b548] {
  color: var(--text-1);
}
.text-2[data-v-7366b548] {
  color: var(--text-2);
}
.text-3[data-v-7366b548] {
  color: var(--text-3);
}
.text-4[data-v-7366b548] {
  color: var(--text-4);
}
.white[data-v-7366b548] {
  color: var(--white);
}
.primary-color[data-v-7366b548] {
  color: var(--primary-color);
}
.error-color[data-v-7366b548] {
  color: var(--error-1);
}
.neutral-icon[data-v-7366b548] {
  color: var(--neutral-icon);
}
.dialog-style[data-v-7366b548] {
  position: absolute;
  border: 1px solid #F2F2F2;
  margin: 20px;
  right: 0px;
  bottom: 0px;
  background-color: #f8f9f8;
  border-radius: 2px;
  width: var(--width);
  height: var(--height);
}
.dialog-header[data-v-7366b548] {
  display: flex;
  padding: 16px 20px;
  align-items: center;
  justify-content: space-between;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
  background-color: var(--bg-color);
  cursor: pointer;
  margin-bottom: 8px;
}
.logo-image[data-v-7366b548] {
  height: 30px;
  display: block;
  margin: 0;
}
.w-100[data-v-83e11129] {
  font-weight: 100;
}
.w-200[data-v-83e11129] {
  font-weight: 200;
}
.w-300[data-v-83e11129] {
  font-weight: 300;
}
.w-400[data-v-83e11129] {
  font-weight: 400;
}
.w-500[data-v-83e11129] {
  font-weight: 500;
}
.w-600[data-v-83e11129] {
  font-weight: 600;
}
.w-700[data-v-83e11129] {
  font-weight: 700;
}
.w-800[data-v-83e11129] {
  font-weight: 800;
}
.w-900[data-v-83e11129] {
  font-weight: 900;
}
html[data-v-83e11129] {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.s-8[data-v-83e11129] {
  font-size: 8px;
}
.s-10[data-v-83e11129] {
  font-size: 10px;
}
.s-12[data-v-83e11129] {
  font-size: 12px;
}
.s-13[data-v-83e11129] {
  font-size: 13px;
}
.s-14[data-v-83e11129] {
  font-size: 14px;
}
.s-16[data-v-83e11129] {
  font-size: 16px;
}
.s-18[data-v-83e11129] {
  font-size: 18px;
}
.s-20[data-v-83e11129] {
  font-size: 20px;
}
.s-22[data-v-83e11129] {
  font-size: 22px;
}
.s-24[data-v-83e11129] {
  font-size: 24px;
}
.s-32[data-v-83e11129] {
  font-size: 32px;
}
.s-36[data-v-83e11129] {
  font-size: 36px;
}
.s-40[data-v-83e11129] {
  font-size: 40px;
}
.l-8[data-v-83e11129] {
  line-height: 8px;
}
.l-10[data-v-83e11129] {
  line-height: 10px;
}
.l-12[data-v-83e11129] {
  line-height: 12px;
}
.l-13[data-v-83e11129] {
  line-height: 13px;
}
.l-14[data-v-83e11129] {
  line-height: 14px;
}
.l-16[data-v-83e11129] {
  line-height: 16px;
}
.l-18[data-v-83e11129] {
  line-height: 18px;
}
.l-20[data-v-83e11129] {
  line-height: 20px;
}
.l-22[data-v-83e11129] {
  line-height: 22px;
}
.l-24[data-v-83e11129] {
  line-height: 24px;
}
.l-32[data-v-83e11129] {
  line-height: 32px;
}
.l-36[data-v-83e11129] {
  line-height: 36px;
}
.l-40[data-v-83e11129] {
  line-height: 40px;
}
.mt-0[data-v-83e11129] {
  margin-top: 0px;
}
.mt-1[data-v-83e11129] {
  margin-top: 1px;
}
.mt-2[data-v-83e11129] {
  margin-top: 2px;
}
.mt-3[data-v-83e11129] {
  margin-top: 3px;
}
.mt-4[data-v-83e11129] {
  margin-top: 4px;
}
.mt-5[data-v-83e11129] {
  margin-top: 5px;
}
.mt-6[data-v-83e11129] {
  margin-top: 6px;
}
.mt-7[data-v-83e11129] {
  margin-top: 7px;
}
.mt-8[data-v-83e11129] {
  margin-top: 8px;
}
.mt-9[data-v-83e11129] {
  margin-top: 9px;
}
.mt-10[data-v-83e11129] {
  margin-top: 10px;
}
.mt-12[data-v-83e11129] {
  margin-top: 12px;
}
.mt-14[data-v-83e11129] {
  margin-top: 14px;
}
.mt-16[data-v-83e11129] {
  margin-top: 16px;
}
.mt-18[data-v-83e11129] {
  margin-top: 18px;
}
.mt-20[data-v-83e11129] {
  margin-top: 20px;
}
.mt-22[data-v-83e11129] {
  margin-top: 22px;
}
.mt-24[data-v-83e11129] {
  margin-top: 24px;
}
.mt-26[data-v-83e11129] {
  margin-top: 26px;
}
.mt-28[data-v-83e11129] {
  margin-top: 28px;
}
.mt-30[data-v-83e11129] {
  margin-top: 30px;
}
.mt-32[data-v-83e11129] {
  margin-top: 32px;
}
.mt-34[data-v-83e11129] {
  margin-top: 34px;
}
.mt-36[data-v-83e11129] {
  margin-top: 36px;
}
.mb-0[data-v-83e11129] {
  margin-bottom: 0px;
}
.mb-1[data-v-83e11129] {
  margin-bottom: 1px;
}
.mb-2[data-v-83e11129] {
  margin-bottom: 2px;
}
.mb-3[data-v-83e11129] {
  margin-bottom: 3px;
}
.mb-4[data-v-83e11129] {
  margin-bottom: 4px;
}
.mb-5[data-v-83e11129] {
  margin-bottom: 5px;
}
.mb-6[data-v-83e11129] {
  margin-bottom: 6px;
}
.mb-7[data-v-83e11129] {
  margin-bottom: 7px;
}
.mb-8[data-v-83e11129] {
  margin-bottom: 8px;
}
.mb-9[data-v-83e11129] {
  margin-bottom: 9px;
}
.mb-10[data-v-83e11129] {
  margin-bottom: 10px;
}
.mb-12[data-v-83e11129] {
  margin-bottom: 12px;
}
.mb-14[data-v-83e11129] {
  margin-bottom: 14px;
}
.mb-16[data-v-83e11129] {
  margin-bottom: 16px;
}
.mb-18[data-v-83e11129] {
  margin-bottom: 18px;
}
.mb-20[data-v-83e11129] {
  margin-bottom: 20px;
}
.mb-22[data-v-83e11129] {
  margin-bottom: 22px;
}
.mb-24[data-v-83e11129] {
  margin-bottom: 24px;
}
.mb-26[data-v-83e11129] {
  margin-bottom: 26px;
}
.mb-28[data-v-83e11129] {
  margin-bottom: 28px;
}
.mb-30[data-v-83e11129] {
  margin-bottom: 30px;
}
.mb-32[data-v-83e11129] {
  margin-bottom: 32px;
}
.mb-34[data-v-83e11129] {
  margin-bottom: 34px;
}
.mb-36[data-v-83e11129] {
  margin-bottom: 36px;
}
.ml-0[data-v-83e11129] {
  margin-left: 0px;
}
.ml-1[data-v-83e11129] {
  margin-left: 1px;
}
.ml-2[data-v-83e11129] {
  margin-left: 2px;
}
.ml-3[data-v-83e11129] {
  margin-left: 3px;
}
.ml-4[data-v-83e11129] {
  margin-left: 4px;
}
.ml-5[data-v-83e11129] {
  margin-left: 5px;
}
.ml-6[data-v-83e11129] {
  margin-left: 6px;
}
.ml-7[data-v-83e11129] {
  margin-left: 7px;
}
.ml-8[data-v-83e11129] {
  margin-left: 8px;
}
.ml-9[data-v-83e11129] {
  margin-left: 9px;
}
.ml-10[data-v-83e11129] {
  margin-left: 10px;
}
.ml-12[data-v-83e11129] {
  margin-left: 12px;
}
.ml-14[data-v-83e11129] {
  margin-left: 14px;
}
.ml-16[data-v-83e11129] {
  margin-left: 16px;
}
.ml-18[data-v-83e11129] {
  margin-left: 18px;
}
.ml-20[data-v-83e11129] {
  margin-left: 20px;
}
.ml-22[data-v-83e11129] {
  margin-left: 22px;
}
.ml-24[data-v-83e11129] {
  margin-left: 24px;
}
.ml-26[data-v-83e11129] {
  margin-left: 26px;
}
.ml-28[data-v-83e11129] {
  margin-left: 28px;
}
.ml-30[data-v-83e11129] {
  margin-left: 30px;
}
.ml-32[data-v-83e11129] {
  margin-left: 32px;
}
.ml-34[data-v-83e11129] {
  margin-left: 34px;
}
.ml-36[data-v-83e11129] {
  margin-left: 36px;
}
.mr-0[data-v-83e11129] {
  margin-right: 0px;
}
.mr-1[data-v-83e11129] {
  margin-right: 1px;
}
.mr-2[data-v-83e11129] {
  margin-right: 2px;
}
.mr-3[data-v-83e11129] {
  margin-right: 3px;
}
.mr-4[data-v-83e11129] {
  margin-right: 4px;
}
.mr-5[data-v-83e11129] {
  margin-right: 5px;
}
.mr-6[data-v-83e11129] {
  margin-right: 6px;
}
.mr-7[data-v-83e11129] {
  margin-right: 7px;
}
.mr-8[data-v-83e11129] {
  margin-right: 8px;
}
.mr-9[data-v-83e11129] {
  margin-right: 9px;
}
.mr-10[data-v-83e11129] {
  margin-right: 10px;
}
.mr-12[data-v-83e11129] {
  margin-right: 12px;
}
.mr-14[data-v-83e11129] {
  margin-right: 14px;
}
.mr-16[data-v-83e11129] {
  margin-right: 16px;
}
.mr-18[data-v-83e11129] {
  margin-right: 18px;
}
.mr-20[data-v-83e11129] {
  margin-right: 20px;
}
.mr-22[data-v-83e11129] {
  margin-right: 22px;
}
.mr-24[data-v-83e11129] {
  margin-right: 24px;
}
.mr-26[data-v-83e11129] {
  margin-right: 26px;
}
.mr-28[data-v-83e11129] {
  margin-right: 28px;
}
.mr-30[data-v-83e11129] {
  margin-right: 30px;
}
.mr-32[data-v-83e11129] {
  margin-right: 32px;
}
.mr-34[data-v-83e11129] {
  margin-right: 34px;
}
.mr-36[data-v-83e11129] {
  margin-right: 36px;
}
.pt-0[data-v-83e11129] {
  padding-top: 0px;
}
.pt-1[data-v-83e11129] {
  padding-top: 1px;
}
.pt-2[data-v-83e11129] {
  padding-top: 2px;
}
.pt-3[data-v-83e11129] {
  padding-top: 3px;
}
.pt-4[data-v-83e11129] {
  padding-top: 4px;
}
.pt-5[data-v-83e11129] {
  padding-top: 5px;
}
.pt-6[data-v-83e11129] {
  padding-top: 6px;
}
.pt-7[data-v-83e11129] {
  padding-top: 7px;
}
.pt-8[data-v-83e11129] {
  padding-top: 8px;
}
.pt-9[data-v-83e11129] {
  padding-top: 9px;
}
.pt-10[data-v-83e11129] {
  padding-top: 10px;
}
.pt-12[data-v-83e11129] {
  padding-top: 12px;
}
.pt-14[data-v-83e11129] {
  padding-top: 14px;
}
.pt-16[data-v-83e11129] {
  padding-top: 16px;
}
.pt-18[data-v-83e11129] {
  padding-top: 18px;
}
.pt-20[data-v-83e11129] {
  padding-top: 20px;
}
.pt-22[data-v-83e11129] {
  padding-top: 22px;
}
.pt-24[data-v-83e11129] {
  padding-top: 24px;
}
.pt-26[data-v-83e11129] {
  padding-top: 26px;
}
.pt-28[data-v-83e11129] {
  padding-top: 28px;
}
.pt-30[data-v-83e11129] {
  padding-top: 30px;
}
.pt-32[data-v-83e11129] {
  padding-top: 32px;
}
.pt-34[data-v-83e11129] {
  padding-top: 34px;
}
.pt-36[data-v-83e11129] {
  padding-top: 36px;
}
.pb-0[data-v-83e11129] {
  padding-bottom: 0px;
}
.pb-1[data-v-83e11129] {
  padding-bottom: 1px;
}
.pb-2[data-v-83e11129] {
  padding-bottom: 2px;
}
.pb-3[data-v-83e11129] {
  padding-bottom: 3px;
}
.pb-4[data-v-83e11129] {
  padding-bottom: 4px;
}
.pb-5[data-v-83e11129] {
  padding-bottom: 5px;
}
.pb-6[data-v-83e11129] {
  padding-bottom: 6px;
}
.pb-7[data-v-83e11129] {
  padding-bottom: 7px;
}
.pb-8[data-v-83e11129] {
  padding-bottom: 8px;
}
.pb-9[data-v-83e11129] {
  padding-bottom: 9px;
}
.pb-10[data-v-83e11129] {
  padding-bottom: 10px;
}
.pb-12[data-v-83e11129] {
  padding-bottom: 12px;
}
.pb-14[data-v-83e11129] {
  padding-bottom: 14px;
}
.pb-16[data-v-83e11129] {
  padding-bottom: 16px;
}
.pb-18[data-v-83e11129] {
  padding-bottom: 18px;
}
.pb-20[data-v-83e11129] {
  padding-bottom: 20px;
}
.pb-22[data-v-83e11129] {
  padding-bottom: 22px;
}
.pb-24[data-v-83e11129] {
  padding-bottom: 24px;
}
.pb-26[data-v-83e11129] {
  padding-bottom: 26px;
}
.pb-28[data-v-83e11129] {
  padding-bottom: 28px;
}
.pb-30[data-v-83e11129] {
  padding-bottom: 30px;
}
.pb-32[data-v-83e11129] {
  padding-bottom: 32px;
}
.pb-34[data-v-83e11129] {
  padding-bottom: 34px;
}
.pb-36[data-v-83e11129] {
  padding-bottom: 36px;
}
.pl-0[data-v-83e11129] {
  padding-left: 0px;
}
.pl-1[data-v-83e11129] {
  padding-left: 1px;
}
.pl-2[data-v-83e11129] {
  padding-left: 2px;
}
.pl-3[data-v-83e11129] {
  padding-left: 3px;
}
.pl-4[data-v-83e11129] {
  padding-left: 4px;
}
.pl-5[data-v-83e11129] {
  padding-left: 5px;
}
.pl-6[data-v-83e11129] {
  padding-left: 6px;
}
.pl-7[data-v-83e11129] {
  padding-left: 7px;
}
.pl-8[data-v-83e11129] {
  padding-left: 8px;
}
.pl-9[data-v-83e11129] {
  padding-left: 9px;
}
.pl-10[data-v-83e11129] {
  padding-left: 10px;
}
.pl-12[data-v-83e11129] {
  padding-left: 12px;
}
.pl-14[data-v-83e11129] {
  padding-left: 14px;
}
.pl-16[data-v-83e11129] {
  padding-left: 16px;
}
.pl-18[data-v-83e11129] {
  padding-left: 18px;
}
.pl-20[data-v-83e11129] {
  padding-left: 20px;
}
.pl-22[data-v-83e11129] {
  padding-left: 22px;
}
.pl-24[data-v-83e11129] {
  padding-left: 24px;
}
.pl-26[data-v-83e11129] {
  padding-left: 26px;
}
.pl-28[data-v-83e11129] {
  padding-left: 28px;
}
.pl-30[data-v-83e11129] {
  padding-left: 30px;
}
.pl-32[data-v-83e11129] {
  padding-left: 32px;
}
.pl-34[data-v-83e11129] {
  padding-left: 34px;
}
.pl-36[data-v-83e11129] {
  padding-left: 36px;
}
.pr-0[data-v-83e11129] {
  padding-right: 0px;
}
.pr-1[data-v-83e11129] {
  padding-right: 1px;
}
.pr-2[data-v-83e11129] {
  padding-right: 2px;
}
.pr-3[data-v-83e11129] {
  padding-right: 3px;
}
.pr-4[data-v-83e11129] {
  padding-right: 4px;
}
.pr-5[data-v-83e11129] {
  padding-right: 5px;
}
.pr-6[data-v-83e11129] {
  padding-right: 6px;
}
.pr-7[data-v-83e11129] {
  padding-right: 7px;
}
.pr-8[data-v-83e11129] {
  padding-right: 8px;
}
.pr-9[data-v-83e11129] {
  padding-right: 9px;
}
.pr-10[data-v-83e11129] {
  padding-right: 10px;
}
.pr-12[data-v-83e11129] {
  padding-right: 12px;
}
.pr-14[data-v-83e11129] {
  padding-right: 14px;
}
.pr-16[data-v-83e11129] {
  padding-right: 16px;
}
.pr-18[data-v-83e11129] {
  padding-right: 18px;
}
.pr-20[data-v-83e11129] {
  padding-right: 20px;
}
.pr-22[data-v-83e11129] {
  padding-right: 22px;
}
.pr-24[data-v-83e11129] {
  padding-right: 24px;
}
.pr-26[data-v-83e11129] {
  padding-right: 26px;
}
.pr-28[data-v-83e11129] {
  padding-right: 28px;
}
.pr-30[data-v-83e11129] {
  padding-right: 30px;
}
.pr-32[data-v-83e11129] {
  padding-right: 32px;
}
.pr-34[data-v-83e11129] {
  padding-right: 34px;
}
.pr-36[data-v-83e11129] {
  padding-right: 36px;
}
html[data-v-83e11129] {
  --primary-color: #00703d;
  --primary-disabled-color: #99c6b1;
  --primary-bg-color: #edf8ef;
  --white: white;
  --primary-color-20: #00703d33;
  --brand-4: #00703d22;
  --text-1: #1d2920;
  --text-2: #616961;
  --text-3: #979c98;
  --text-4: #b8bbb8;
  --text-blue: #3c68bf;
  --text-red: #d16559;
  --neutral-fill-1: #f8f9f8;
  --neutral-fill-2: #f1f3f1;
  --neutral-fill-3: #e0e3e0;
  --neutral-border: #f2f2f2;
  --neutral-icon: #696d69;
  --blue-bg-color: #f2f7f9;
  --red-bg-color: #fdf2f0;
  --error-1: #e4000c;
  --error-2: #fff3f4;
  --warn-1: #e88e00;
  --warn-2: #fff6e7;
  --antd-wave-shadow-color: var(--primary-color) !important;
}
span[data-v-83e11129] {
  color: var(--text-1);
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
}
.text-1[data-v-83e11129] {
  color: var(--text-1);
}
.text-2[data-v-83e11129] {
  color: var(--text-2);
}
.text-3[data-v-83e11129] {
  color: var(--text-3);
}
.text-4[data-v-83e11129] {
  color: var(--text-4);
}
.white[data-v-83e11129] {
  color: var(--white);
}
.primary-color[data-v-83e11129] {
  color: var(--primary-color);
}
.error-color[data-v-83e11129] {
  color: var(--error-1);
}
.neutral-icon[data-v-83e11129] {
  color: var(--neutral-icon);
}
.style-wrapper[data-v-83e11129] {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 999;
  pointer-events: none;
}
.style-wrapper[data-v-83e11129] > * {
  pointer-events: auto;
}
.entrance-style[data-v-83e11129] {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: absolute;
  margin: 20px;
  gap: 8px;
  top: var(--top);
  left: var(--left);
  background-color: var(--bg-color);
  border-radius: 4px;
  transition: all 0.3s ease;
  width: var(--width);
  height: var(--height);
  cursor: pointer;
}
.entrance-style[data-v-83e11129]:hover {
  scale: 1.1;
}
.entrance-style.entrance-type-circle[data-v-83e11129] {
  border-radius: 50%;
}
.entrance-style.entrance-type-none[data-v-83e11129] {
  display: none;
}
.entrance-label[data-v-83e11129] {
  color: white;
  user-select: none;
  font-weight: 500;
  text-align: center;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}
.entrance-label.entrance-label-rect[data-v-83e11129] {
  writing-mode: vertical-lr;
  letter-spacing: var(--lang-spacing);
  font-size: 14px;
  line-height: 20px;
  height: calc(var(--height) - 48px);
}
.entrance-label.entrance-label-square[data-v-83e11129] {
  line-height: 14px;
  width: calc(var(--width) - 20px);
}
.entrance-label.entrance-label-circle[data-v-83e11129] {
  line-height: 14px;
  width: calc(var(--width) - 20px);
}
html {
  --primary-color: #00703d;
  --primary-disabled-color: #99c6b1;
  --primary-bg-color: #edf8ef;
  --white: white;
  --primary-color-20: #00703d33;
  --brand-4: #00703d22;
  --text-1: #1d2920;
  --text-2: #616961;
  --text-3: #979c98;
  --text-4: #b8bbb8;
  --text-blue: #3c68bf;
  --text-red: #d16559;
  --neutral-fill-1: #f8f9f8;
  --neutral-fill-2: #f1f3f1;
  --neutral-fill-3: #e0e3e0;
  --neutral-border: #f2f2f2;
  --neutral-icon: #696d69;
  --blue-bg-color: #f2f7f9;
  --red-bg-color: #fdf2f0;
  --error-1: #e4000c;
  --error-2: #fff3f4;
  --warn-1: #e88e00;
  --warn-2: #fff6e7;
  --antd-wave-shadow-color: var(--primary-color) !important;
}
span {
  color: var(--text-1);
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
}
.text-1 {
  color: var(--text-1);
}
.text-2 {
  color: var(--text-2);
}
.text-3 {
  color: var(--text-3);
}
.text-4 {
  color: var(--text-4);
}
.white {
  color: var(--white);
}
.primary-color {
  color: var(--primary-color);
}
.error-color {
  color: var(--error-1);
}
.neutral-icon {
  color: var(--neutral-icon);
}
.w-100 {
  font-weight: 100;
}
.w-200 {
  font-weight: 200;
}
.w-300 {
  font-weight: 300;
}
.w-400 {
  font-weight: 400;
}
.w-500 {
  font-weight: 500;
}
.w-600 {
  font-weight: 600;
}
.w-700 {
  font-weight: 700;
}
.w-800 {
  font-weight: 800;
}
.w-900 {
  font-weight: 900;
}
html {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.s-8 {
  font-size: 8px;
}
.s-10 {
  font-size: 10px;
}
.s-12 {
  font-size: 12px;
}
.s-13 {
  font-size: 13px;
}
.s-14 {
  font-size: 14px;
}
.s-16 {
  font-size: 16px;
}
.s-18 {
  font-size: 18px;
}
.s-20 {
  font-size: 20px;
}
.s-22 {
  font-size: 22px;
}
.s-24 {
  font-size: 24px;
}
.s-32 {
  font-size: 32px;
}
.s-36 {
  font-size: 36px;
}
.s-40 {
  font-size: 40px;
}
.l-8 {
  line-height: 8px;
}
.l-10 {
  line-height: 10px;
}
.l-12 {
  line-height: 12px;
}
.l-13 {
  line-height: 13px;
}
.l-14 {
  line-height: 14px;
}
.l-16 {
  line-height: 16px;
}
.l-18 {
  line-height: 18px;
}
.l-20 {
  line-height: 20px;
}
.l-22 {
  line-height: 22px;
}
.l-24 {
  line-height: 24px;
}
.l-32 {
  line-height: 32px;
}
.l-36 {
  line-height: 36px;
}
.l-40 {
  line-height: 40px;
}
.mt-0 {
  margin-top: 0px;
}
.mt-1 {
  margin-top: 1px;
}
.mt-2 {
  margin-top: 2px;
}
.mt-3 {
  margin-top: 3px;
}
.mt-4 {
  margin-top: 4px;
}
.mt-5 {
  margin-top: 5px;
}
.mt-6 {
  margin-top: 6px;
}
.mt-7 {
  margin-top: 7px;
}
.mt-8 {
  margin-top: 8px;
}
.mt-9 {
  margin-top: 9px;
}
.mt-10 {
  margin-top: 10px;
}
.mt-12 {
  margin-top: 12px;
}
.mt-14 {
  margin-top: 14px;
}
.mt-16 {
  margin-top: 16px;
}
.mt-18 {
  margin-top: 18px;
}
.mt-20 {
  margin-top: 20px;
}
.mt-22 {
  margin-top: 22px;
}
.mt-24 {
  margin-top: 24px;
}
.mt-26 {
  margin-top: 26px;
}
.mt-28 {
  margin-top: 28px;
}
.mt-30 {
  margin-top: 30px;
}
.mt-32 {
  margin-top: 32px;
}
.mt-34 {
  margin-top: 34px;
}
.mt-36 {
  margin-top: 36px;
}
.mb-0 {
  margin-bottom: 0px;
}
.mb-1 {
  margin-bottom: 1px;
}
.mb-2 {
  margin-bottom: 2px;
}
.mb-3 {
  margin-bottom: 3px;
}
.mb-4 {
  margin-bottom: 4px;
}
.mb-5 {
  margin-bottom: 5px;
}
.mb-6 {
  margin-bottom: 6px;
}
.mb-7 {
  margin-bottom: 7px;
}
.mb-8 {
  margin-bottom: 8px;
}
.mb-9 {
  margin-bottom: 9px;
}
.mb-10 {
  margin-bottom: 10px;
}
.mb-12 {
  margin-bottom: 12px;
}
.mb-14 {
  margin-bottom: 14px;
}
.mb-16 {
  margin-bottom: 16px;
}
.mb-18 {
  margin-bottom: 18px;
}
.mb-20 {
  margin-bottom: 20px;
}
.mb-22 {
  margin-bottom: 22px;
}
.mb-24 {
  margin-bottom: 24px;
}
.mb-26 {
  margin-bottom: 26px;
}
.mb-28 {
  margin-bottom: 28px;
}
.mb-30 {
  margin-bottom: 30px;
}
.mb-32 {
  margin-bottom: 32px;
}
.mb-34 {
  margin-bottom: 34px;
}
.mb-36 {
  margin-bottom: 36px;
}
.ml-0 {
  margin-left: 0px;
}
.ml-1 {
  margin-left: 1px;
}
.ml-2 {
  margin-left: 2px;
}
.ml-3 {
  margin-left: 3px;
}
.ml-4 {
  margin-left: 4px;
}
.ml-5 {
  margin-left: 5px;
}
.ml-6 {
  margin-left: 6px;
}
.ml-7 {
  margin-left: 7px;
}
.ml-8 {
  margin-left: 8px;
}
.ml-9 {
  margin-left: 9px;
}
.ml-10 {
  margin-left: 10px;
}
.ml-12 {
  margin-left: 12px;
}
.ml-14 {
  margin-left: 14px;
}
.ml-16 {
  margin-left: 16px;
}
.ml-18 {
  margin-left: 18px;
}
.ml-20 {
  margin-left: 20px;
}
.ml-22 {
  margin-left: 22px;
}
.ml-24 {
  margin-left: 24px;
}
.ml-26 {
  margin-left: 26px;
}
.ml-28 {
  margin-left: 28px;
}
.ml-30 {
  margin-left: 30px;
}
.ml-32 {
  margin-left: 32px;
}
.ml-34 {
  margin-left: 34px;
}
.ml-36 {
  margin-left: 36px;
}
.mr-0 {
  margin-right: 0px;
}
.mr-1 {
  margin-right: 1px;
}
.mr-2 {
  margin-right: 2px;
}
.mr-3 {
  margin-right: 3px;
}
.mr-4 {
  margin-right: 4px;
}
.mr-5 {
  margin-right: 5px;
}
.mr-6 {
  margin-right: 6px;
}
.mr-7 {
  margin-right: 7px;
}
.mr-8 {
  margin-right: 8px;
}
.mr-9 {
  margin-right: 9px;
}
.mr-10 {
  margin-right: 10px;
}
.mr-12 {
  margin-right: 12px;
}
.mr-14 {
  margin-right: 14px;
}
.mr-16 {
  margin-right: 16px;
}
.mr-18 {
  margin-right: 18px;
}
.mr-20 {
  margin-right: 20px;
}
.mr-22 {
  margin-right: 22px;
}
.mr-24 {
  margin-right: 24px;
}
.mr-26 {
  margin-right: 26px;
}
.mr-28 {
  margin-right: 28px;
}
.mr-30 {
  margin-right: 30px;
}
.mr-32 {
  margin-right: 32px;
}
.mr-34 {
  margin-right: 34px;
}
.mr-36 {
  margin-right: 36px;
}
.pt-0 {
  padding-top: 0px;
}
.pt-1 {
  padding-top: 1px;
}
.pt-2 {
  padding-top: 2px;
}
.pt-3 {
  padding-top: 3px;
}
.pt-4 {
  padding-top: 4px;
}
.pt-5 {
  padding-top: 5px;
}
.pt-6 {
  padding-top: 6px;
}
.pt-7 {
  padding-top: 7px;
}
.pt-8 {
  padding-top: 8px;
}
.pt-9 {
  padding-top: 9px;
}
.pt-10 {
  padding-top: 10px;
}
.pt-12 {
  padding-top: 12px;
}
.pt-14 {
  padding-top: 14px;
}
.pt-16 {
  padding-top: 16px;
}
.pt-18 {
  padding-top: 18px;
}
.pt-20 {
  padding-top: 20px;
}
.pt-22 {
  padding-top: 22px;
}
.pt-24 {
  padding-top: 24px;
}
.pt-26 {
  padding-top: 26px;
}
.pt-28 {
  padding-top: 28px;
}
.pt-30 {
  padding-top: 30px;
}
.pt-32 {
  padding-top: 32px;
}
.pt-34 {
  padding-top: 34px;
}
.pt-36 {
  padding-top: 36px;
}
.pb-0 {
  padding-bottom: 0px;
}
.pb-1 {
  padding-bottom: 1px;
}
.pb-2 {
  padding-bottom: 2px;
}
.pb-3 {
  padding-bottom: 3px;
}
.pb-4 {
  padding-bottom: 4px;
}
.pb-5 {
  padding-bottom: 5px;
}
.pb-6 {
  padding-bottom: 6px;
}
.pb-7 {
  padding-bottom: 7px;
}
.pb-8 {
  padding-bottom: 8px;
}
.pb-9 {
  padding-bottom: 9px;
}
.pb-10 {
  padding-bottom: 10px;
}
.pb-12 {
  padding-bottom: 12px;
}
.pb-14 {
  padding-bottom: 14px;
}
.pb-16 {
  padding-bottom: 16px;
}
.pb-18 {
  padding-bottom: 18px;
}
.pb-20 {
  padding-bottom: 20px;
}
.pb-22 {
  padding-bottom: 22px;
}
.pb-24 {
  padding-bottom: 24px;
}
.pb-26 {
  padding-bottom: 26px;
}
.pb-28 {
  padding-bottom: 28px;
}
.pb-30 {
  padding-bottom: 30px;
}
.pb-32 {
  padding-bottom: 32px;
}
.pb-34 {
  padding-bottom: 34px;
}
.pb-36 {
  padding-bottom: 36px;
}
.pl-0 {
  padding-left: 0px;
}
.pl-1 {
  padding-left: 1px;
}
.pl-2 {
  padding-left: 2px;
}
.pl-3 {
  padding-left: 3px;
}
.pl-4 {
  padding-left: 4px;
}
.pl-5 {
  padding-left: 5px;
}
.pl-6 {
  padding-left: 6px;
}
.pl-7 {
  padding-left: 7px;
}
.pl-8 {
  padding-left: 8px;
}
.pl-9 {
  padding-left: 9px;
}
.pl-10 {
  padding-left: 10px;
}
.pl-12 {
  padding-left: 12px;
}
.pl-14 {
  padding-left: 14px;
}
.pl-16 {
  padding-left: 16px;
}
.pl-18 {
  padding-left: 18px;
}
.pl-20 {
  padding-left: 20px;
}
.pl-22 {
  padding-left: 22px;
}
.pl-24 {
  padding-left: 24px;
}
.pl-26 {
  padding-left: 26px;
}
.pl-28 {
  padding-left: 28px;
}
.pl-30 {
  padding-left: 30px;
}
.pl-32 {
  padding-left: 32px;
}
.pl-34 {
  padding-left: 34px;
}
.pl-36 {
  padding-left: 36px;
}
.pr-0 {
  padding-right: 0px;
}
.pr-1 {
  padding-right: 1px;
}
.pr-2 {
  padding-right: 2px;
}
.pr-3 {
  padding-right: 3px;
}
.pr-4 {
  padding-right: 4px;
}
.pr-5 {
  padding-right: 5px;
}
.pr-6 {
  padding-right: 6px;
}
.pr-7 {
  padding-right: 7px;
}
.pr-8 {
  padding-right: 8px;
}
.pr-9 {
  padding-right: 9px;
}
.pr-10 {
  padding-right: 10px;
}
.pr-12 {
  padding-right: 12px;
}
.pr-14 {
  padding-right: 14px;
}
.pr-16 {
  padding-right: 16px;
}
.pr-18 {
  padding-right: 18px;
}
.pr-20 {
  padding-right: 20px;
}
.pr-22 {
  padding-right: 22px;
}
.pr-24 {
  padding-right: 24px;
}
.pr-26 {
  padding-right: 26px;
}
.pr-28 {
  padding-right: 28px;
}
.pr-30 {
  padding-right: 30px;
}
.pr-32 {
  padding-right: 32px;
}
.pr-34 {
  padding-right: 34px;
}
.pr-36 {
  padding-right: 36px;
}
.w-100 {
  font-weight: 100;
}
.w-200 {
  font-weight: 200;
}
.w-300 {
  font-weight: 300;
}
.w-400 {
  font-weight: 400;
}
.w-500 {
  font-weight: 500;
}
.w-600 {
  font-weight: 600;
}
.w-700 {
  font-weight: 700;
}
.w-800 {
  font-weight: 800;
}
.w-900 {
  font-weight: 900;
}
html {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.s-8 {
  font-size: 8px;
}
.s-10 {
  font-size: 10px;
}
.s-12 {
  font-size: 12px;
}
.s-13 {
  font-size: 13px;
}
.s-14 {
  font-size: 14px;
}
.s-16 {
  font-size: 16px;
}
.s-18 {
  font-size: 18px;
}
.s-20 {
  font-size: 20px;
}
.s-22 {
  font-size: 22px;
}
.s-24 {
  font-size: 24px;
}
.s-32 {
  font-size: 32px;
}
.s-36 {
  font-size: 36px;
}
.s-40 {
  font-size: 40px;
}
.l-8 {
  line-height: 8px;
}
.l-10 {
  line-height: 10px;
}
.l-12 {
  line-height: 12px;
}
.l-13 {
  line-height: 13px;
}
.l-14 {
  line-height: 14px;
}
.l-16 {
  line-height: 16px;
}
.l-18 {
  line-height: 18px;
}
.l-20 {
  line-height: 20px;
}
.l-22 {
  line-height: 22px;
}
.l-24 {
  line-height: 24px;
}
.l-32 {
  line-height: 32px;
}
.l-36 {
  line-height: 36px;
}
.l-40 {
  line-height: 40px;
}
.mt-0 {
  margin-top: 0px;
}
.mt-1 {
  margin-top: 1px;
}
.mt-2 {
  margin-top: 2px;
}
.mt-3 {
  margin-top: 3px;
}
.mt-4 {
  margin-top: 4px;
}
.mt-5 {
  margin-top: 5px;
}
.mt-6 {
  margin-top: 6px;
}
.mt-7 {
  margin-top: 7px;
}
.mt-8 {
  margin-top: 8px;
}
.mt-9 {
  margin-top: 9px;
}
.mt-10 {
  margin-top: 10px;
}
.mt-12 {
  margin-top: 12px;
}
.mt-14 {
  margin-top: 14px;
}
.mt-16 {
  margin-top: 16px;
}
.mt-18 {
  margin-top: 18px;
}
.mt-20 {
  margin-top: 20px;
}
.mt-22 {
  margin-top: 22px;
}
.mt-24 {
  margin-top: 24px;
}
.mt-26 {
  margin-top: 26px;
}
.mt-28 {
  margin-top: 28px;
}
.mt-30 {
  margin-top: 30px;
}
.mt-32 {
  margin-top: 32px;
}
.mt-34 {
  margin-top: 34px;
}
.mt-36 {
  margin-top: 36px;
}
.mb-0 {
  margin-bottom: 0px;
}
.mb-1 {
  margin-bottom: 1px;
}
.mb-2 {
  margin-bottom: 2px;
}
.mb-3 {
  margin-bottom: 3px;
}
.mb-4 {
  margin-bottom: 4px;
}
.mb-5 {
  margin-bottom: 5px;
}
.mb-6 {
  margin-bottom: 6px;
}
.mb-7 {
  margin-bottom: 7px;
}
.mb-8 {
  margin-bottom: 8px;
}
.mb-9 {
  margin-bottom: 9px;
}
.mb-10 {
  margin-bottom: 10px;
}
.mb-12 {
  margin-bottom: 12px;
}
.mb-14 {
  margin-bottom: 14px;
}
.mb-16 {
  margin-bottom: 16px;
}
.mb-18 {
  margin-bottom: 18px;
}
.mb-20 {
  margin-bottom: 20px;
}
.mb-22 {
  margin-bottom: 22px;
}
.mb-24 {
  margin-bottom: 24px;
}
.mb-26 {
  margin-bottom: 26px;
}
.mb-28 {
  margin-bottom: 28px;
}
.mb-30 {
  margin-bottom: 30px;
}
.mb-32 {
  margin-bottom: 32px;
}
.mb-34 {
  margin-bottom: 34px;
}
.mb-36 {
  margin-bottom: 36px;
}
.ml-0 {
  margin-left: 0px;
}
.ml-1 {
  margin-left: 1px;
}
.ml-2 {
  margin-left: 2px;
}
.ml-3 {
  margin-left: 3px;
}
.ml-4 {
  margin-left: 4px;
}
.ml-5 {
  margin-left: 5px;
}
.ml-6 {
  margin-left: 6px;
}
.ml-7 {
  margin-left: 7px;
}
.ml-8 {
  margin-left: 8px;
}
.ml-9 {
  margin-left: 9px;
}
.ml-10 {
  margin-left: 10px;
}
.ml-12 {
  margin-left: 12px;
}
.ml-14 {
  margin-left: 14px;
}
.ml-16 {
  margin-left: 16px;
}
.ml-18 {
  margin-left: 18px;
}
.ml-20 {
  margin-left: 20px;
}
.ml-22 {
  margin-left: 22px;
}
.ml-24 {
  margin-left: 24px;
}
.ml-26 {
  margin-left: 26px;
}
.ml-28 {
  margin-left: 28px;
}
.ml-30 {
  margin-left: 30px;
}
.ml-32 {
  margin-left: 32px;
}
.ml-34 {
  margin-left: 34px;
}
.ml-36 {
  margin-left: 36px;
}
.mr-0 {
  margin-right: 0px;
}
.mr-1 {
  margin-right: 1px;
}
.mr-2 {
  margin-right: 2px;
}
.mr-3 {
  margin-right: 3px;
}
.mr-4 {
  margin-right: 4px;
}
.mr-5 {
  margin-right: 5px;
}
.mr-6 {
  margin-right: 6px;
}
.mr-7 {
  margin-right: 7px;
}
.mr-8 {
  margin-right: 8px;
}
.mr-9 {
  margin-right: 9px;
}
.mr-10 {
  margin-right: 10px;
}
.mr-12 {
  margin-right: 12px;
}
.mr-14 {
  margin-right: 14px;
}
.mr-16 {
  margin-right: 16px;
}
.mr-18 {
  margin-right: 18px;
}
.mr-20 {
  margin-right: 20px;
}
.mr-22 {
  margin-right: 22px;
}
.mr-24 {
  margin-right: 24px;
}
.mr-26 {
  margin-right: 26px;
}
.mr-28 {
  margin-right: 28px;
}
.mr-30 {
  margin-right: 30px;
}
.mr-32 {
  margin-right: 32px;
}
.mr-34 {
  margin-right: 34px;
}
.mr-36 {
  margin-right: 36px;
}
.pt-0 {
  padding-top: 0px;
}
.pt-1 {
  padding-top: 1px;
}
.pt-2 {
  padding-top: 2px;
}
.pt-3 {
  padding-top: 3px;
}
.pt-4 {
  padding-top: 4px;
}
.pt-5 {
  padding-top: 5px;
}
.pt-6 {
  padding-top: 6px;
}
.pt-7 {
  padding-top: 7px;
}
.pt-8 {
  padding-top: 8px;
}
.pt-9 {
  padding-top: 9px;
}
.pt-10 {
  padding-top: 10px;
}
.pt-12 {
  padding-top: 12px;
}
.pt-14 {
  padding-top: 14px;
}
.pt-16 {
  padding-top: 16px;
}
.pt-18 {
  padding-top: 18px;
}
.pt-20 {
  padding-top: 20px;
}
.pt-22 {
  padding-top: 22px;
}
.pt-24 {
  padding-top: 24px;
}
.pt-26 {
  padding-top: 26px;
}
.pt-28 {
  padding-top: 28px;
}
.pt-30 {
  padding-top: 30px;
}
.pt-32 {
  padding-top: 32px;
}
.pt-34 {
  padding-top: 34px;
}
.pt-36 {
  padding-top: 36px;
}
.pb-0 {
  padding-bottom: 0px;
}
.pb-1 {
  padding-bottom: 1px;
}
.pb-2 {
  padding-bottom: 2px;
}
.pb-3 {
  padding-bottom: 3px;
}
.pb-4 {
  padding-bottom: 4px;
}
.pb-5 {
  padding-bottom: 5px;
}
.pb-6 {
  padding-bottom: 6px;
}
.pb-7 {
  padding-bottom: 7px;
}
.pb-8 {
  padding-bottom: 8px;
}
.pb-9 {
  padding-bottom: 9px;
}
.pb-10 {
  padding-bottom: 10px;
}
.pb-12 {
  padding-bottom: 12px;
}
.pb-14 {
  padding-bottom: 14px;
}
.pb-16 {
  padding-bottom: 16px;
}
.pb-18 {
  padding-bottom: 18px;
}
.pb-20 {
  padding-bottom: 20px;
}
.pb-22 {
  padding-bottom: 22px;
}
.pb-24 {
  padding-bottom: 24px;
}
.pb-26 {
  padding-bottom: 26px;
}
.pb-28 {
  padding-bottom: 28px;
}
.pb-30 {
  padding-bottom: 30px;
}
.pb-32 {
  padding-bottom: 32px;
}
.pb-34 {
  padding-bottom: 34px;
}
.pb-36 {
  padding-bottom: 36px;
}
.pl-0 {
  padding-left: 0px;
}
.pl-1 {
  padding-left: 1px;
}
.pl-2 {
  padding-left: 2px;
}
.pl-3 {
  padding-left: 3px;
}
.pl-4 {
  padding-left: 4px;
}
.pl-5 {
  padding-left: 5px;
}
.pl-6 {
  padding-left: 6px;
}
.pl-7 {
  padding-left: 7px;
}
.pl-8 {
  padding-left: 8px;
}
.pl-9 {
  padding-left: 9px;
}
.pl-10 {
  padding-left: 10px;
}
.pl-12 {
  padding-left: 12px;
}
.pl-14 {
  padding-left: 14px;
}
.pl-16 {
  padding-left: 16px;
}
.pl-18 {
  padding-left: 18px;
}
.pl-20 {
  padding-left: 20px;
}
.pl-22 {
  padding-left: 22px;
}
.pl-24 {
  padding-left: 24px;
}
.pl-26 {
  padding-left: 26px;
}
.pl-28 {
  padding-left: 28px;
}
.pl-30 {
  padding-left: 30px;
}
.pl-32 {
  padding-left: 32px;
}
.pl-34 {
  padding-left: 34px;
}
.pl-36 {
  padding-left: 36px;
}
.pr-0 {
  padding-right: 0px;
}
.pr-1 {
  padding-right: 1px;
}
.pr-2 {
  padding-right: 2px;
}
.pr-3 {
  padding-right: 3px;
}
.pr-4 {
  padding-right: 4px;
}
.pr-5 {
  padding-right: 5px;
}
.pr-6 {
  padding-right: 6px;
}
.pr-7 {
  padding-right: 7px;
}
.pr-8 {
  padding-right: 8px;
}
.pr-9 {
  padding-right: 9px;
}
.pr-10 {
  padding-right: 10px;
}
.pr-12 {
  padding-right: 12px;
}
.pr-14 {
  padding-right: 14px;
}
.pr-16 {
  padding-right: 16px;
}
.pr-18 {
  padding-right: 18px;
}
.pr-20 {
  padding-right: 20px;
}
.pr-22 {
  padding-right: 22px;
}
.pr-24 {
  padding-right: 24px;
}
.pr-26 {
  padding-right: 26px;
}
.pr-28 {
  padding-right: 28px;
}
.pr-30 {
  padding-right: 30px;
}
.pr-32 {
  padding-right: 32px;
}
.pr-34 {
  padding-right: 34px;
}
.pr-36 {
  padding-right: 36px;
}
html {
  --primary-color: #00703d;
  --primary-disabled-color: #99c6b1;
  --primary-bg-color: #edf8ef;
  --white: white;
  --primary-color-20: #00703d33;
  --brand-4: #00703d22;
  --text-1: #1d2920;
  --text-2: #616961;
  --text-3: #979c98;
  --text-4: #b8bbb8;
  --text-blue: #3c68bf;
  --text-red: #d16559;
  --neutral-fill-1: #f8f9f8;
  --neutral-fill-2: #f1f3f1;
  --neutral-fill-3: #e0e3e0;
  --neutral-border: #f2f2f2;
  --neutral-icon: #696d69;
  --blue-bg-color: #f2f7f9;
  --red-bg-color: #fdf2f0;
  --error-1: #e4000c;
  --error-2: #fff3f4;
  --warn-1: #e88e00;
  --warn-2: #fff6e7;
  --antd-wave-shadow-color: var(--primary-color) !important;
}
span {
  color: var(--text-1);
  font-weight: 400;
  font-size: 14px;
  line-height: 22px;
}
.text-1 {
  color: var(--text-1);
}
.text-2 {
  color: var(--text-2);
}
.text-3 {
  color: var(--text-3);
}
.text-4 {
  color: var(--text-4);
}
.white {
  color: var(--white);
}
.primary-color {
  color: var(--primary-color);
}
.error-color {
  color: var(--error-1);
}
.neutral-icon {
  color: var(--neutral-icon);
}
`;
  document.head.appendChild(style);
})();
/**
* @vue/shared v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(","))
    map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject$1(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value2) => objectToString.call(value2);
const toRawType = (value2) => {
  return toTypeString(value2).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-\w/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (c) => c.slice(1).toUpperCase());
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
const hasChanged = (value2, oldValue) => !Object.is(value2, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value2, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value: value2
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : {});
};
function genCacheKey(source, options) {
  return source + JSON.stringify(
    options,
    (_, val) => typeof val === "function" ? val.toString() : val
  );
}
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
function normalizeStyle(value2) {
  if (isArray(value2)) {
    const res = {};
    for (let i = 0; i < value2.length; i++) {
      const item = value2[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value2) || isObject$1(value2)) {
    return value2;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value2) {
  let res = "";
  if (isString(value2)) {
    res = value2;
  } else if (isArray(value2)) {
    for (let i = 0; i < value2.length; i++) {
      const normalized = normalizeClass(value2[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$1(value2)) {
    for (const name in value2) {
      if (value2[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value2) {
  return !!value2 || value2 === "";
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$1(a);
  bValidType = isObject$1(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject$1(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$1(val) && !isArray(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};
function normalizeCssVarValue(value2) {
  if (value2 == null) {
    return "initial";
  }
  if (typeof value2 === "string") {
    return value2 === "" ? " " : value2;
  }
  return String(value2);
}
/**
* @vue/reactivity v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this._on = 0;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed2 = false) {
  sub.flags |= 8;
  if (isComputed2) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error)
            error = err;
        }
      }
      e = next;
    }
  }
  if (error)
    throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail)
        tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= -17;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
    return;
  }
  computed2.flags |= 2;
  const dep = computed2.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value2 = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value2, computed2._value)) {
      computed2.flags |= 128;
      computed2._value = value2;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const e = new ReactiveEffect(fn);
  if (options) {
    extend(e, options);
  }
  try {
    e.run();
  } catch (err) {
    e.stop();
    throw err;
  }
  const runner = e.run.bind(e);
  runner.effect = e;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
    this.__v_skip = true;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false)
        ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l = computed2.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail)
        currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array)
    return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value2) => {
      value2[1] = toReactive(value2[1]);
      return value2;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (!result.done) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toReactive(item), index, self2);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self2, method, fn, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn;
  if (arr !== self2) {
    if (!isShallow(self2)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self2);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self2)[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty(key) {
  if (!isSymbol(key))
    key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip")
      return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      const value2 = targetIsArray && isIntegerKey(key) ? res : res.value;
      return isReadonly2 && isObject$1(value2) ? readonly(value2) : value2;
    }
    if (isObject$1(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value2, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value2) && !isReadonly(value2)) {
        oldValue = toRaw(oldValue);
        value2 = toRaw(value2);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value2)) {
        if (isOldValueReadonly) {
          return true;
        } else {
          oldValue.value = value2;
          return true;
        }
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value2,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value2);
      } else if (hasChanged(value2, oldValue)) {
        trigger(target, "set", key, value2);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value2) => value2;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value: value2, done } = innerIterator.next();
        return done ? { value: value2, done } : {
          value: isPair ? [wrap(value2[0]), wrap(value2[1])] : wrap(value2),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return target.size;
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value2, key) => {
        return callback.call(thisArg, wrap(value2), wrap(key), observed);
      });
    }
  };
  extend(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value2) {
        if (!shallow && !isShallow(value2) && !isReadonly(value2)) {
          value2 = toRaw(value2);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value2);
        if (!hadKey) {
          target.add(value2);
          trigger(target, "add", value2, value2);
        }
        return this;
      },
      set(key, value2) {
        if (!shallow && !isShallow(value2) && !isReadonly(value2)) {
          value2 = toRaw(value2);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value2);
        if (!hadKey) {
          trigger(target, "add", key, value2);
        } else if (hasChanged(value2, oldValue)) {
          trigger(target, "set", key, value2);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value2) {
  return value2["__v_skip"] || !Object.isExtensible(value2) ? 0 : targetTypeMap(toRawType(value2));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$1(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value2) {
  if (isReadonly(value2)) {
    return isReactive(value2["__v_raw"]);
  }
  return !!(value2 && value2["__v_isReactive"]);
}
function isReadonly(value2) {
  return !!(value2 && value2["__v_isReadonly"]);
}
function isShallow(value2) {
  return !!(value2 && value2["__v_isShallow"]);
}
function isProxy(value2) {
  return value2 ? !!value2["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value2) {
  if (!hasOwn(value2, "__v_skip") && Object.isExtensible(value2)) {
    def(value2, "__v_skip", true);
  }
  return value2;
}
const toReactive = (value2) => isObject$1(value2) ? reactive(value2) : value2;
const toReadonly = (value2) => isObject$1(value2) ? readonly(value2) : value2;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value2) {
  return createRef(value2, false);
}
function shallowRef(value2) {
  return createRef(value2, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value2, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value2 : toRaw(value2);
    this._value = isShallow2 ? value2 : toReactive(value2);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function triggerRef(ref2) {
  if (ref2.dep) {
    {
      ref2.dep.trigger();
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return isFunction(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value2, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value2)) {
      oldValue.value = value2;
      return true;
    } else {
      return Reflect.set(target, key, value2, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this["__v_isRef"] = true;
    this._value = void 0;
    const dep = this.dep = new Dep();
    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
    this._get = get;
    this._set = set;
  }
  get value() {
    return this._value = this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
  }
  get value() {
    const val = this._object[this._key];
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this["__v_isRef"] = true;
    this["__v_isReadonly"] = true;
    this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$1(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function getCurrentWatcher() {
  return activeWatcher;
}
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups)
      cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep)
      return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction(s)) {
        return call ? call(s, 2) : s();
      } else
        ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope && scope.active) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          oldValue = newValue;
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups)
          cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value2, depth = Infinity, seen2) {
  if (depth <= 0 || !isObject$1(value2) || value2["__v_skip"]) {
    return value2;
  }
  seen2 = seen2 || /* @__PURE__ */ new Map();
  if ((seen2.get(value2) || 0) >= depth) {
    return value2;
  }
  seen2.set(value2, depth);
  depth--;
  if (isRef(value2)) {
    traverse(value2.value, depth, seen2);
  } else if (isArray(value2)) {
    for (let i = 0; i < value2.length; i++) {
      traverse(value2[i], depth, seen2);
    }
  } else if (isSet(value2) || isMap(value2)) {
    value2.forEach((v) => {
      traverse(v, depth, seen2);
    });
  } else if (isPlainObject$1(value2)) {
    for (const key in value2) {
      traverse(value2[key], depth, seen2);
    }
    for (const key of Object.getOwnPropertySymbols(value2)) {
      if (Object.prototype.propertyIsEnumerable.call(value2, key)) {
        traverse(value2[key], depth, seen2);
      }
    }
  }
  return value2;
}
/**
* @vue/runtime-core v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack$1 = [];
function pushWarningContext(vnode) {
  stack$1.push(vnode);
}
function popWarningContext() {
  stack$1.pop();
}
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning)
    return;
  isWarning = true;
  pauseTracking();
  const instance = stack$1.length ? stack$1[stack$1.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack$1[stack$1.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value2, raw) {
  if (isString(value2)) {
    value2 = JSON.stringify(value2);
    return raw ? value2 : [`${key}=${value2}`];
  } else if (typeof value2 === "number" || typeof value2 === "boolean" || value2 == null) {
    return raw ? value2 : [`${key}=${value2}`];
  } else if (isRef(value2)) {
    value2 = formatProp(key, toRaw(value2.value), true);
    return raw ? value2 : [`${key}=Ref<`, value2, `>`];
  } else if (isFunction(value2)) {
    return [`${key}=fn${value2.name ? `<${value2.name}>` : ``}`];
  } else {
    value2 = toRaw(value2);
    return raw ? value2 : [`${key}=`, value2];
  }
}
function assertNumber(val, type) {
  return;
}
const ErrorCodes = {
  "SETUP_FUNCTION": 0,
  "0": "SETUP_FUNCTION",
  "RENDER_FUNCTION": 1,
  "1": "RENDER_FUNCTION",
  "NATIVE_EVENT_HANDLER": 5,
  "5": "NATIVE_EVENT_HANDLER",
  "COMPONENT_EVENT_HANDLER": 6,
  "6": "COMPONENT_EVENT_HANDLER",
  "VNODE_HOOK": 7,
  "7": "VNODE_HOOK",
  "DIRECTIVE_HOOK": 8,
  "8": "DIRECTIVE_HOOK",
  "TRANSITION_HOOK": 9,
  "9": "TRANSITION_HOOK",
  "APP_ERROR_HANDLER": 10,
  "10": "APP_ERROR_HANDLER",
  "APP_WARN_HANDLER": 11,
  "11": "APP_WARN_HANDLER",
  "FUNCTION_REF": 12,
  "12": "FUNCTION_REF",
  "ASYNC_COMPONENT_LOADER": 13,
  "13": "ASYNC_COMPONENT_LOADER",
  "SCHEDULER": 14,
  "14": "SCHEDULER",
  "COMPONENT_UPDATE": 15,
  "15": "COMPONENT_UPDATE",
  "APP_UNMOUNT_CLEANUP": 16,
  "16": "APP_UNMOUNT_CLEANUP"
};
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush",
  [15]: "component update",
  [16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick$1(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen2, i = flushIndex + 1) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8))
        cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen2) {
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false)
          ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let devtools$1;
let buffer = [];
function setDevtoolsHook$1(hook, target) {
  var _a, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer = [];
      }
    }, 3e3);
  } else {
    buffer = [];
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value2, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value2);
      }
      bindings.push({
        dir,
        instance,
        value: value2,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (parentComponent && parentComponent.isCE) {
            (parentComponent.ce._teleportTargets || (parentComponent.ce._teleportTargets = /* @__PURE__ */ new Set())).add(target);
          }
          if (!disabled) {
            mount(target, targetAnchor);
            updateCssVars(n2, false);
          }
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        n2.el.__isMounted = false;
        queuePostRenderEffect(() => {
          mountToTarget();
          delete n2.el.__isMounted;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  function hydrateDisabledTeleport(node2, vnode2, targetStart, targetAnchor) {
    vnode2.anchor = hydrateChildren(
      nextSibling(node2),
      vnode2,
      parentNode(node2),
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    vnode2.targetStart = targetStart;
    vnode2.targetAnchor = targetAnchor;
  }
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  const disabled = isTeleportDisabled(vnode.props);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        hydrateDisabledTeleport(
          node,
          vnode,
          targetNode,
          targetNode && nextSibling(targetNode)
        );
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  } else if (disabled) {
    if (vnode.shapeFlag & 16) {
      hydrateDisabledTeleport(node, vnode, node, nextSibling(node));
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(oldInnerChild, innerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c of children) {
      if (c.type !== Comment) {
        child = c;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone)
        postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if (vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function useId() {
  const i = getCurrentInstance();
  if (i) {
    return (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++;
  }
  return "";
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
function useTemplateRef(key) {
  const i = getCurrentInstance();
  const r = shallowRef(null);
  if (i) {
    const refs = i.refs === EMPTY_OBJ ? i.refs = {} : i.refs;
    {
      Object.defineProperty(refs, key, {
        enumerable: true,
        get: () => r.value,
        set: (val) => r.value = val
      });
    }
  }
  const ret = r;
  return ret;
}
const pendingSetRefMap = /* @__PURE__ */ new WeakMap();
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value2 = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? NO : (key) => {
    return hasOwn(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref2) {
    invalidatePendingSetRef(oldRawRef);
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      {
        oldRef.value = null;
      }
      const oldRawRefAtom = oldRawRef;
      if (oldRawRefAtom.k)
        refs[oldRawRefAtom.k] = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value2, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (canSetSetupRef(ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                const newVal = [refValue];
                {
                  ref2.value = newVal;
                }
                if (rawRef.k)
                  refs[rawRef.k] = newVal;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value2;
          if (canSetSetupRef(ref2)) {
            setupState[ref2] = value2;
          }
        } else if (_isRef) {
          {
            ref2.value = value2;
          }
          if (rawRef.k)
            refs[rawRef.k] = value2;
        } else
          ;
      };
      if (value2) {
        const job = () => {
          doSet();
          pendingSetRefMap.delete(rawRef);
        };
        job.id = -1;
        pendingSetRefMap.set(rawRef, job);
        queuePostRenderEffect(job, parentSuspense);
      } else {
        invalidatePendingSetRef(rawRef);
        doSet();
      }
    }
  }
}
function invalidatePendingSetRef(rawRef) {
  const pendingSetRef = pendingSetRefMap.get(rawRef);
  if (pendingSetRef) {
    pendingSetRef.flags |= 8;
    pendingSetRefMap.delete(rawRef);
  }
}
let hasLoggedMismatchError = false;
const logMismatchError = () => {
  if (hasLoggedMismatchError) {
    return;
  }
  console.error("Hydration completed but contains mismatches.");
  hasLoggedMismatchError = true;
};
const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
const getContainerType = (container) => {
  if (container.nodeType !== 1)
    return void 0;
  if (isSVGContainer(container))
    return "svg";
  if (isMathMLContainer(container))
    return "mathml";
  return void 0;
};
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp: patchProp2,
      createText,
      nextSibling,
      parentNode,
      remove: remove2,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref: ref2, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            logMismatchError();
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (isTemplateNode2(node)) {
          nextNode = nextSibling(node);
          replaceNode(
            vnode.el = node.content.firstChild,
            node,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode2(node)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node);
          } else if (isComment(node) && node.data === "teleport start") {
            nextNode = locateClosingAnchor(node, node.data, "teleport end");
          } else {
            nextNode = nextSibling(node);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            optimized
          );
          if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            getContainerType(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else
          ;
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatch = type === "input" || type === "option";
    if (forcePatch || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode2(el)) {
        needCallTransitionHooks = needTransition(
          null,
          // no need check parentSuspense in hydration
          transition
        ) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          const cls = content.getAttribute("class");
          if (cls)
            content.$cls = cls;
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        while (next) {
          if (!isMismatchAllowed(
            el,
            1
            /* CHILDREN */
          )) {
            logMismatchError();
          }
          const cur = next;
          next = next.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        let clientText = vnode.children;
        if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) {
          clientText = clientText.slice(1);
        }
        if (el.textContent !== clientText) {
          if (!isMismatchAllowed(
            el,
            0
            /* TEXT */
          )) {
            logMismatchError();
          }
          el.textContent = vnode.children;
        }
      }
      if (props) {
        if (forcePatch || !optimized || patchFlag & (16 | 32)) {
          const isCustomElement = el.tagName.includes("-");
          for (const key in props) {
            if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers
            key[0] === "." || isCustomElement) {
              patchProp2(el, key, null, props[key], void 0, parentComponent);
            }
          }
        } else if (props.onClick) {
          patchProp2(
            el,
            "onClick",
            null,
            props.onClick,
            void 0,
            parentComponent
          );
        } else if (patchFlag & 4 && isReactive(props.style)) {
          for (const key in props.style)
            props.style[key];
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      const isText = vnode.type === Text;
      if (node) {
        if (isText && !optimized) {
          if (i + 1 < l && normalizeVNode(children[i + 1]).type === Text) {
            insert(
              createText(
                node.data.slice(vnode.children.length)
              ),
              container,
              nextSibling(node)
            );
            node.data = vnode.children;
          }
        }
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (isText && !vnode.children) {
        insert(vnode.el = createText(""), container);
      } else {
        if (!isMismatchAllowed(
          container,
          1
          /* CHILDREN */
        )) {
          logMismatchError();
        }
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      logMismatchError();
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    if (!isMismatchAllowed(
      node.parentElement,
      1
      /* CHILDREN */
    )) {
      logMismatchError();
    }
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove2(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove2(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      getContainerType(container),
      slotScopeIds
    );
    if (parentComponent) {
      parentComponent.vnode.el = vnode.el;
      updateHOCHostEl(parentComponent, vnode.el);
    }
    return next;
  };
  const locateClosingAnchor = (node, open = "[", close = "]") => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === open)
          match++;
        if (node.data === close) {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode2 = (node) => {
    return node.nodeType === 1 && node.tagName === "TEMPLATE";
  };
  return [hydrate2, hydrateNode];
}
const allowMismatchAttr = "data-allow-mismatch";
const MismatchTypeString = {
  [
    0
    /* TEXT */
  ]: "text",
  [
    1
    /* CHILDREN */
  ]: "children",
  [
    2
    /* CLASS */
  ]: "class",
  [
    3
    /* STYLE */
  ]: "style",
  [
    4
    /* ATTRIBUTE */
  ]: "attribute"
};
function isMismatchAllowed(el, allowedType) {
  if (allowedType === 0 || allowedType === 1) {
    while (el && !el.hasAttribute(allowMismatchAttr)) {
      el = el.parentElement;
    }
  }
  const allowedAttr = el && el.getAttribute(allowMismatchAttr);
  if (allowedAttr == null) {
    return false;
  } else if (allowedAttr === "") {
    return true;
  } else {
    const list = allowedAttr.split(",");
    if (allowedType === 0 && list.includes("children")) {
      return true;
    }
    return list.includes(MismatchTypeString[allowedType]);
  }
}
const requestIdleCallback = getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
const cancelIdleCallback = getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
const hydrateOnIdle = (timeout = 1e4) => (hydrate2) => {
  const id = requestIdleCallback(hydrate2, { timeout });
  return () => cancelIdleCallback(id);
};
function elementIsVisibleInViewport(el) {
  const { top, left, bottom, right } = el.getBoundingClientRect();
  const { innerHeight, innerWidth } = window;
  return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
}
const hydrateOnVisible = (opts) => (hydrate2, forEach) => {
  const ob = new IntersectionObserver((entries) => {
    for (const e of entries) {
      if (!e.isIntersecting)
        continue;
      ob.disconnect();
      hydrate2();
      break;
    }
  }, opts);
  forEach((el) => {
    if (!(el instanceof Element))
      return;
    if (elementIsVisibleInViewport(el)) {
      hydrate2();
      ob.disconnect();
      return false;
    }
    ob.observe(el);
  });
  return () => ob.disconnect();
};
const hydrateOnMediaQuery = (query) => (hydrate2) => {
  if (query) {
    const mql = matchMedia(query);
    if (mql.matches) {
      hydrate2();
    } else {
      mql.addEventListener("change", hydrate2, { once: true });
      return () => mql.removeEventListener("change", hydrate2);
    }
  }
};
const hydrateOnInteraction = (interactions = []) => (hydrate2, forEach) => {
  if (isString(interactions))
    interactions = [interactions];
  let hasHydrated = false;
  const doHydrate = (e) => {
    if (!hasHydrated) {
      hasHydrated = true;
      teardown();
      hydrate2();
      e.target.dispatchEvent(new e.constructor(e.type, e));
    }
  };
  const teardown = () => {
    forEach((el) => {
      for (const i of interactions) {
        el.removeEventListener(i, doHydrate);
      }
    });
  };
  forEach((el) => {
    for (const i of interactions) {
      el.addEventListener(i, doHydrate, { once: true });
    }
  });
  return teardown;
};
function forEachElement(node, cb) {
  if (isComment(node) && node.data === "[") {
    let depth = 1;
    let next = node.nextSibling;
    while (next) {
      if (next.nodeType === 1) {
        const result = cb(next);
        if (result === false) {
          break;
        }
      } else if (isComment(next)) {
        if (next.data === "]") {
          if (--depth === 0)
            break;
        } else if (next.data === "[") {
          depth++;
        }
      }
      next = next.nextSibling;
    }
  } else {
    cb(node);
  }
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    hydrate: hydrateStrategy,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return /* @__PURE__ */ defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    __asyncHydrate(el, instance, hydrate2) {
      let patched = false;
      (instance.bu || (instance.bu = [])).push(() => patched = true);
      const performHydrate = () => {
        if (patched) {
          return;
        }
        hydrate2();
      };
      const doHydrate = hydrateStrategy ? () => {
        const teardown = hydrateStrategy(
          performHydrate,
          (cb) => forEachElement(el, cb)
        );
        if (teardown) {
          (instance.bum || (instance.bum = [])).push(teardown);
        }
      } : performHydrate;
      if (resolvedComp) {
        doHydrate();
      } else {
        load().then(() => !instance.isUnmounted && doHydrate());
      }
    },
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      markAsyncBoundary(instance);
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.update();
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref2, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache2 = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache2.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && !filter(name)) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache2.get(key);
      if (cached && (!current || !isSameVNodeType(cached, current))) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache2.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache2.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return current = null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      if (vnode.type === Comment) {
        current = null;
        return vnode;
      }
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        vnode.shapeFlag &= -257;
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache2.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray(pattern)) {
    return pattern.some((p2) => matches(p2, name));
  } else if (isString(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp(pattern)) {
    pattern.lastIndex = 0;
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= -257;
  vnode.shapeFlag &= -513;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset2 = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset2();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // window registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source, renderItem, cache2, index) {
  let ret;
  const cached = cache2 && cache2[index];
  const sourceIsArray = isArray(source);
  if (sourceIsArray || isString(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    let isReadonlySource = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      isReadonlySource = isReadonly(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i])) : toReactive(source[i]) : source[i],
        i,
        void 0,
        cached && cached[i]
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$1(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res)
          res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    const hasProps = Object.keys(props).length > 0;
    if (name !== "default")
      props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      hasProps ? -2 : 64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick$1.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // window properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value2) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value2;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value2;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value2;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions, type }
  }, key) {
    let normalizedProps, cssModules;
    return !!(accessCache[key] || data !== EMPTY_OBJ && key[0] !== "$" && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key) || (cssModules = type.__cssModules) && cssModules[key]);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has = key[0] !== "_" && !isGloballyAllowed(key);
    return has;
  }
});
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function defineOptions(options) {
}
function defineSlots() {
  return null;
}
function defineModel() {
}
function withDefaults(props, defaults) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext(calledFunctionName) {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip"))
      continue;
    let opt = props[key];
    if (opt) {
      if (isArray(opt) || isFunction(opt)) {
        opt = props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults[key] };
    } else
      ;
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a, b) {
  if (!a || !b)
    return a || b;
  if (isArray(a) && isArray(b))
    return a.concat(b);
  return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$1(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val,
          enumerable: true
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$1(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$1(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$1(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray$1,
  created: mergeAsArray$1,
  beforeMount: mergeAsArray$1,
  mounted: mergeAsArray$1,
  beforeUpdate: mergeAsArray$1,
  updated: mergeAsArray$1,
  beforeDestroy: mergeAsArray$1,
  beforeUnmount: mergeAsArray$1,
  destroyed: mergeAsArray$1,
  unmounted: mergeAsArray$1,
  activated: mergeAsArray$1,
  deactivated: mergeAsArray$1,
  errorCaptured: mergeAsArray$1,
  serverPrefetch: mergeAsArray$1,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction(to) ? to.call(this, this) : to,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray$1(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray$1(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$1(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin2) {
        {
          if (!context.mixins.includes(mixin2)) {
            context.mixins.push(mixin2);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render2(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value2) {
        context.provides[key] = value2;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value2) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value2;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = getCurrentInstance();
  if (instance || currentApp) {
    let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else
      ;
  }
}
function hasInjectionContext() {
  return !!(getCurrentInstance() || currentApp);
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value2 = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value2 !== attrs[key]) {
              attrs[key] = value2;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value2,
              instance,
              false
            );
          }
        } else {
          if (value2 !== attrs[key]) {
            attrs[key] = value2;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value2 = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value2;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value2;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value2 !== attrs[key]) {
          attrs[key] = value2;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value2, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value2 === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value2 = propsDefaults[key];
        } else {
          const reset2 = setCurrentInstance(instance);
          value2 = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset2();
        }
      } else {
        value2 = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value2);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value2 = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value2 === "" || value2 === hyphenate(key))) {
        value2 = true;
      }
    }
  }
  return value2;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = isFunction(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$1(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key === "_" || key === "_ctx" || key === "$stable";
const normalizeSlotValue = (value2) => isArray(value2) ? value2.map(normalizeVNode) : [normalizeVNode(value2)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value2 = rawSlots[key];
    if (isFunction(value2)) {
      slots[key] = normalizeSlot(key, value2, ctx);
    } else if (value2 != null) {
      const normalized = normalizeSlotValue(value2);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || !isInternalKey(key)) {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    } else if (ref2 == null && n1 && n1.ref != null) {
      setRef(n1.ref, null, parentSuspense, n1, true);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
        initialVNode.placeholder = placeholder.el;
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode && type.__asyncHydrate) {
            type.__asyncHydrate(
              el,
              instance,
              hydrateSubTree
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (root.ce && // @ts-expect-error _def is private
          root.ce._def.shadowRoot !== false) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchorVNode = c2[nextIndex + 1];
        const anchor = nextIndex + 1 < l2 ? (
          // #13559, fallback to el placeholder for unresolved async component
          anchorVNode.el || anchorVNode.placeholder
        ) : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => {
          if (vnode.ctx.isUnmounted) {
            hostRemove(el);
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const performLeave = () => {
          if (el._isLeaving) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref2,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref2 != null) {
      pauseTracking();
      setRef(ref2, null, parentSuspense, vnode, true);
      resetTracking();
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, job, subTree, um, m, a } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render2 = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text && // avoid cached text nodes retaining detached dom nodes
      c2.patchFlag !== -1) {
        c2.el = c1.el;
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "post" }
  );
}
function watchSyncEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "sync" }
  );
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value2, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value2)) {
    cb = value2;
  } else {
    cb = value2.handler;
    options = value2;
  }
  const reset2 = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset2();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function useModel(props, name, options = EMPTY_OBJ) {
  const i = getCurrentInstance();
  const camelizedName = camelize(name);
  const hyphenatedName = hyphenate(name);
  const modifiers = getModelModifiers(props, camelizedName);
  const res = customRef((track2, trigger2) => {
    let localValue;
    let prevSetValue = EMPTY_OBJ;
    let prevEmittedValue;
    watchSyncEffect(() => {
      const propValue = props[camelizedName];
      if (hasChanged(localValue, propValue)) {
        localValue = propValue;
        trigger2();
      }
    });
    return {
      get() {
        track2();
        return options.get ? options.get(localValue) : localValue;
      },
      set(value2) {
        const emittedValue = options.set ? options.set(value2) : value2;
        if (!hasChanged(emittedValue, localValue) && !(prevSetValue !== EMPTY_OBJ && hasChanged(value2, prevSetValue))) {
          return;
        }
        const rawProps = i.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
          localValue = value2;
          trigger2();
        }
        i.emit(`update:${name}`, emittedValue);
        if (hasChanged(value2, emittedValue) && hasChanged(value2, prevSetValue) && !hasChanged(emittedValue, prevEmittedValue)) {
          trigger2();
        }
        prevSetValue = value2;
        prevEmittedValue = emittedValue;
      }
    };
  });
  res[Symbol.iterator] = () => {
    let i2 = 0;
    return {
      next() {
        if (i2 < 2) {
          return { value: i2++ ? modifiers || EMPTY_OBJ : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
const mixinEmitsCache = /* @__PURE__ */ new WeakMap();
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = asMixin ? mixinEmitsCache : appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$1(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render2.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render22(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const isSuspense = (type) => type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(pendingBranch, newBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(activeBranch, newBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(activeBranch, newBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove: remove2 }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense && parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) === container2) {
            anchor = next(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect, optimized2) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          namespace,
          optimized2
        );
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  const suspensible = vnode.props && vnode.props.suspensible;
  return suspensible != null && suspensible !== false;
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value2, inVOnce = false) {
  isBlockTreeEnabled += value2;
  if (value2 < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value2) {
  return value2 ? value2.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref2,
  ref_key,
  ref_for
}) => {
  if (typeof ref2 === "number") {
    ref2 = "" + ref2;
  }
  return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$1(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref2, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    placeholder: vnode.placeholder,
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key]))
      setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1)
        setters.forEach((set) => set(v));
      else
        setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized || isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset2 = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise(setupResult);
    resetTracking();
    reset2();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$1(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    const reset2 = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset2();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])\w/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value2) {
  return isFunction(value2) && "__vccOpts" in value2;
}
const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};
function h(type, propsOrChildren, children) {
  try {
    setBlockTracking(-1);
    const l = arguments.length;
    if (l === 2) {
      if (isObject$1(propsOrChildren) && !isArray(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  } finally {
    setBlockTracking(1);
  }
}
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo, render2, cache2, index) {
  const cached = cache2[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  ret.cacheIndex = index;
  return cache2[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if (hasChanged(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version = "3.5.22";
const warn = NOOP;
const ErrorTypeStrings = ErrorTypeStrings$1;
const devtools = devtools$1;
const setDevtoolsHook = setDevtoolsHook$1;
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode,
  getComponentPublicInstance,
  ensureValidVNode,
  pushWarningContext,
  popWarningContext
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;
/**
* @vue/runtime-dom v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION$1 = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t2) => {
  t2.displayName = "Transition";
  t2.props = TransitionPropsValidators;
  return t2;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow(el);
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow(el);
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$1(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION$1}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION$1}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION$1) {
    if (transitionTimeout > 0) {
      type = TRANSITION$1;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION$1 : ANIMATION : null;
    propCount = type ? type === TRANSITION$1 ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION$1 && /\b(?:transform|all)(?:,|$)/.test(
    getStyleProperties(`${TRANSITION$1}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto")
    return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow(el) {
  const targetDocument = el ? el.ownerDocument : document;
  return targetDocument.body.offsetHeight;
}
function patchClass(el, value2, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value2 = (value2 ? [value2, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value2 == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value2);
  } else {
    el.className = value2;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(el, { value: value2 }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value2) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value2);
    }
  },
  mounted(el, { value: value2 }, { transition }) {
    if (transition && value2) {
      transition.enter(el);
    }
  },
  updated(el, { value: value2, oldValue }, { transition }) {
    if (!value2 === !oldValue)
      return;
    if (transition) {
      if (value2) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value2);
    }
  },
  beforeUnmount(el, { value: value2 }) {
    setDisplay(el, value2);
  }
};
function setDisplay(el, value2) {
  el.style.display = value2 ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value2;
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value: value2 }) => {
    if (!value2) {
      return { style: { display: "none" } };
    }
  };
}
const CSS_VAR_TEXT = Symbol("");
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    if (instance.ce) {
      setVarsOnNode(instance.ce, vars);
    } else {
      setVarsOnVNode(instance.subTree, vars);
    }
    updateTeleports(vars);
  };
  onBeforeUpdate(() => {
    queuePostFlushCb(setVars);
  });
  onMounted(() => {
    watch(setVars, NOOP, { flush: "post" });
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      const value2 = normalizeCssVarValue(vars[key]);
      style.setProperty(`--${key}`, value2);
      cssText += `--${key}: ${value2};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}
const displayRE = /(?:^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value2, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value2 == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value2);
    }
  } else {
    if (value2 == null || isBoolean && !includeBooleanAttr(value2)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : isSymbol(value2) ? String(value2) : value2
      );
    }
  }
}
function patchDOMProp(el, key, value2, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value2 != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value2) : value2;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value2 == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value2);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value2 == null) {
      el.removeAttribute(key);
    }
    el._value = value2;
    return;
  }
  let needRemove = false;
  if (value2 === "" || value2 == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value2 = includeBooleanAttr(value2);
    } else if (value2 == null && type === "string") {
      value2 = "";
      needRemove = true;
    } else if (type === "number") {
      value2 = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value2;
  } catch (e) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener$1(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener$1(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener$1(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener$1(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value2) {
  if (isArray(value2)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value2.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value2;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
  ) {
    patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value2, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction(value2)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString(value2)) {
    return false;
  }
  return key in el;
}
const REMOVAL = {};
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, extraOptions, _createApp) {
  let Comp = /* @__PURE__ */ defineComponent(options, extraOptions);
  if (isPlainObject$1(Comp))
    Comp = extend({}, Comp, extraOptions);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, _createApp);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {
  return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, _createApp = createApp) {
    super();
    this._def = _def;
    this._props = _props;
    this._createApp = _createApp;
    this._isVueCE = true;
    this._instance = null;
    this._app = null;
    this._nonce = this._def.nonce;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._styleChildren = /* @__PURE__ */ new WeakSet();
    this._ob = null;
    if (this.shadowRoot && _createApp !== createApp) {
      this._root = this.shadowRoot;
    } else {
      if (_def.shadowRoot !== false) {
        this.attachShadow(
          extend({}, _def.shadowRootOptions, {
            mode: "open"
          })
        );
        this._root = this.shadowRoot;
      } else {
        this._root = this;
      }
    }
  }
  connectedCallback() {
    if (!this.isConnected)
      return;
    if (!this.shadowRoot && !this._resolved) {
      this._parseSlots();
    }
    this._connected = true;
    let parent = this;
    while (parent = parent && (parent.parentNode || parent.host)) {
      if (parent instanceof VueElement) {
        this._parent = parent;
        break;
      }
    }
    if (!this._instance) {
      if (this._resolved) {
        this._mount(this._def);
      } else {
        if (parent && parent._pendingResolve) {
          this._pendingResolve = parent._pendingResolve.then(() => {
            this._pendingResolve = void 0;
            this._resolveDef();
          });
        } else {
          this._resolveDef();
        }
      }
    }
  }
  _setParent(parent = this._parent) {
    if (parent) {
      this._instance.parent = parent._instance;
      this._inheritParentContext(parent);
    }
  }
  _inheritParentContext(parent = this._parent) {
    if (parent && this._app) {
      Object.setPrototypeOf(
        this._app._context.provides,
        parent._instance.provides
      );
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick$1(() => {
      if (!this._connected) {
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        this._app && this._app.unmount();
        if (this._instance)
          this._instance.ce = void 0;
        this._app = this._instance = null;
        if (this._teleportTargets) {
          this._teleportTargets.clear();
          this._teleportTargets = void 0;
        }
      }
    });
  }
  _processMutations(mutations) {
    for (const m of mutations) {
      this._setAttr(m.attributeName);
    }
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve) {
      return;
    }
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    this._ob = new MutationObserver(this._processMutations.bind(this));
    this._ob.observe(this, { attributes: true });
    const resolve2 = (def2, isAsync = false) => {
      this._resolved = true;
      this._pendingResolve = void 0;
      const { props, styles } = def2;
      let numberProps;
      if (props && !isArray(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      this._resolveProps(def2);
      if (this.shadowRoot) {
        this._applyStyles(styles);
      }
      this._mount(def2);
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      this._pendingResolve = asyncDef().then((def2) => {
        def2.configureApp = this._def.configureApp;
        resolve2(this._def = def2, true);
      });
    } else {
      resolve2(this._def);
    }
  }
  _mount(def2) {
    this._app = this._createApp(def2);
    this._inheritParentContext();
    if (def2.configureApp) {
      def2.configureApp(this._app);
    }
    this._app._ceVNode = this._createVNode();
    this._app.mount(this._root);
    const exposed = this._instance && this._instance.exposed;
    if (!exposed)
      return;
    for (const key in exposed) {
      if (!hasOwn(this, key)) {
        Object.defineProperty(this, key, {
          // unwrap ref to be consistent with public instance behavior
          get: () => unref(exposed[key])
        });
      }
    }
  }
  _resolveProps(def2) {
    const { props } = def2;
    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key]);
      }
    }
    for (const key of declaredPropKeys.map(camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val, true, true);
        }
      });
    }
  }
  _setAttr(key) {
    if (key.startsWith("data-v-"))
      return;
    const has = this.hasAttribute(key);
    let value2 = has ? this.getAttribute(key) : REMOVAL;
    const camelKey = camelize(key);
    if (has && this._numberProps && this._numberProps[camelKey]) {
      value2 = toNumber(value2);
    }
    this._setProp(camelKey, value2, false, true);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
    if (val !== this._props[key]) {
      if (val === REMOVAL) {
        delete this._props[key];
      } else {
        this._props[key] = val;
        if (key === "key" && this._app) {
          this._app._ceVNode.key = val;
        }
      }
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        const ob = this._ob;
        if (ob) {
          this._processMutations(ob.takeRecords());
          ob.disconnect();
        }
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
        ob && ob.observe(this, { attributes: true });
      }
    }
  }
  _update() {
    const vnode = this._createVNode();
    if (this._app)
      vnode.appContext = this._app._context;
    render(vnode, this._root);
  }
  _createVNode() {
    const baseProps = {};
    if (!this.shadowRoot) {
      baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
    }
    const vnode = createVNode(this._def, extend(baseProps, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.ce = this;
        instance.isCE = true;
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(
              event,
              isPlainObject$1(args[0]) ? extend({ detail: args }, args[0]) : { detail: args }
            )
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if (hyphenate(event) !== event) {
            dispatch(hyphenate(event), args);
          }
        };
        this._setParent();
      };
    }
    return vnode;
  }
  _applyStyles(styles, owner) {
    if (!styles)
      return;
    if (owner) {
      if (owner === this._def || this._styleChildren.has(owner)) {
        return;
      }
      this._styleChildren.add(owner);
    }
    const nonce = this._nonce;
    for (let i = styles.length - 1; i >= 0; i--) {
      const s = document.createElement("style");
      if (nonce)
        s.setAttribute("nonce", nonce);
      s.textContent = styles[i];
      this.shadowRoot.prepend(s);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const slots = this._slots = {};
    let n;
    while (n = this.firstChild) {
      const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
      (slots[slotName] || (slots[slotName] = [])).push(n);
      this.removeChild(n);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const outlets = this._getSlots();
    const scopeId = this._instance.type.__scopeId;
    for (let i = 0; i < outlets.length; i++) {
      const o = outlets[i];
      const slotName = o.getAttribute("name") || "default";
      const content = this._slots[slotName];
      const parent = o.parentNode;
      if (content) {
        for (const n of content) {
          if (scopeId && n.nodeType === 1) {
            const id = scopeId + "-s";
            const walker = document.createTreeWalker(n, 1);
            n.setAttribute(id, "");
            let child;
            while (child = walker.nextNode()) {
              child.setAttribute(id, "");
            }
          }
          parent.insertBefore(n, o);
        }
      } else {
        while (o.firstChild)
          parent.insertBefore(o.firstChild, o);
      }
      parent.removeChild(o);
    }
  }
  /**
   * @internal
   */
  _getSlots() {
    const roots = [this];
    if (this._teleportTargets) {
      roots.push(...this._teleportTargets);
    }
    return roots.reduce((res, i) => {
      res.push(...Array.from(i.querySelectorAll("slot")));
      return res;
    }, []);
  }
  /**
   * @internal
   */
  _injectChildStyle(comp) {
    this._applyStyles(comp.styles, comp);
  }
  /**
   * @internal
   */
  _removeChildStyle(comp) {
  }
}
function useHost(caller) {
  const instance = getCurrentInstance();
  const el = instance && instance.ce;
  if (el) {
    return el;
  }
  return null;
}
function useShadowRoot() {
  const el = useHost();
  return el && el.shadowRoot;
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const decorate = (t2) => {
  delete t2.props.mode;
  return t2;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        prevChildren = [];
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow(instance.vnode.el);
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || e.propertyName.endsWith("transform")) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
      prevChildren = [];
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      return createVNode(tag, null, children);
    };
  }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn) ? (value2) => invokeArrayFns(fn, value2) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener$1(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener$1(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener$1(el, "compositionstart", onCompositionStart);
      addEventListener$1(el, "compositionend", onCompositionEnd);
      addEventListener$1(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value: value2 }) {
    el.value = value2 == null ? "" : value2;
  },
  beforeUpdate(el, { value: value2, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing)
      return;
    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value2 == null ? "" : value2;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value2 === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener$1(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign2 = el[assignKey];
      if (isArray(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign2(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign2(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value: value2, oldValue }, vnode) {
  el._modelValue = value2;
  let checked;
  if (isArray(value2)) {
    checked = looseIndexOf(value2, vnode.props.value) > -1;
  } else if (isSet(value2)) {
    checked = value2.has(vnode.props.value);
  } else {
    if (value2 === oldValue)
      return;
    checked = looseEqual(value2, getCheckboxValue(el, true));
  }
  if (el.checked !== checked) {
    el.checked = checked;
  }
}
const vModelRadio = {
  created(el, { value: value2 }, vnode) {
    el.checked = looseEqual(value2, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener$1(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value: value2, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value2 !== oldValue) {
      el.checked = looseEqual(value2, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value: value2, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value2);
    addEventListener$1(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick$1(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value: value2 }) {
    setSelected(el, value2);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value: value2 }) {
    if (!el._assigning) {
      setSelected(el, value2);
    }
  }
};
function setSelected(el, value2) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray(value2);
  if (isMultiple && !isArrayValue && !isSet(value2)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value2.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = looseIndexOf(value2, optionValue) > -1;
        }
      } else {
        option.selected = value2.has(optionValue);
      }
    } else if (looseEqual(getValue(option), value2)) {
      if (el.selectedIndex !== i)
        el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value: value2 }) => ({ value: value2 });
  vModelRadio.getSSRProps = ({ value: value2 }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value2)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value: value2 }, vnode) => {
    if (isArray(value2)) {
      if (vnode.props && looseIndexOf(value2, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value2)) {
      if (vnode.props && value2.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value2) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache2 = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache2 = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn(event);
    }
  });
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, resolveRootNamespace(container));
    }
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
const runtimeDom = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition,
  BaseTransitionPropsValidators,
  Comment,
  DeprecationTypes,
  EffectScope,
  ErrorCodes,
  ErrorTypeStrings,
  Fragment,
  KeepAlive,
  ReactiveEffect,
  Static,
  Suspense,
  Teleport,
  Text,
  TrackOpTypes,
  Transition,
  TransitionGroup,
  TriggerOpTypes,
  VueElement,
  assertNumber,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize,
  capitalize,
  cloneVNode,
  compatUtils,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent,
  defineCustomElement,
  defineEmits,
  defineExpose,
  defineModel,
  defineOptions,
  defineProps,
  defineSSRCustomElement,
  defineSlots,
  devtools,
  effect,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  getCurrentWatcher,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  hasInjectionContext,
  hydrate,
  hydrateOnIdle,
  hydrateOnInteraction,
  hydrateOnMediaQuery,
  hydrateOnVisible,
  initCustomFormatter,
  initDirectivesForSSR,
  inject,
  isMemoSame,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isRuntimeOnly,
  isShallow,
  isVNode,
  markRaw,
  mergeDefaults,
  mergeModels,
  mergeProps,
  nextTick: nextTick$1,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  onWatcherCleanup,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  stop,
  toDisplayString,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef,
  toRefs,
  toValue,
  transformVNodeArgs,
  triggerRef,
  unref,
  useAttrs,
  useCssModule,
  useCssVars,
  useHost,
  useId,
  useModel,
  useSSRContext,
  useShadowRoot,
  useSlots,
  useTemplateRef,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version,
  warn,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withKeys,
  withMemo,
  withModifiers,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
/**
* @vue/compiler-core v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const FRAGMENT = Symbol(``);
const TELEPORT = Symbol(``);
const SUSPENSE = Symbol(``);
const KEEP_ALIVE = Symbol(``);
const BASE_TRANSITION = Symbol(
  ``
);
const OPEN_BLOCK = Symbol(``);
const CREATE_BLOCK = Symbol(``);
const CREATE_ELEMENT_BLOCK = Symbol(
  ``
);
const CREATE_VNODE = Symbol(``);
const CREATE_ELEMENT_VNODE = Symbol(
  ``
);
const CREATE_COMMENT = Symbol(
  ``
);
const CREATE_TEXT = Symbol(
  ``
);
const CREATE_STATIC = Symbol(
  ``
);
const RESOLVE_COMPONENT = Symbol(
  ``
);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(
  ``
);
const RESOLVE_DIRECTIVE = Symbol(
  ``
);
const RESOLVE_FILTER = Symbol(
  ``
);
const WITH_DIRECTIVES = Symbol(
  ``
);
const RENDER_LIST = Symbol(``);
const RENDER_SLOT = Symbol(``);
const CREATE_SLOTS = Symbol(``);
const TO_DISPLAY_STRING = Symbol(
  ``
);
const MERGE_PROPS = Symbol(``);
const NORMALIZE_CLASS = Symbol(
  ``
);
const NORMALIZE_STYLE = Symbol(
  ``
);
const NORMALIZE_PROPS = Symbol(
  ``
);
const GUARD_REACTIVE_PROPS = Symbol(
  ``
);
const TO_HANDLERS = Symbol(``);
const CAMELIZE = Symbol(``);
const CAPITALIZE = Symbol(``);
const TO_HANDLER_KEY = Symbol(
  ``
);
const SET_BLOCK_TRACKING = Symbol(
  ``
);
const PUSH_SCOPE_ID = Symbol(``);
const POP_SCOPE_ID = Symbol(``);
const WITH_CTX = Symbol(``);
const UNREF = Symbol(``);
const IS_REF = Symbol(``);
const WITH_MEMO = Symbol(``);
const IS_MEMO_SAME = Symbol(``);
const helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
const locStub = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 },
  source: ""
};
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: [],
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value2) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value: value2
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value2, needPauseTracking = false, inVOnce = false) {
  return {
    type: 20,
    index,
    value: value2,
    needPauseTracking,
    inVOnce,
    needArraySpread: false,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
const defaultDelimitersOpen = new Uint8Array([123, 123]);
const defaultDelimitersClose = new Uint8Array([125, 125]);
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
const Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea
};
class Tokenizer {
  constructor(stack2, cbs) {
    this.stack = stack2;
    this.cbs = cbs;
    this.state = 1;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.entityStart = 0;
    this.baseState = 1;
    this.inRCDATA = false;
    this.inXML = false;
    this.inVPre = false;
    this.newlines = [];
    this.mode = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
    this.delimiterIndex = -1;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
  }
  get inSFCRoot() {
    return this.mode === 2 && this.stack.length === 0;
  }
  reset() {
    this.state = 1;
    this.mode = 0;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = 1;
    this.inRCDATA = false;
    this.currentSequence = void 0;
    this.newlines.length = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
  }
  /**
   * Generate Position object with line / column information using recorded
   * newline positions. We know the index is always going to be an already
   * processed index, so all the newlines up to this index should have been
   * recorded.
   */
  getPos(index) {
    let line = 1;
    let column = index + 1;
    for (let i = this.newlines.length - 1; i >= 0; i--) {
      const newlineIndex = this.newlines[i];
      if (index > newlineIndex) {
        line = i + 2;
        column = index - newlineIndex;
        break;
      }
    }
    return {
      column,
      line,
      offset: index
    };
  }
  peek() {
    return this.buffer.charCodeAt(this.index + 1);
  }
  stateText(c) {
    if (c === 60) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!this.inVPre && c === this.delimiterOpen[0]) {
      this.state = 2;
      this.delimiterIndex = 0;
      this.stateInterpolationOpen(c);
    }
  }
  stateInterpolationOpen(c) {
    if (c === this.delimiterOpen[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const start = this.index + 1 - this.delimiterOpen.length;
        if (start > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, start);
        }
        this.state = 3;
        this.sectionStart = start;
      } else {
        this.delimiterIndex++;
      }
    } else if (this.inRCDATA) {
      this.state = 32;
      this.stateInRCDATA(c);
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInterpolation(c) {
    if (c === this.delimiterClose[0]) {
      this.state = 4;
      this.delimiterIndex = 0;
      this.stateInterpolationClose(c);
    }
  }
  stateInterpolationClose(c) {
    if (c === this.delimiterClose[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterClose.length - 1) {
        this.cbs.oninterpolation(this.sectionStart, this.index + 1);
        if (this.inRCDATA) {
          this.state = 32;
        } else {
          this.state = 1;
        }
        this.sectionStart = this.index + 1;
      } else {
        this.delimiterIndex++;
      }
    } else {
      this.state = 3;
      this.stateInterpolation(c);
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.inRCDATA = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = 6;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> and <textarea>, also decode entities. */
  stateInRCDATA(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === 62 || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        this.inRCDATA = false;
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
        if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      } else if (this.fastForwardTo(60)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === 60);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = 28;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = 23;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length) {
      const cc = this.buffer.charCodeAt(this.index);
      if (cc === 10) {
        this.newlines.push(this.index);
      }
      if (cc === c) {
        return true;
      }
    }
    this.index = this.buffer.length - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index - 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index - 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = 1;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  startSpecial(sequence, offset) {
    this.enterRCDATA(sequence, offset);
    this.state = 31;
  }
  enterRCDATA(sequence, offset) {
    this.inRCDATA = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
  }
  stateBeforeTagName(c) {
    if (c === 33) {
      this.state = 22;
      this.sectionStart = this.index + 1;
    } else if (c === 63) {
      this.state = 24;
      this.sectionStart = this.index + 1;
    } else if (isTagStartChar(c)) {
      this.sectionStart = this.index;
      if (this.mode === 0) {
        this.state = 6;
      } else if (this.inSFCRoot) {
        this.state = 34;
      } else if (!this.inXML) {
        if (c === 116) {
          this.state = 30;
        } else {
          this.state = c === 115 ? 29 : 6;
        }
      } else {
        this.state = 6;
      }
    } else if (c === 47) {
      this.state = 8;
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.handleTagName(c);
    }
  }
  stateInSFCRootTagName(c) {
    if (isEndOfTagSection(c)) {
      const tag = this.buffer.slice(this.sectionStart, this.index);
      if (tag !== "template") {
        this.enterRCDATA(toCharCodes(`</` + tag), 0);
      }
      this.handleTagName(c);
    }
  }
  handleTagName(c) {
    this.cbs.onopentagname(this.sectionStart, this.index);
    this.sectionStart = -1;
    this.state = 11;
    this.stateBeforeAttrName(c);
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c))
      ;
    else if (c === 62) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    } else {
      this.state = isTagStartChar(c) ? 9 : 27;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === 62 || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = 10;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === 62) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttrName(c) {
    if (c === 62) {
      this.cbs.onopentagend(this.index);
      if (this.inRCDATA) {
        this.state = 32;
      } else {
        this.state = 1;
      }
      this.sectionStart = this.index + 1;
    } else if (c === 47) {
      this.state = 7;
    } else if (c === 60 && this.peek() === 47) {
      this.cbs.onopentagend(this.index);
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!isWhitespace(c)) {
      this.handleAttrStart(c);
    }
  }
  handleAttrStart(c) {
    if (c === 118 && this.peek() === 45) {
      this.state = 13;
      this.sectionStart = this.index;
    } else if (c === 46 || c === 58 || c === 64 || c === 35) {
      this.cbs.ondirname(this.index, this.index + 1);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 12;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === 62) {
      this.cbs.onselfclosingtag(this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
      this.inRCDATA = false;
    } else if (!isWhitespace(c)) {
      this.state = 11;
      this.stateBeforeAttrName(c);
    }
  }
  stateInAttrName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    }
  }
  stateInDirName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 58) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else if (c === 46) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDirArg(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 91) {
      this.state = 15;
    } else if (c === 46) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDynamicDirArg(c) {
    if (c === 93) {
      this.state = 14;
    } else if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index + 1);
      this.handleAttrNameEnd(c);
    }
  }
  stateInDirModifier(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 46) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.sectionStart = this.index + 1;
    }
  }
  handleAttrNameEnd(c) {
    this.sectionStart = this.index;
    this.state = 17;
    this.cbs.onattribnameend(this.index);
    this.stateAfterAttrName(c);
  }
  stateAfterAttrName(c) {
    if (c === 61) {
      this.state = 18;
    } else if (c === 47 || c === 62) {
      this.cbs.onattribend(0, this.sectionStart);
      this.sectionStart = -1;
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(0, this.sectionStart);
      this.handleAttrStart(c);
    }
  }
  stateBeforeAttrValue(c) {
    if (c === 34) {
      this.state = 19;
      this.sectionStart = this.index + 1;
    } else if (c === 39) {
      this.state = 20;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = 21;
      this.stateInAttrValueNoQuotes(c);
    }
  }
  handleInAttrValue(c, quote) {
    if (c === quote || this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(
        quote === 34 ? 3 : 2,
        this.index + 1
      );
      this.state = 11;
    }
  }
  stateInAttrValueDoubleQuotes(c) {
    this.handleInAttrValue(c, 34);
  }
  stateInAttrValueSingleQuotes(c) {
    this.handleInAttrValue(c, 39);
  }
  stateInAttrValueNoQuotes(c) {
    if (isWhitespace(c) || c === 62) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(1, this.index);
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (c === 39 || c === 60 || c === 61 || c === 96) {
      this.cbs.onerr(
        18,
        this.index
      );
    } else
      ;
  }
  stateBeforeDeclaration(c) {
    if (c === 91) {
      this.state = 26;
      this.sequenceIndex = 0;
    } else {
      this.state = c === 45 ? 25 : 23;
    }
  }
  stateInDeclaration(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === 45) {
      this.state = 28;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 23;
    }
  }
  stateInSpecialComment(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.oncomment(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    if (c === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (c === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  stateBeforeSpecialT(c) {
    if (c === Sequences.TitleEnd[3]) {
      this.startSpecial(Sequences.TitleEnd, 4);
    } else if (c === Sequences.TextareaEnd[3]) {
      this.startSpecial(Sequences.TextareaEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  startEntity() {
  }
  stateInEntity() {
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse(input) {
    this.buffer = input;
    while (this.index < this.buffer.length) {
      const c = this.buffer.charCodeAt(this.index);
      if (c === 10 && this.state !== 33) {
        this.newlines.push(this.index);
      }
      switch (this.state) {
        case 1: {
          this.stateText(c);
          break;
        }
        case 2: {
          this.stateInterpolationOpen(c);
          break;
        }
        case 3: {
          this.stateInterpolation(c);
          break;
        }
        case 4: {
          this.stateInterpolationClose(c);
          break;
        }
        case 31: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case 32: {
          this.stateInRCDATA(c);
          break;
        }
        case 26: {
          this.stateCDATASequence(c);
          break;
        }
        case 19: {
          this.stateInAttrValueDoubleQuotes(c);
          break;
        }
        case 12: {
          this.stateInAttrName(c);
          break;
        }
        case 13: {
          this.stateInDirName(c);
          break;
        }
        case 14: {
          this.stateInDirArg(c);
          break;
        }
        case 15: {
          this.stateInDynamicDirArg(c);
          break;
        }
        case 16: {
          this.stateInDirModifier(c);
          break;
        }
        case 28: {
          this.stateInCommentLike(c);
          break;
        }
        case 27: {
          this.stateInSpecialComment(c);
          break;
        }
        case 11: {
          this.stateBeforeAttrName(c);
          break;
        }
        case 6: {
          this.stateInTagName(c);
          break;
        }
        case 34: {
          this.stateInSFCRootTagName(c);
          break;
        }
        case 9: {
          this.stateInClosingTagName(c);
          break;
        }
        case 5: {
          this.stateBeforeTagName(c);
          break;
        }
        case 17: {
          this.stateAfterAttrName(c);
          break;
        }
        case 20: {
          this.stateInAttrValueSingleQuotes(c);
          break;
        }
        case 18: {
          this.stateBeforeAttrValue(c);
          break;
        }
        case 8: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case 10: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case 29: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case 30: {
          this.stateBeforeSpecialT(c);
          break;
        }
        case 21: {
          this.stateInAttrValueNoQuotes(c);
          break;
        }
        case 7: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case 23: {
          this.stateInDeclaration(c);
          break;
        }
        case 22: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case 25: {
          this.stateBeforeComment(c);
          break;
        }
        case 24: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case 33: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
    this.finish();
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.sectionStart !== this.index) {
      if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === 19 || this.state === 20 || this.state === 21) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  finish() {
    this.handleTrailingData();
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === 28) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex);
      }
    } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9)
      ;
    else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
  }
}
function getCompatValue(key, { compatConfig }) {
  const value2 = compatConfig && compatConfig[key];
  if (key === "MODE") {
    return value2 || 3;
  } else {
    return value2;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value2 = getCompatValue(key, context);
  return mode === 3 ? value2 === true : value2 !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  return enabled;
}
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = `https://vuejs.org/error-reference/#compiler-${code}`;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
const isStaticExp = (p2) => p2.type === 4 && p2.isStatic;
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
const nonIdentifierRE = /^$|^\d|[^\$\w\xA0-\uFFFF]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
const getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
const isMemberExpressionBrowser = (exp) => {
  const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
  let state = 0;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i = 0; i < path.length; i++) {
    const char = path.charAt(i);
    switch (state) {
      case 0:
        if (char === "[") {
          stateStack.push(state);
          state = 1;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state);
          state = 2;
          currentOpenParensCount++;
        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 2:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i === path.length - 1) {
            return false;
          }
          if (!--currentOpenParensCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 3:
        if (char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpression = isMemberExpressionBrowser;
const fnExpRE = /^\s*(?:async\s*)?(?:\([^)]*?\)|[\w$_]+)\s*(?::[^=]+)?=>|^\s*(?:async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
const isFnExpression = isFnExpressionBrowser;
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 7 && (allowEmpty || p2.exp) && (isString(name) ? p2.name === name : name.test(p2.name))) {
      return p2;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 6) {
      if (dynamicOnly)
        continue;
      if (p2.name === name && (p2.value || allowEmpty)) {
        return p2;
      }
    } else if (p2.name === "bind" && (p2.exp || allowEmpty) && isStaticArgOf(p2.arg, name)) {
      return p2;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p2) => p2.type === 7 && p2.name === "bind" && (!p2.arg || // v-bind="obj"
    p2.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p2.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVPre(p2) {
  return p2.type === 7 && p2.name === "pre";
}
function isVSlot(p2) {
  return p2.type === 7 && p2.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p2) => p2.key.type === 4 && p2.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
const defaultParserOptions = {
  parseMode: "base",
  ns: 0,
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  isVoidTag: NO,
  isPreTag: NO,
  isIgnoreNewlineTag: NO,
  isCustomElement: NO,
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: false,
  prefixIdentifiers: false
};
let currentOptions = defaultParserOptions;
let currentRoot = null;
let currentInput = "";
let currentOpenTag = null;
let currentProp = null;
let currentAttrValue = "";
let currentAttrStartIndex = -1;
let currentAttrEndIndex = -1;
let inPre = 0;
let inVPre = false;
let currentVPreBoundary = null;
const stack = [];
const tokenizer = new Tokenizer(stack, {
  onerr: emitError,
  ontext(start, end) {
    onText(getSlice(start, end), start, end);
  },
  ontextentity(char, start, end) {
    onText(char, start, end);
  },
  oninterpolation(start, end) {
    if (inVPre) {
      return onText(getSlice(start, end), start, end);
    }
    let innerStart = start + tokenizer.delimiterOpen.length;
    let innerEnd = end - tokenizer.delimiterClose.length;
    while (isWhitespace(currentInput.charCodeAt(innerStart))) {
      innerStart++;
    }
    while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
      innerEnd--;
    }
    let exp = getSlice(innerStart, innerEnd);
    if (exp.includes("&")) {
      {
        exp = currentOptions.decodeEntities(exp, false);
      }
    }
    addNode({
      type: 5,
      content: createExp(exp, false, getLoc(innerStart, innerEnd)),
      loc: getLoc(start, end)
    });
  },
  onopentagname(start, end) {
    const name = getSlice(start, end);
    currentOpenTag = {
      type: 1,
      tag: name,
      ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
      tagType: 0,
      // will be refined on tag close
      props: [],
      children: [],
      loc: getLoc(start - 1, end),
      codegenNode: void 0
    };
  },
  onopentagend(end) {
    endOpenTag(end);
  },
  onclosetag(start, end) {
    const name = getSlice(start, end);
    if (!currentOptions.isVoidTag(name)) {
      let found = false;
      for (let i = 0; i < stack.length; i++) {
        const e = stack[i];
        if (e.tag.toLowerCase() === name.toLowerCase()) {
          found = true;
          if (i > 0) {
            emitError(24, stack[0].loc.start.offset);
          }
          for (let j = 0; j <= i; j++) {
            const el = stack.shift();
            onCloseTag(el, end, j < i);
          }
          break;
        }
      }
      if (!found) {
        emitError(23, backTrack(start, 60));
      }
    }
  },
  onselfclosingtag(end) {
    const name = currentOpenTag.tag;
    currentOpenTag.isSelfClosing = true;
    endOpenTag(end);
    if (stack[0] && stack[0].tag === name) {
      onCloseTag(stack.shift(), end);
    }
  },
  onattribname(start, end) {
    currentProp = {
      type: 6,
      name: getSlice(start, end),
      nameLoc: getLoc(start, end),
      value: void 0,
      loc: getLoc(start)
    };
  },
  ondirname(start, end) {
    const raw = getSlice(start, end);
    const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
    if (!inVPre && name === "") {
      emitError(26, start);
    }
    if (inVPre || name === "") {
      currentProp = {
        type: 6,
        name: raw,
        nameLoc: getLoc(start, end),
        value: void 0,
        loc: getLoc(start)
      };
    } else {
      currentProp = {
        type: 7,
        name,
        rawName: raw,
        exp: void 0,
        arg: void 0,
        modifiers: raw === "." ? [createSimpleExpression("prop")] : [],
        loc: getLoc(start)
      };
      if (name === "pre") {
        inVPre = tokenizer.inVPre = true;
        currentVPreBoundary = currentOpenTag;
        const props = currentOpenTag.props;
        for (let i = 0; i < props.length; i++) {
          if (props[i].type === 7) {
            props[i] = dirToAttr(props[i]);
          }
        }
      }
    }
  },
  ondirarg(start, end) {
    if (start === end)
      return;
    const arg = getSlice(start, end);
    if (inVPre && !isVPre(currentProp)) {
      currentProp.name += arg;
      setLocEnd(currentProp.nameLoc, end);
    } else {
      const isStatic = arg[0] !== `[`;
      currentProp.arg = createExp(
        isStatic ? arg : arg.slice(1, -1),
        isStatic,
        getLoc(start, end),
        isStatic ? 3 : 0
      );
    }
  },
  ondirmodifier(start, end) {
    const mod = getSlice(start, end);
    if (inVPre && !isVPre(currentProp)) {
      currentProp.name += "." + mod;
      setLocEnd(currentProp.nameLoc, end);
    } else if (currentProp.name === "slot") {
      const arg = currentProp.arg;
      if (arg) {
        arg.content += "." + mod;
        setLocEnd(arg.loc, end);
      }
    } else {
      const exp = createSimpleExpression(mod, true, getLoc(start, end));
      currentProp.modifiers.push(exp);
    }
  },
  onattribdata(start, end) {
    currentAttrValue += getSlice(start, end);
    if (currentAttrStartIndex < 0)
      currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribentity(char, start, end) {
    currentAttrValue += char;
    if (currentAttrStartIndex < 0)
      currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribnameend(end) {
    const start = currentProp.loc.start.offset;
    const name = getSlice(start, end);
    if (currentProp.type === 7) {
      currentProp.rawName = name;
    }
    if (currentOpenTag.props.some(
      (p2) => (p2.type === 7 ? p2.rawName : p2.name) === name
    )) {
      emitError(2, start);
    }
  },
  onattribend(quote, end) {
    if (currentOpenTag && currentProp) {
      setLocEnd(currentProp.loc, end);
      if (quote !== 0) {
        if (currentAttrValue.includes("&")) {
          currentAttrValue = currentOptions.decodeEntities(
            currentAttrValue,
            true
          );
        }
        if (currentProp.type === 6) {
          if (currentProp.name === "class") {
            currentAttrValue = condense(currentAttrValue).trim();
          }
          if (quote === 1 && !currentAttrValue) {
            emitError(13, end);
          }
          currentProp.value = {
            type: 2,
            content: currentAttrValue,
            loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
          };
          if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
            tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
          }
        } else {
          let expParseMode = 0;
          currentProp.exp = createExp(
            currentAttrValue,
            false,
            getLoc(currentAttrStartIndex, currentAttrEndIndex),
            0,
            expParseMode
          );
          if (currentProp.name === "for") {
            currentProp.forParseResult = parseForExpression(currentProp.exp);
          }
          let syncIndex = -1;
          if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex(
            (mod) => mod.content === "sync"
          )) > -1 && checkCompatEnabled(
            "COMPILER_V_BIND_SYNC",
            currentOptions,
            currentProp.loc,
            currentProp.arg.loc.source
          )) {
            currentProp.name = "model";
            currentProp.modifiers.splice(syncIndex, 1);
          }
        }
      }
      if (currentProp.type !== 7 || currentProp.name !== "pre") {
        currentOpenTag.props.push(currentProp);
      }
    }
    currentAttrValue = "";
    currentAttrStartIndex = currentAttrEndIndex = -1;
  },
  oncomment(start, end) {
    if (currentOptions.comments) {
      addNode({
        type: 3,
        content: getSlice(start, end),
        loc: getLoc(start - 4, end + 3)
      });
    }
  },
  onend() {
    const end = currentInput.length;
    for (let index = 0; index < stack.length; index++) {
      onCloseTag(stack[index], end - 1);
      emitError(24, stack[index].loc.start.offset);
    }
  },
  oncdata(start, end) {
    if (stack[0].ns !== 0) {
      onText(getSlice(start, end), start, end);
    } else {
      emitError(1, start - 9);
    }
  },
  onprocessinginstruction(start) {
    if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
      emitError(
        21,
        start - 1
      );
    }
  }
});
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content, offset, asParam = false) => {
    const start = loc.start.offset + offset;
    const end = start + content.length;
    return createExp(
      content,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 : 0
      /* Normal */
    );
  };
  const result = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content, start, end) {
  {
    const tag = stack[0] && stack[0].tag;
    if (tag !== "script" && tag !== "style" && content.includes("&")) {
      content = currentOptions.decodeEntities(content, false);
    }
  }
  const parent = stack[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if (lastNode && lastNode.type === 2) {
    lastNode.content += content;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, lookAhead(end, 62) + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = extend({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = extend({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns, children } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(children);
  }
  if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
    const first = children[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
  {
    const props = el.props;
    if (!tokenizer.inSFCRoot && isCompatEnabled(
      "COMPILER_NATIVE_TEMPLATE",
      currentOptions
    ) && el.tag === "template" && !isFragmentTemplate(el)) {
      const parent = stack[0] || currentRoot;
      const index = parent.children.indexOf(el);
      parent.children.splice(index, 1, ...el.children);
    }
    const inlineTemplateProp = props.find(
      (p2) => p2.type === 6 && p2.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      currentOptions,
      inlineTemplateProp.loc
    ) && el.children.length) {
      inlineTemplateProp.value = {
        type: 2,
        content: getSlice(
          el.children[0].loc.start.offset,
          el.children[el.children.length - 1].loc.end.offset
        ),
        loc: inlineTemplateProp.loc
      };
    }
  }
}
function lookAhead(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1)
    i++;
  return i;
}
function backTrack(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i >= 0)
    i--;
  return i;
}
const specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p2 = props[i];
    if (p2.type === 6) {
      if (p2.name === "is" && p2.value) {
        if (p2.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p2.loc
        )) {
          return true;
        }
      }
    } else if (
      // :is on plain element - only treat as component in compat mode
      p2.name === "bind" && isStaticArgOf(p2.arg, "is") && checkCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        currentOptions,
        p2.loc
      )
    ) {
      return true;
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
const windowsNewlineRE = /\r\n/g;
function condenseWhitespace(nodes) {
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node.content)) {
          const prev = nodes[i - 1] && nodes[i - 1].type;
          const next = nodes[i + 1] && nodes[i + 1].type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = condense(node.content);
        }
      } else {
        node.content = node.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node) {
  (stack[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function cloneLoc(loc) {
  return getLoc(loc.start.offset, loc.end.offset);
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0) {
  const exp = createSimpleExpression(content, isStatic, loc, constType);
  return exp;
}
function emitError(code, index, message) {
  currentOptions.onError(
    createCompilerError(code, getLoc(index, index))
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack.length = 0;
}
function baseParse(input, options) {
  reset();
  currentInput = input;
  currentOptions = extend({}, defaultParserOptions);
  if (options) {
    let key;
    for (key in options) {
      if (options[key] != null) {
        currentOptions[key] = options[key];
      }
    }
  }
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options && options.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root.loc = getLoc(0, input.length);
  root.children = condenseWhitespace(root.children);
  currentRoot = null;
  return root;
}
function cacheStatic(root, context) {
  walk(
    root,
    void 0,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    !!getSingleElementRoot(root)
  );
}
function getSingleElementRoot(root) {
  const children = root.children.filter((x) => x.type !== 3);
  return children.length === 1 && children[0].type === 1 && !isSlotOutlet(children[0]) ? children[0] : null;
}
function walk(node, parent, context, doNotHoistNode = false, inFor = false) {
  const { children } = node;
  const toCache = [];
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1;
          toCache.push(child);
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = codegenNode.patchFlag;
          if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType >= 2) {
        if (child.codegenNode.type === 14 && child.codegenNode.arguments.length > 0) {
          child.codegenNode.arguments.push(
            `-1`
          );
        }
        toCache.push(child);
        continue;
      }
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, node, context, false, inFor);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, node, context, child.children.length === 1, true);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          node,
          context,
          child.branches[i2].children.length === 1,
          inFor
        );
      }
    }
  }
  let cachedAsArray = false;
  if (toCache.length === children.length && node.type === 1) {
    if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
      node.codegenNode.children = getCacheExpression(
        createArrayExpression(node.codegenNode.children)
      );
      cachedAsArray = true;
    } else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !isArray(node.codegenNode.children) && node.codegenNode.children.type === 15) {
      const slot = getSlotNode(node.codegenNode, "default");
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    } else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
      const slotName = findDir(node, "slot", true);
      const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    }
  }
  if (!cachedAsArray) {
    for (const child of toCache) {
      child.codegenNode = context.cache(child.codegenNode);
    }
  }
  function getCacheExpression(value2) {
    const exp = context.cache(value2);
    exp.needArraySpread = true;
    return exp;
  }
  function getSlotNode(node2, name) {
    if (node2.children && !isArray(node2.children) && node2.children.type === 15) {
      const slot = node2.children.properties.find(
        (p2) => p2.key === name || p2.key.content === name
      );
      return slot && slot.value;
    }
  }
  if (toCache.length && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
        return 0;
      }
      if (codegenNode.patchFlag === void 0) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p2 = node.props[i];
            if (p2.type === 7 && p2.name === "bind" && p2.exp) {
              const expType = getConstantType(p2.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p2 = node.props[i];
            if (p2.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    case 20:
      return 2;
    default:
      return 0;
  }
}
const allowHoistedHelperSet = /* @__PURE__ */ new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value2, context) {
  if (value2.type === 14 && !isString(value2.callee) && allowHoistedHelperSet.has(value2.callee)) {
    const arg = value2.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value: value2 } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value2.type === 4) {
        valueType = getConstantType(value2, context);
      } else if (value2.type === 14) {
        valueType = getConstantTypeOfHelperCall(value2, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    filename,
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    cached: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: NOOP,
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp))
        exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode2 = false, inVOnce = false) {
      const cacheExp = createCacheExpression(
        context.cached.length,
        exp,
        isVNode2,
        inVOnce
      );
      context.cached.push(cacheExp);
      return cacheExp;
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    cacheStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  root.transformed = true;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const singleElementRootChild = getSingleElementRoot(root);
    if (singleElementRootChild && singleElementRootChild.codegenNode) {
      const codegenNode = singleElementRootChild.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = children[0];
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag,
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else
    ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child))
      continue;
    context.grandParent = context.parent;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches2 = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches2(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
const PURE_ANNOTATION = `/*@__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, newlineIndex = -2, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push(
      "\n" + `  `.repeat(n),
      0
      /* Start */
    );
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated)
    options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1
        /* End */
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(
      `
`,
      0
      /* Start */
    );
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(
        `const _Vue = ${VueBinding}
`,
        -1
        /* End */
      );
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(
          `const { ${staticHelpers} } = _Vue
`,
          -1
          /* End */
        );
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = `);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || false;
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(
        node,
        -3
        /* Unknown */
      );
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(
      node,
      -3
      /* Unknown */
    );
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), -3, node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(
    isStatic ? JSON.stringify(content) : content,
    -3,
    node
  );
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure)
    push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(
        child,
        -3
        /* Unknown */
      );
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, -2, node);
  } else {
    push(`[${node.content}]`, -3, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
    -3,
    node
  );
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2
  } = node;
  let patchFlagString;
  if (patchFlag) {
    {
      patchFlagString = String(patchFlag);
    }
  }
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, -2, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null)
      break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, -2, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, -2, node);
    return;
  }
  const multilines = properties.length > 1 || false;
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value: value2 } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value2, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, -2, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  const { needPauseTracking, needArraySpread } = node;
  if (needArraySpread) {
    push(`[...(`);
  }
  push(`_cache[${node.index}] || (`);
  if (needPauseTracking) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1`);
    if (node.inVOnce)
      push(`, true`);
    push(`),`);
    newline();
    push(`(`);
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (needPauseTracking) {
    push(`).cacheIndex = ${node.index},`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
  if (needArraySpread) {
    push(`)]`);
  }
}
new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
);
const transformIf = createStructuralDirectiveTransform(
  /^(?:if|else|else-if)$/,
  (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      const siblings = context.parent.children;
      let i = siblings.indexOf(ifNode);
      let key = 0;
      while (i-- >= 0) {
        const sibling = siblings[i];
        if (sibling && sibling.type === 9) {
          key += sibling.branches.length;
        }
      }
      return () => {
        if (isRoot) {
          ifNode.codegenNode = createCodegenNodeForBranch(
            branch,
            key,
            context
          );
        } else {
          const parentCondition = getParentCondition(ifNode.codegenNode);
          parentCondition.alternate = createCodegenNodeForBranch(
            branch,
            key + ifNode.branches.length - 1,
            context
          );
        }
      };
    });
  }
);
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: cloneLoc(node.loc),
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if ((dir.name === "else-if" || dir.name === "else") && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit)
          onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
        '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag,
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
const transformFor = createStructuralDirectiveTransform(
  "for",
  (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor(node, dir, context, (forNode) => {
      const renderExp = createCallExpression(helper(RENDER_LIST), [
        forNode.source
      ]);
      const isTemplate = isTemplateNode(node);
      const memo = findDir(node, "memo");
      const keyProp = findProp(node, `key`, false, true);
      keyProp && keyProp.type === 7;
      let keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
      const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
      const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
      const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
      forNode.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        void 0,
        renderExp,
        fragmentFlag,
        void 0,
        void 0,
        true,
        !isStableFragment,
        false,
        node.loc
      );
      return () => {
        let childBlock;
        const { children } = forNode;
        const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
        const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
        if (slotOutlet) {
          childBlock = slotOutlet.codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
        } else if (needFragmentWrapper) {
          childBlock = createVNodeCall(
            context,
            helper(FRAGMENT),
            keyProperty ? createObjectExpression([keyProperty]) : void 0,
            node.children,
            64,
            void 0,
            void 0,
            true,
            void 0,
            false
          );
        } else {
          childBlock = children[0].codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
          if (childBlock.isBlock !== !isStableFragment) {
            if (childBlock.isBlock) {
              removeHelper(OPEN_BLOCK);
              removeHelper(
                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
              );
            } else {
              removeHelper(
                getVNodeHelper(context.inSSR, childBlock.isComponent)
              );
            }
          }
          childBlock.isBlock = !isStableFragment;
          if (childBlock.isBlock) {
            helper(OPEN_BLOCK);
            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        if (memo) {
          const loop = createFunctionExpression(
            createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ])
          );
          loop.body = createBlockStatement([
            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
            createCompoundExpression([
              `if (_cached`,
              ...keyExp ? [` && _cached.key === `, keyExp] : [],
              ` && ${context.helperString(
                IS_MEMO_SAME
              )}(_cached, _memo)) return _cached`
            ]),
            createCompoundExpression([`const _item = `, childBlock]),
            createSimpleExpression(`_item.memo = _memo`),
            createSimpleExpression(`return _item`)
          ]);
          renderExp.arguments.push(
            loop,
            createSimpleExpression(`_cache`),
            createSimpleExpression(String(context.cached.length))
          );
          context.cached.push(null);
        } else {
          renderExp.arguments.push(
            createFunctionExpression(
              createForLoopParams(forNode.parseResult),
              childBlock,
              true
            )
          );
        }
      };
    });
  }
);
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult);
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value: value2, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value2,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit)
      onExit();
  };
}
function finalizeForParseResult(result, context) {
  if (result.finalized)
    return;
  result.finalized = true;
}
function createForLoopParams({ value: value2, key, index }, memoArgs = []) {
  return createParamsList([value2, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i])
      break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
const defaultFallback = createSimpleExpression(`undefined`, false);
const trackSlotScopes = (node, context) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir(node, "slot");
    if (vSlot) {
      vSlot.exp;
      context.scopes.vSlot++;
      return () => {
        context.scopes.vSlot--;
      };
    }
  }
};
const buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
  props,
  children,
  false,
  true,
  children.length ? children[0].loc : loc
);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(?:-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3 && isNonWhitespaceContent(prev)) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, /^(?:else-)?if$/)) {
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult);
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + ``,
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
const directiveImportMap = /* @__PURE__ */ new WeakMap();
const transformElement = (node, context) => {
  return function postTransformElement() {
    node = context.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const { tag, props } = node;
    const isComponent2 = node.tagType === 1;
    let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
    const isDynamicComponent = isObject$1(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock = (
      // dynamic component may resolve to plain elements
      isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
      // updates inside get proper isSVG flag at runtime. (#639, #643)
      // This is technically web-specific, but splitting the logic out of core
      // leads to too much unnecessary complexity.
      (tag === "svg" || tag === "foreignObject" || tag === "math")
    );
    if (props.length > 0) {
      const propsBuildResult = buildProps(
        node,
        context,
        void 0,
        isComponent2,
        isDynamicComponent
      );
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(
        directives.map((dir) => buildDirectiveArgs(dir, context))
      ) : void 0;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
      }
      const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
      vnodeTag !== TELEPORT && // explained above.
      vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type = child.type;
        const hasDynamicTextChild = type === 5 || type === 8;
        if (hasDynamicTextChild && getConstantType(child, context) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (dynamicPropNames && dynamicPropNames.length) {
      vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
    }
    node.codegenNode = createVNodeCall(
      context,
      vnodeTag,
      vnodeProps,
      vnodeChildren,
      patchFlag === 0 ? void 0 : patchFlag,
      vnodeDynamicProps,
      vnodeDirectives,
      !!shouldUseBlock,
      false,
      isComponent2,
      node.loc
    );
  };
};
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(
    node,
    "is",
    false,
    true
    /* allow empty */
  );
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      let exp;
      if (isProp.type === 6) {
        exp = isProp.value && createSimpleExpression(isProp.value.content, true);
      } else {
        exp = isProp.exp;
        if (!exp) {
          exp = createSimpleExpression(`is`, false, isProp.arg.loc);
        }
      }
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg)
      mergeArgs.push(arg);
  };
  const pushRefVForMarker = () => {
    if (context.scopes.vFor > 0) {
      properties.push(
        createObjectProperty(
          createSimpleExpression("ref_for", true),
          createSimpleExpression("true")
        )
      );
    }
  };
  const analyzePatchFlag = ({ key, value: value2 }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value2.type === 14) {
        value2 = value2.arguments[0];
      }
      if (value2.type === 20 || (value2.type === 4 || value2.type === 8) && getConstantType(value2, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, nameLoc, value: value2 } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        pushRefVForMarker();
      }
      if (name === "is" && (isComponentTag(tag) || value2 && value2.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name, true, nameLoc),
          createSimpleExpression(
            value2 ? value2.content : "",
            isStatic,
            value2 ? value2.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc, modifiers } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref")) {
        pushRefVForMarker();
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            {
              pushMergeArg();
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            pushRefVForMarker();
            pushMergeArg();
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent2 ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.some((mod) => mod.content === "prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
const transformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const { children, loc } = node;
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const slotArgs = [
      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      "{}",
      "undefined",
      "true"
    ];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(
      context.helper(RENDER_SLOT),
      slotArgs,
      loc
    );
  }
};
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 6) {
      if (p2.value) {
        if (p2.name === "name") {
          slotName = JSON.stringify(p2.value.content);
        } else {
          p2.name = camelize(p2.name);
          nonNameProps.push(p2);
        }
      }
    } else {
      if (p2.name === "bind" && isStaticArgOf(p2.arg, "name")) {
        if (p2.exp) {
          slotName = p2.exp;
        } else if (p2.arg && p2.arg.type === 4) {
          const name = camelize(p2.arg.content);
          slotName = p2.exp = createSimpleExpression(name, false, p2.arg.loc);
        }
      } else {
        if (p2.name === "bind" && p2.arg && isStaticExp(p2.arg)) {
          p2.arg.content = camelize(p2.arg.content);
        }
        nonNameProps.push(p2);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}
const transformOn$1 = (dir, node, context, augmentor) => {
  const { loc, modifiers, arg } = dir;
  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        toHandlerKey(camelize(rawName))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${rawName}`
      );
      eventName = createSimpleExpression(eventString, true, arg.loc);
    } else {
      eventName = createCompoundExpression([
        `${context.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = void 0;
  }
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression(exp);
    const isInlineStatement = !(isMemberExp || isFnExpression(exp));
    const hasMultipleStatements = exp.content.includes(`;`);
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([
        `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ]);
    }
  }
  let ret = {
    props: [
      createObjectProperty(
        eventName,
        exp || createSimpleExpression(`() => {}`, false, loc)
      )
    ]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context.cache(ret.props[0].value);
  }
  ret.props.forEach((p2) => p2.key.isHandlerKey = true);
  return ret;
};
const transformBind = (dir, _node, context) => {
  const { modifiers, loc } = dir;
  const arg = dir.arg;
  let { exp } = dir;
  if (exp && exp.type === 4 && !exp.content.trim()) {
    {
      exp = void 0;
    }
  }
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = arg.content ? `${arg.content} || ""` : `""`;
  }
  if (modifiers.some((mod) => mod.content === "camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = camelize(arg.content);
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context.inSSR) {
    if (modifiers.some((mod) => mod.content === "prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers.some((mod) => mod.content === "attr")) {
      injectPrefix(arg, "^");
    }
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
const injectPrefix = (arg, prefix) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`);
    arg.children.push(`)`);
  }
};
const transformText = (node, context) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = void 0;
      let hasText = false;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child)) {
          hasText = true;
          for (let j = i + 1; j < children.length; j++) {
            const next = children[j];
            if (isText$1(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = createCompoundExpression(
                  [child],
                  child.loc
                );
              }
              currentContainer.children.push(` + `, next);
              children.splice(j, 1);
              j--;
            } else {
              currentContainer = void 0;
              break;
            }
          }
        }
      }
      if (!hasText || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !node.props.find(
        (p2) => p2.type === 7 && !context.directiveTransforms[p2.name]
      ) && // in compat mode, <template> tags with no special directives
      // will be rendered as a fragment so its children must be
      // converted into vnodes.
      !(node.tag === "template"))) {
        return;
      }
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context.ssr && getConstantType(child, context) === 0) {
            callArgs.push(
              `1`
            );
          }
          children[i] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(
              context.helper(CREATE_TEXT),
              callArgs
            )
          };
        }
      }
    };
  }
};
const seen$1 = /* @__PURE__ */ new WeakSet();
const transformOnce = (node, context) => {
  if (node.type === 1 && findDir(node, "once", true)) {
    if (seen$1.has(node) || context.inVOnce || context.inSSR) {
      return;
    }
    seen$1.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(
          cur.codegenNode,
          true,
          true
        );
      }
    };
  }
};
const transformModel$1 = (dir, node, context) => {
  const { exp, arg } = dir;
  if (!exp) {
    context.onError(
      createCompilerError(41, dir.loc)
    );
    return createTransformProps();
  }
  const rawExp = exp.loc.source.trim();
  const expString = exp.type === 4 ? exp.content : rawExp;
  const bindingType = context.bindingMetadata[rawExp];
  if (bindingType === "props" || bindingType === "props-aliased") {
    context.onError(createCompilerError(44, exp.loc));
    return createTransformProps();
  }
  if (!expString.trim() || !isMemberExpression(exp) && true) {
    context.onError(
      createCompilerError(42, exp.loc)
    );
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context.isTS ? `($event: any)` : `$event`;
  {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ]);
  }
  const props = [
    // modelValue: foo
    createObjectProperty(propName, dir.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    createObjectProperty(eventName, assignmentExp)
  ];
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props.push(
      createObjectProperty(
        modifiersKey,
        createSimpleExpression(
          `{ ${modifiers} }`,
          false,
          dir.loc,
          2
        )
      )
    );
  }
  return createTransformProps(props);
};
function createTransformProps(props = []) {
  return { props };
}
const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
  if (!isCompatEnabled("COMPILER_FILTERS", context)) {
    return;
  }
  if (node.type === 5) {
    rewriteFilter(node.content, context);
  } else if (node.type === 1) {
    node.props.forEach((prop) => {
      if (prop.type === 7 && prop.name !== "for" && prop.exp) {
        rewriteFilter(prop.exp, context);
      }
    });
  }
};
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object")
        continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92)
        inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92)
        inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92)
        inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92)
        inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p2;
        for (; j >= 0; j--) {
          p2 = exp.charAt(j);
          if (p2 !== " ")
            break;
        }
        if (!p2 || !validDivisionCharRE.test(p2)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
    node.ast = void 0;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
const seen = /* @__PURE__ */ new WeakSet();
const transformMemo = (node, context) => {
  if (node.type === 1) {
    const dir = findDir(node, "memo");
    if (!dir || seen.has(node) || context.inSSR) {
      return;
    }
    seen.add(node);
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          convertToBlock(codegenNode, context);
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(void 0, codegenNode),
          `_cache`,
          String(context.cached.length)
        ]);
        context.cached.push(null);
      }
    };
  }
};
const transformVBindShorthand = (node, context) => {
  if (node.type === 1) {
    for (const prop of node.props) {
      if (prop.type === 7 && prop.name === "bind" && !prop.exp) {
        const arg = prop.arg;
        if (arg.type !== 4 || !arg.isStatic) {
          context.onError(
            createCompilerError(
              52,
              arg.loc
            )
          );
          prop.exp = createSimpleExpression("", true, arg.loc);
        } else {
          const propName = camelize(arg.content);
          if (validFirstIdentCharRE.test(propName[0]) || // allow hyphen first char for https://github.com/vuejs/language-tools/pull/3424
          propName[0] === "-") {
            prop.exp = createSimpleExpression(propName, false, arg.loc);
          }
        }
      }
    }
  }
};
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformVBindShorthand,
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...[],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn$1,
      bind: transformBind,
      model: transformModel$1
    }
  ];
}
function baseCompile(source, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const resolvedOptions = extend({}, options, {
    prefixIdentifiers
  });
  const ast = isString(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ast, resolvedOptions);
}
const noopDirectiveTransform = () => ({ props: [] });
/**
* @vue/compiler-dom v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const V_MODEL_RADIO = Symbol(``);
const V_MODEL_CHECKBOX = Symbol(
  ``
);
const V_MODEL_TEXT = Symbol(``);
const V_MODEL_SELECT = Symbol(
  ``
);
const V_MODEL_DYNAMIC = Symbol(
  ``
);
const V_ON_WITH_MODIFIERS = Symbol(
  ``
);
const V_ON_WITH_KEYS = Symbol(
  ``
);
const V_SHOW = Symbol(``);
const TRANSITION = Symbol(``);
const TRANSITION_GROUP = Symbol(
  ``
);
registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});
let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
const parserOptions = {
  parseMode: "html",
  isVoidTag,
  isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
  isPreTag: (tag) => tag === "pre",
  isIgnoreNewlineTag: (tag) => tag === "pre" || tag === "textarea",
  decodeEntities: decodeHtmlBrowser,
  isBuiltInComponent: (tag) => {
    if (tag === "Transition" || tag === "transition") {
      return TRANSITION;
    } else if (tag === "TransitionGroup" || tag === "transition-group") {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent, rootNamespace) {
    let ns = parent ? parent.ns : rootNamespace;
    if (parent && ns === 2) {
      if (parent.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent.props.some(
          (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
        )) {
          ns = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns = 0;
      }
    } else if (parent && ns === 1) {
      if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
        ns = 0;
      }
    }
    if (ns === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns;
  }
};
const transformStyle = (node) => {
  if (node.type === 1) {
    node.props.forEach((p2, i) => {
      if (p2.type === 6 && p2.name === "style" && p2.value) {
        node.props[i] = {
          type: 7,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p2.loc),
          exp: parseInlineCSS(p2.value.content, p2.loc),
          modifiers: [],
          loc: p2.loc
        };
      }
    });
  }
};
const parseInlineCSS = (cssText, loc) => {
  const normalized = parseStringStyle(cssText);
  return createSimpleExpression(
    JSON.stringify(normalized),
    false,
    loc,
    3
  );
};
function createDOMCompilerError(code, loc) {
  return createCompilerError(
    code,
    loc
  );
}
const transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(53, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(54, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`innerHTML`, true, loc),
        exp || createSimpleExpression("", true)
      )
    ]
  };
};
const transformVText = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(55, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(56, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`textContent`, true),
        exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
          context.helperString(TO_DISPLAY_STRING),
          [exp],
          loc
        ) : createSimpleExpression("", true)
      )
    ]
  };
};
const transformModel = (dir, node, context) => {
  const baseResult = transformModel$1(dir, node, context);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context.onError(
      createDOMCompilerError(
        58,
        dir.arg.loc
      )
    );
  }
  const { tag } = node;
  const isCustomElement = context.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type = findProp(node, `type`);
      if (type) {
        if (type.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context.onError(
                createDOMCompilerError(
                  59,
                  dir.loc
                )
              );
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else
        ;
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else
      ;
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(
      createDOMCompilerError(
        57,
        dir.loc
      )
    );
  }
  baseResult.props = baseResult.props.filter(
    (p2) => !(p2.key.type === 4 && p2.key.content === "modelValue")
  );
  return baseResult;
};
const isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
const isNonKeyModifier = /* @__PURE__ */ makeMap(
  // event propagation management
  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
);
const maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
const isKeyboardEvent = /* @__PURE__ */ makeMap(`onkeyup,onkeydown,onkeypress`);
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i = 0; i < modifiers.length; i++) {
    const modifier = modifiers[i].content;
    if (modifier === "native" && checkCompatEnabled(
      "COMPILER_V_ON_NATIVE",
      context
    )) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      if (maybeKeyModifier(modifier)) {
        if (isStaticExp(key)) {
          if (isKeyboardEvent(key.content.toLowerCase())) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
const transformClick = (key, event) => {
  const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
  return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
    `(`,
    key,
    `) === "onClick" ? "${event}" : (`,
    key,
    `)`
  ]) : key;
};
const transformOn = (dir, node, context) => {
  return transformOn$1(dir, node, context, (baseResult) => {
    const { modifiers } = dir;
    if (!modifiers.length)
      return baseResult;
    let { key, value: handlerExp } = baseResult.props[0];
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key = transformClick(key, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key = transformClick(key, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ]);
    }
    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
    (!isStaticExp(key) || isKeyboardEvent(key.content.toLowerCase()))) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
      key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [createObjectProperty(key, handlerExp)]
    };
  });
};
const transformShow = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(61, loc)
    );
  }
  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};
const ignoreSideEffectTags = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
    context.removeNode();
  }
};
const DOMNodeTransforms = [
  transformStyle,
  ...[]
];
const DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  // override compiler-core
  on: transformOn,
  // override compiler-core
  show: transformShow
};
function compile(src, options = {}) {
  return baseCompile(
    src,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
/**
* vue v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const compileCache = /* @__PURE__ */ Object.create(null);
function compileToFunction(template, options) {
  if (!isString(template)) {
    if (template.nodeType) {
      template = template.innerHTML;
    } else {
      return NOOP;
    }
  }
  const key = genCacheKey(template, options);
  const cached = compileCache[key];
  if (cached) {
    return cached;
  }
  if (template[0] === "#") {
    const el = document.querySelector(template);
    template = el ? el.innerHTML : ``;
  }
  const opts = extend(
    {
      hoistStatic: true,
      onError: void 0,
      onWarn: NOOP
    },
    options
  );
  if (!opts.isCustomElement && typeof customElements !== "undefined") {
    opts.isCustomElement = (tag) => !!customElements.get(tag);
  }
  const { code } = compile(template, opts);
  const render2 = new Function("Vue", code)(runtimeDom);
  render2._rc = true;
  return compileCache[key] = render2;
}
registerRuntimeCompiler(compileToFunction);
function generateUUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function getOrCreateUserUUID() {
  const STORAGE_KEY = "__ABOT_PLUGIN_USERNAME__";
  try {
    let uuid = localStorage.getItem(STORAGE_KEY);
    if (uuid) {
      console.log("📝 找到现有用户UUID:", uuid);
      return uuid;
    }
    uuid = generateUUID();
    console.log("🆕 创建新用户UUID:", uuid);
    localStorage.setItem(STORAGE_KEY, uuid);
    console.log("💾 用户UUID已保存到localStorage");
    return uuid;
  } catch (error) {
    console.warn("❌ localStorage访问失败，使用临时UUID:", error.message);
    return "temp_" + generateUUID();
  }
}
/*!
 * pinia v3.0.4
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = (pinia) => activePinia = pinia;
const piniaSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app) {
      setActivePinia(pinia);
      pinia._a = app;
      app.provide(piniaSymbol, pinia);
      app.config.globalProperties.$pinia = pinia;
      toBeInstalled.forEach((plugin) => _p.push(plugin));
      toBeInstalled = [];
    },
    use(plugin) {
      if (!this._a) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia;
}
const noop = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
  subscriptions.add(callback);
  const removeSubscription = () => {
    const isDel = subscriptions.delete(callback);
    isDel && onCleanup();
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn) => fn();
const ACTION_MARKER = Symbol();
const ACTION_NAME = Symbol();
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value2, key) => target.set(key, value2));
  } else if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function shouldHydrate(obj) {
  return !isPlainObject(obj) || !Object.prototype.hasOwnProperty.call(obj, skipHydrateSymbol);
}
const { assign } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore(id, options, pinia, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia.state.value[id];
  let store;
  function setup() {
    if (!initialState && true) {
      pinia.state.value[id] = state ? state() : {};
    }
    const localState = toRefs(pinia.state.value[id]);
    return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia);
        const store2 = pinia._s.get(id);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id, setup, options, pinia, hot, true);
  return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign({ actions: {} }, options);
  const $subscribeOptions = { deep: true };
  let isListening;
  let isSyncListening;
  let subscriptions = /* @__PURE__ */ new Set();
  let actionSubscriptions = /* @__PURE__ */ new Set();
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    pinia.state.value[$id] = {};
  }
  ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick$1().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign($state, newState);
    });
  } : (
    /* istanbul ignore next */
    noop
  );
  function $dispose() {
    scope.stop();
    subscriptions.clear();
    actionSubscriptions.clear();
    pinia._s.delete($id);
  }
  const action = (fn, name = "") => {
    if (ACTION_MARKER in fn) {
      fn[ACTION_NAME] = name;
      return fn;
    }
    const wrappedAction = function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const afterCallbackSet = /* @__PURE__ */ new Set();
      const onErrorCallbackSet = /* @__PURE__ */ new Set();
      function after(callback) {
        afterCallbackSet.add(callback);
      }
      function onError(callback) {
        onErrorCallbackSet.add(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name: wrappedAction[ACTION_NAME],
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = fn.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackSet, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value2) => {
          triggerSubscriptions(afterCallbackSet, value2);
          return value2;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackSet, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackSet, ret);
      return ret;
    };
    wrappedAction[ACTION_MARKER] = true;
    wrappedAction[ACTION_NAME] = name;
    return wrappedAction;
  };
  const partialStore = {
    _p: pinia,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(partialStore);
  pinia._s.set($id, store);
  const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        pinia.state.value[$id][key] = prop;
      }
    } else if (typeof prop === "function") {
      const actionValue = action(prop, key);
      setupStore[key] = actionValue;
      optionsForPlugin.actions[key] = prop;
    } else
      ;
  }
  assign(store, setupStore);
  assign(toRaw(store), setupStore);
  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign($state, state);
      });
    }
  });
  pinia._p.forEach((extender) => {
    {
      assign(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineStore(id, setup, setupOptions) {
  let options;
  const isSetupStore = typeof setup === "function";
  options = isSetupStore ? setupOptions : setup;
  function useStore(pinia, hot) {
    const hasContext = hasInjectionContext();
    pinia = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    pinia || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia)
      setActivePinia(pinia);
    pinia = activePinia;
    if (!pinia._s.has(id)) {
      if (isSetupStore) {
        createSetupStore(id, setup, options, pinia);
      } else {
        createOptionsStore(id, options, pinia);
      }
    }
    const store = pinia._s.get(id);
    return store;
  }
  useStore.$id = id;
  return useStore;
}
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$g = {};
const _hoisted_1$e = {
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function _sfc_render$f(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$e, [..._cache[0] || (_cache[0] = [
    createBaseVNode("path", {
      d: "M8.23567 3.18842L3.28591 8.13818C2.11433 9.30975 2.11433 11.2092 3.28591 12.3808C4.45747 13.5524 6.35697 13.5524 7.52854 12.3808L13.4211 6.48825C14.2021 5.70722 14.2021 4.44088 13.4211 3.65982C12.6401 2.87878 11.3737 2.87878 10.5927 3.65982L4.70014 9.55238C4.3096 9.94292 4.3096 10.5761 4.70014 10.9666C5.09064 11.3571 5.7238 11.3571 6.11434 10.9666L11.0641 6.01685",
      stroke: "#696D69",
      "stroke-width": "1.4",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, -1)
  ])]);
}
const AttachIcon = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$f]]);
const _sfc_main$f = {};
const _hoisted_1$d = {
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function _sfc_render$e(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$d, [..._cache[0] || (_cache[0] = [
    createStaticVNode('<g clip-path="url(#clip0_2881_2325)"><path d="M8.00016 14.6666C11.6821 14.6666 14.6668 11.6819 14.6668 7.99998C14.6668 4.31808 11.6821 1.33331 8.00016 1.33331C4.31826 1.33331 1.3335 4.31808 1.3335 7.99998C1.3335 11.6819 4.31826 14.6666 8.00016 14.6666Z" stroke="#696D69" stroke-width="1.4" stroke-linejoin="round"></path><path d="M10.3332 10.3333C10.3332 10.3333 9.6665 11.6666 7.99984 11.6666C6.33317 11.6666 5.6665 10.3333 5.6665 10.3333" stroke="#696D69" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"></path><path d="M10.3335 6V7.33333" stroke="#696D69" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"></path><path d="M5.6665 6V7.33333" stroke="#696D69" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"></path></g><defs><clipPath id="clip0_2881_2325"><rect width="16" height="16" fill="white"></rect></clipPath></defs>', 2)
  ])]);
}
const EmotionIcon = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$e]]);
const _sfc_main$e = {};
const _hoisted_1$c = {
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function _sfc_render$d(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$c, [..._cache[0] || (_cache[0] = [
    createBaseVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M1.6665 3.33335C1.6665 2.96516 1.96498 2.66669 2.33317 2.66669H13.6665C14.0347 2.66669 14.3332 2.96516 14.3332 3.33335V12.6667C14.3332 13.0349 14.0347 13.3334 13.6665 13.3334H2.33317C1.96498 13.3334 1.6665 13.0349 1.6665 12.6667V3.33335Z",
      stroke: "#696D69",
      "stroke-width": "1.4",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, -1),
    createBaseVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M4.8335 6C5.10963 6 5.3335 5.77613 5.3335 5.5C5.3335 5.22387 5.10963 5 4.8335 5C4.55736 5 4.3335 5.22387 4.3335 5.5C4.3335 5.77613 4.55736 6 4.8335 6Z",
      stroke: "#696D69",
      "stroke-width": "1.4",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, -1),
    createBaseVNode("path", {
      d: "M4.99984 8L6.6665 9.33333L8.6665 7L14.3332 11.3333V12.6667C14.3332 13.0349 14.0347 13.3333 13.6665 13.3333H2.33317C1.96498 13.3333 1.6665 13.0349 1.6665 12.6667V11.3333L4.99984 8Z",
      stroke: "#696D69",
      "stroke-width": "1.4",
      "stroke-linejoin": "round"
    }, null, -1)
  ])]);
}
const ImageIcon = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$d]]);
const _sfc_main$d = {};
const _hoisted_1$b = {
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function _sfc_render$c(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$b, [..._cache[0] || (_cache[0] = [
    createBaseVNode("path", {
      d: "M9.2 6.19995V3.79995C9.2 2.80583 8.39413 1.99994 7.4 1.99994L5 7.39995V13.9999H11.972C12.5704 14.0067 13.0823 13.5716 13.172 12.9799L14 7.57995C14.0528 7.23185 13.9501 6.87812 13.7191 6.61245C13.4881 6.34678 13.1521 6.19595 12.8 6.19995H9.2Z",
      stroke: "#696D69",
      "stroke-width": "1.4",
      "stroke-linejoin": "round"
    }, null, -1),
    createBaseVNode("path", {
      d: "M5 7.33339H3.398C2.69511 7.32095 2.09423 7.90319 2 8.59982V12.7998C2.09423 13.4965 2.69511 14.0123 3.398 13.9998H5V7.33339Z",
      stroke: "#696D69",
      "stroke-width": "1.4",
      "stroke-linejoin": "round"
    }, null, -1)
  ])]);
}
const SubscribeIcon = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$c]]);
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  name: "SmallIconButton",
  props: {
    name: {
      type: String,
      default: "emotion"
    },
    onClick: {
      type: Function,
      default: () => {
      }
    }
  },
  setup(props) {
    const getIcon = computed(() => {
      if (props.name === "emotion") {
        return EmotionIcon;
      } else if (props.name === "image") {
        return ImageIcon;
      } else if (props.name === "attach") {
        return AttachIcon;
      } else if (props.name === "subscribe") {
        return SubscribeIcon;
      }
      return EmotionIcon;
    });
    return { getIcon };
  }
});
const SmallIconButton_vue_vue_type_style_index_0_scoped_b6253ea0_lang = "";
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "small-icon-button",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.onClick())
  }, [
    (openBlock(), createBlock(resolveDynamicComponent(_ctx.getIcon)))
  ]);
}
const SmallIconButton = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$b], ["__scopeId", "data-v-b6253ea0"]]);
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  name: "ChatInputToolbar",
  components: { SmallIconButton },
  setup() {
    const handleEmotion = () => {
      console.log("click chat toolbar Button");
    };
    return { handleEmotion };
  }
});
const CustomerInputToolbar_vue_vue_type_style_index_0_scoped_e2e9113f_lang = "";
const _hoisted_1$a = { class: "chat-input-toolbar" };
const _hoisted_2$4 = { class: "chat-input-toolbar-left" };
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SmallIconButton = resolveComponent("SmallIconButton");
  return openBlock(), createElementBlock("div", _hoisted_1$a, [
    createBaseVNode("div", _hoisted_2$4, [
      createVNode(_component_SmallIconButton, {
        name: "emotion",
        onClick: _ctx.handleEmotion
      }, null, 8, ["onClick"]),
      createVNode(_component_SmallIconButton, {
        name: "image",
        onClick: _ctx.handleEmotion
      }, null, 8, ["onClick"]),
      createVNode(_component_SmallIconButton, {
        name: "attach",
        onClick: _ctx.handleEmotion
      }, null, 8, ["onClick"]),
      createVNode(_component_SmallIconButton, {
        name: "subscribe",
        onClick: _ctx.handleEmotion
      }, null, 8, ["onClick"])
    ])
  ]);
}
const CustomerInputToolbar = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$a], ["__scopeId", "data-v-e2e9113f"]]);
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  name: "PrimaryButton",
  props: {
    label: {
      type: String,
      default: "common.default.default"
    },
    fullWidth: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: "default"
    },
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    ghost: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    onClick: {
      type: Function,
      default: () => {
      }
    },
    forceColor: {
      type: String,
      default: void 0
    }
  },
  setup(props) {
    const handleClick = () => {
      if (!props.disabled)
        props.onClick();
    };
    return { handleClick };
  }
});
const PrimaryButton_vue_vue_type_style_index_0_scoped_b7664f0f_lang = "";
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["primary-button", { "full-width": _ctx.fullWidth, "ghost": _ctx.ghost, "error": _ctx.error, "disabled": _ctx.disabled || _ctx.loading, "big": _ctx.size === "big", "small": _ctx.size === "small" }]),
    style: normalizeStyle({ "background-color": _ctx.forceColor }),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    createBaseVNode("span", {
      class: normalizeClass(["w-400 s-14 primary-button-label", { "ghost": _ctx.ghost, "disabled": _ctx.disabled || _ctx.loading }])
    }, toDisplayString(_ctx.$t(_ctx.label)), 3)
  ], 6);
}
const PrimaryButton = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$9], ["__scopeId", "data-v-b7664f0f"]]);
function useLang() {
  const browserLanguage = ref("zh-CN");
  const getUCLang = () => {
    if (typeof navigator === "undefined") {
      return "zh-CN";
    }
    const lang = (navigator.language || navigator.userLanguage || navigator.browserLanguage || navigator.systemLanguage || "zh-CN").toLowerCase();
    if (lang.startsWith("zh")) {
      return lang.includes("tw") || lang.includes("hk") || lang.includes("mo") ? "zh-TW" : "zh-CN";
    } else if (lang.startsWith("en")) {
      return "en-US";
    } else {
      return "zh-CN";
    }
  };
  const setLanguage = (lang) => {
    browserLanguage.value = lang;
  };
  onMounted(() => {
    const currentLang = getUCLang();
    setLanguage(currentLang);
  });
  return {
    browserLanguage,
    getUCLang,
    setLanguage
  };
}
var MessageType = /* @__PURE__ */ ((MessageType2) => {
  MessageType2["QU"] = "queueUpdate";
  MessageType2["CC"] = "chatConnect";
  MessageType2["CD"] = "chatDisconnect";
  MessageType2["ET"] = "eventTerminate";
  MessageType2["TEXT"] = "text";
  MessageType2["BINARY"] = "binary";
  MessageType2["RECOM"] = "recommendations";
  return MessageType2;
})(MessageType || {});
var SenderType = /* @__PURE__ */ ((SenderType2) => {
  SenderType2["AGENT"] = "agent";
  SenderType2["CUSTOM"] = "custom";
  SenderType2["SYS"] = "system";
  return SenderType2;
})(SenderType || {});
var ChatStatus = /* @__PURE__ */ ((ChatStatus2) => {
  ChatStatus2[ChatStatus2["WAITING"] = 0] = "WAITING";
  ChatStatus2[ChatStatus2["ROBOT"] = 1] = "ROBOT";
  ChatStatus2[ChatStatus2["AGENT"] = 2] = "AGENT";
  ChatStatus2[ChatStatus2["TERMINATION"] = 3] = "TERMINATION";
  return ChatStatus2;
})(ChatStatus || {});
var SenderIdType = /* @__PURE__ */ ((SenderIdType2) => {
  SenderIdType2[SenderIdType2["SYS"] = -1] = "SYS";
  SenderIdType2[SenderIdType2["TO_AGENT"] = -2] = "TO_AGENT";
  SenderIdType2[SenderIdType2["TO_CUSTOM"] = -3] = "TO_CUSTOM";
  return SenderIdType2;
})(SenderIdType || {});
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob$1 && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
  lookup$1[chars.charCodeAt(i)] = i;
}
const decode$1 = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup$1[base64.charCodeAt(i)];
    encoded2 = lookup$1[base64.charCodeAt(i + 1)];
    encoded3 = lookup$1[base64.charCodeAt(i + 2)];
    encoded4 = lookup$1[base64.charCodeAt(i + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
const decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$1(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length = packets.length;
  const encodedPackets = new Array(length);
  let count = 0;
  packets.forEach((packet, i) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i = 0; i < encodedPackets.length; i++) {
    const decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer2 = new Uint8Array(size);
  let j = 0;
  for (let i = 0; i < size; i++) {
    buffer2[i] = chunks[0][j++];
    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }
  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }
  return buffer2;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n = view.getUint32(0);
          if (n > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks)
    return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
const globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
const defaultBinaryType = "arraybuffer";
function createCookieJar() {
}
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c = 0, length = 0;
  for (let i = 0, l = str.length; i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 128) {
      length += 1;
    } else if (c < 2048) {
      length += 2;
    } else if (c < 55296 || c >= 57344) {
      length += 3;
    } else {
      i++;
      length += 4;
    }
  }
  return length;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function encode(obj) {
  let str = "";
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
    }
  }
  return str;
}
function decode(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i = 0, l = pairs.length; i < l; i++) {
    let pair = pairs[i].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
class TransportError extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
    this.supportsBinary = !opts.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
}
class Polling extends Transport {
  constructor() {
    super(...arguments);
    this._polling = false;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this._polling || !this.writable) {
      let total = 0;
      if (this._polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this._polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this._poll();
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
let value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
const hasCORS = value;
function empty() {
}
class BaseXHR extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(createRequest, uri, opts) {
    super();
    this.createRequest = createRequest;
    installTimerFunctions(this, opts);
    this._opts = opts;
    this._method = opts.method || "GET";
    this._uri = uri;
    this._data = void 0 !== opts.data ? opts.data : null;
    this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var _a;
    const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this._opts.xd;
    const xhr = this._xhr = this.createRequest(opts);
    try {
      xhr.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i in this._opts.extraHeaders) {
            if (this._opts.extraHeaders.hasOwnProperty(i)) {
              xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this._method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this._opts.withCredentials;
      }
      if (this._opts.requestTimeout) {
        xhr.timeout = this._opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a2;
        if (xhr.readyState === 3) {
          (_a2 = this._opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie")
          );
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this._onLoad();
        } else {
          this.setTimeoutFn(() => {
            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this._data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this._onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this._index = Request.requestsCount++;
      Request.requests[this._index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(err) {
    this.emitReserved("error", err, this._xhr);
    this._cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(fromError) {
    if ("undefined" === typeof this._xhr || null === this._xhr) {
      return;
    }
    this._xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this._xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this._index];
    }
    this._xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const data = this._xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this._cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
const hasXHR2 = function() {
  const xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
}();
class XHR extends BaseXHR {
  constructor(opts) {
    super(opts);
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd }, this.opts);
    return new Request(newRequest, this.uri(), opts);
  }
}
function newRequest(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class BaseWS extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = this.createSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        try {
          this.doWrite(packet, data);
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.onerror = () => {
      };
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
class WS extends BaseWS {
  createSocket(uri, protocols, opts) {
    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
  }
  doWrite(_packet, data) {
    this.ws.send(data);
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this._writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this._writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      this._writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a;
    (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
};
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(str) {
  if (str.length > 8e3) {
    throw "URI too long";
  }
  const src = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i = 14;
  while (i--) {
    uri[parts[i]] = m[i] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
const withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
const OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  addEventListener("offline", () => {
    OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
  }, false);
}
class SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    this._prevBufferLen = 0;
    this._pingInterval = -1;
    this._pingTimeout = -1;
    this._maxPayload = -1;
    this._pingTimeoutTime = Infinity;
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      const parsedUri = parse(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query)
        opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = parse(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = [];
    this._transportsByName = {};
    opts.transports.forEach((t2) => {
      const transportName = t2.prototype.name;
      this.transports.push(transportName);
      this._transportsByName[transportName] = t2;
    });
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode(this.opts.query);
    }
    if (withEventListeners) {
      if (this.opts.closeOnBeforeunload) {
        this._beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this._beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this._offlineEventListener = () => {
          this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
      }
    }
    if (this.opts.withCredentials) {
      this._cookieJar = createCookieJar();
    }
    this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol$1;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new this._transportsByName[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const transport = this.createTransport(transportName);
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this._sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          this._resetPingTimeout();
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this._onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this._pingInterval = data.pingInterval;
    this._pingTimeout = data.pingTimeout;
    this._maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const delay = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + delay;
    this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, delay);
    if (this.opts.autoUnref) {
      this._pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen);
    this._prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this._getWritablePackets();
      this.transport.send(packets);
      this._prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const data = this.writeBuffer[i].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i > 0 && payloadSize > this._maxPayload) {
        return this.writeBuffer.slice(0, i);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return true;
    const hasExpired = Date.now() > this._pingTimeoutTime;
    if (hasExpired) {
      this._pingTimeoutTime = 0;
      nextTick(() => {
        this._onClose("ping timeout");
      }, this.setTimeoutFn);
    }
    return hasExpired;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(type, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this._onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(err) {
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
      this.transports.shift();
      return this._open();
    }
    this.emitReserved("error", err);
    this._onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (withEventListeners) {
        if (this._beforeunloadEventListener) {
          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
        }
        if (this._offlineEventListener) {
          const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
          if (i !== -1) {
            OFFLINE_EVENT_LISTENERS.splice(i, 1);
          }
        }
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this._prevBufferLen = 0;
    }
  }
}
SocketWithoutUpgrade.protocol = protocol$1;
class SocketWithUpgrade extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments);
    this._upgrades = [];
  }
  onOpen() {
    super.onOpen();
    if ("open" === this.readyState && this.opts.upgrade) {
      for (let i = 0; i < this._upgrades.length; i++) {
        this._probe(this._upgrades[i]);
      }
    }
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  onHandshake(data) {
    this._upgrades = this._filterUpgrades(data.upgrades);
    super.onHandshake(data);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    for (let i = 0; i < upgrades.length; i++) {
      if (~this.transports.indexOf(upgrades[i]))
        filteredUpgrades.push(upgrades[i]);
    }
    return filteredUpgrades;
  }
}
let Socket$1 = class Socket extends SocketWithUpgrade {
  constructor(uri, opts = {}) {
    const o = typeof uri === "object" ? uri : opts;
    if (!o.transports || o.transports && typeof o.transports[0] === "string") {
      o.transports = (o.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t2) => !!t2);
    }
    super(uri, o);
  }
};
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
const protocol = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer2) {
    this.replacer = replacer2;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i = 0;
    const p2 = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p2.type] === void 0) {
      throw new Error("unknown packet type " + p2.type);
    }
    if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
      const start = i + 1;
      while (str.charAt(++i) !== "-" && i != str.length) {
      }
      const buf = str.substring(start, i);
      if (buf != Number(buf) || str.charAt(i) !== "-") {
        throw new Error("Illegal attachments");
      }
      p2.attachments = Number(buf);
    }
    if ("/" === str.charAt(i + 1)) {
      const start = i + 1;
      while (++i) {
        const c = str.charAt(i);
        if ("," === c)
          break;
        if (i === str.length)
          break;
      }
      p2.nsp = str.substring(start, i);
    } else {
      p2.nsp = "/";
    }
    const next = str.charAt(i + 1);
    if ("" !== next && Number(next) == next) {
      const start = i + 1;
      while (++i) {
        const c = str.charAt(i);
        if (null == c || Number(c) != c) {
          --i;
          break;
        }
        if (i === str.length)
          break;
      }
      p2.id = Number(str.substring(start, i + 1));
    }
    if (str.charAt(++i)) {
      const payload = this.tryParse(str.substr(i));
      if (Decoder.isPayloadValid(p2.type, payload)) {
        p2.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p2;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket2 extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    var _a, _b, _c;
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
    const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
    const discardPacket = this.flags.volatile && !isTransportWritable;
    if (discardPacket)
      ;
    else if (isConnected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    var _a;
    const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i = 0; i < this.sendBuffer.length; i++) {
        if (this.sendBuffer[i].id === id) {
          this.sendBuffer.splice(i, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    const fn = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn.withError = true;
    this.acks[id] = fn;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve2, reject) => {
      const fn = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve2(arg2);
      };
      fn.withError = true;
      args.push(fn);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
      if (!isBuffered) {
        const ack = this.acks[id];
        delete this.acks[id];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
}
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
class Manager extends Emitter {
  constructor(uri, opts) {
    var _a;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    if (!v) {
      this.skipReconnect = true;
    }
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(
      on(socket, "ping", this.onping.bind(this)),
      on(socket, "data", this.ondata.bind(this)),
      on(socket, "error", this.onerror.bind(this)),
      on(socket, "close", this.onclose.bind(this)),
      // @ts-ignore
      on(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i = 0; i < encodedPackets.length; i++) {
      this.engine.write(encodedPackets[i], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(reason, description) {
    var _a;
    this.cleanup();
    (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
const cache = {};
function lookup(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup, {
  Manager,
  Socket: Socket2,
  io: lookup,
  connect: lookup
});
function useSocketIO(url2, options = {}) {
  const socket = ref(null);
  const isConnected = ref(false);
  const connect = () => {
    return new Promise((resolve2, reject) => {
      const urlObj = new URL(url2);
      const baseUrl = `${urlObj.protocol}//${urlObj.host}`;
      const path = urlObj.pathname;
      socket.value = lookup(baseUrl, {
        transports: ["websocket", "polling"],
        path,
        // 关键：设置自定义路径
        query: {
          token: urlObj.searchParams.get("token"),
          channelId: urlObj.searchParams.get("channelId")
        },
        ...options
      });
      socket.value.on("connect", () => {
        isConnected.value = true;
        console.log("Socket.IO 连接成功");
        resolve2();
      });
      socket.value.on("connect_error", (error) => {
        console.error("Socket.IO 连接失败:", error);
        reject(error);
      });
      socket.value.on("disconnect", () => {
        isConnected.value = false;
        console.log("Socket.IO 断开连接");
      });
    });
  };
  const emit2 = (event, data) => {
    if (socket.value && isConnected.value) {
      socket.value.emit(event, data);
    }
  };
  const on2 = (event, callback) => {
    var _a;
    (_a = socket.value) == null ? void 0 : _a.on(event, callback);
  };
  const off = (event) => {
    var _a;
    (_a = socket.value) == null ? void 0 : _a.off(event);
  };
  const disconnect = () => {
    if (socket.value) {
      socket.value.disconnect();
      socket.value = null;
      isConnected.value = false;
    }
  };
  onUnmounted(() => {
    disconnect();
  });
  return {
    connect,
    disconnect,
    emit: emit2,
    on: on2,
    off,
    isConnected
  };
}
const translations = {
  "en-US": {
    "session.chat.time": "{month}/{day} {hour}:{minute}",
    "session.chat.button.placeholder": "Please input ...",
    "session.chat.button.lineBreak": "Press Shift+Enter to line break",
    "common.send": "Save",
    "session.chat.down": " has closed connections",
    "session.chat.up": " is ready to serve you!",
    "chat.terminate": "Chat is terminated"
  },
  "zh-CN": {
    "session.chat.time": "{month}月{day}日 {hour}:{minute}",
    "session.chat.button.placeholder": "请输入消息...",
    "session.chat.button.lineBreak": "按Shift+Enter换行",
    "common.send": "发送",
    "session.chat.down": "已下线",
    "session.chat.up": "已准备为您服务！",
    "chat.terminate": "会话已关闭"
  },
  "zh-TW": {
    "session.chat.time": "{month}月{day}日 {hour}:{minute}",
    "session.chat.button.placeholder": "請輸入消息...",
    "session.chat.button.lineBreak": "按Shift+Enter換行",
    "common.send": "發送",
    "session.chat.down": "已下線",
    "session.chat.up": "已準備為您服務！",
    "chat.terminate": "会话已关闭"
  }
};
let currentLocale = "zh-CN";
const t = (key, params = {}) => {
  var _a;
  const text = ((_a = translations[currentLocale]) == null ? void 0 : _a[key]) || translations["zh-CN"][key] || key;
  return Object.entries(params).reduce((result, [k, v]) => {
    return result.replace(new RegExp(`{${k}}`, "g"), v);
  }, text);
};
const i18nPlugin = {
  install(app) {
    app.config.globalProperties.$t = t;
    app.provide("i18n", { t, locale: { value: currentLocale } });
  }
};
const useI18n = () => ({
  t,
  locale: { value: currentLocale }
});
const useChatStore = /* @__PURE__ */ defineStore("chat-store", () => {
  const state = reactive({
    chatId: "0",
    chatStatus: ChatStatus.TERMINATION,
    channelId: "0",
    currentAgent: "agent-0",
    chatInfo: [],
    sendDisable: true
  });
  const { t: t2 } = useI18n();
  const token = localStorage.getItem("__ABOT_ACCESS_TOKEN__");
  const channel = localStorage.getItem("__ABOT_CHANNEL__");
  const ws = useSocketIO(
    `http://localhost:9999/websocket/socket.io?token=${token}&channelId=${channel}`
    // `https://testwww.abot.pro/websocket/socket.io?token=${token}&channelId=${channel}`
  );
  const loadOldChat = (data) => {
    const oldChat = data.filter((i) => i.messageType !== MessageType.CC).map((r) => ({
      avatar: r.avatar,
      content: r.content,
      contentType: r.contentType,
      sequenceId: r.sequenceId,
      timestamp: r.timestamp,
      sender: r.senderType,
      username: r.senderName
    }));
    state.chatInfo.push(...oldChat.reverse());
  };
  const wsConnect = async () => {
    try {
      console.log("Socket开始连接...", state.channelId);
      await ws.connect();
      ws.on("message", (data) => {
        const sourceData = JSON.parse(data);
        console.log("收到源消息：");
        console.log(sourceData);
        if (sourceData.messageType === MessageType.CC) {
          state.chatId = sourceData.chatId;
          state.chatStatus = 2;
          state.currentAgent = sourceData.content.split("-")[1];
          state.sendDisable = false;
          const thisChat = {
            avatar: "0",
            content: sourceData.content + t2("session.chat.up"),
            contentType: sourceData.contentType,
            sequenceId: sourceData.sequenceId,
            timestamp: sourceData.timestamp,
            sender: sourceData.senderType,
            username: sourceData.senderName ?? "System"
          };
          state.chatInfo.push(thisChat);
        } else if (sourceData.messageType === MessageType.CD) {
          const thisChat = {
            avatar: "0",
            content: sourceData.content + t2("session.chat.down"),
            contentType: sourceData.contentType,
            sequenceId: sourceData.sequenceId,
            timestamp: sourceData.timestamp,
            sender: sourceData.senderType,
            username: sourceData.senderName ?? "System"
          };
          state.chatInfo.push(thisChat);
          state.sendDisable = true;
        } else if (sourceData.messageType === MessageType.TEXT) {
          if (sourceData.senderType === SenderType.SYS && sourceData.senderId === SenderIdType.TO_AGENT) {
            return;
          }
          const thisChat = {
            avatar: sourceData.avatar ?? "0",
            content: sourceData.content,
            contentType: sourceData.contentType,
            sequenceId: sourceData.sequenceId,
            timestamp: sourceData.timestamp,
            sender: sourceData.senderType,
            username: sourceData.senderName
          };
          state.chatInfo.push(thisChat);
          console.log(
            "从" + state.currentAgent + "收到消息:" + sourceData.content
          );
        } else if (sourceData.messageType === MessageType.ET) {
          const thisChat = {
            avatar: "0",
            content: t2("chat.terminate"),
            contentType: sourceData.contentType,
            sequenceId: sourceData.sequenceId,
            timestamp: sourceData.timestamp,
            sender: SenderType.SYS,
            username: "System"
          };
          state.chatInfo.push(thisChat);
        }
      });
      ws.on("connect_error", (error) => {
        console.error("❌ Socket.IO 连接错误:", error);
      });
      ws.on("connect_timeout", (timeout) => {
        console.error("⏰ Socket.IO 连接超时:", timeout);
      });
      ws.on("error", (error) => {
        console.error("🚨 Socket.IO 错误:", error);
      });
      ws.on("disconnect", (reason) => {
        console.log("🔌 Socket.IO 断开连接:", reason);
      });
    } catch (error) {
      console.error("连接失败", error);
    }
  };
  const wsSend = async (query) => {
    ws.emit("message", JSON.stringify(query));
  };
  const wsClose = () => {
    ws.disconnect();
  };
  return {
    ...toRefs(state),
    wsConnect,
    wsClose,
    wsSend,
    loadOldChat
  };
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h2 = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t3 % 100;
      return "[" + t3 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m = function(t3, e2, n2) {
      var r2 = String(t3);
      return !r2 || r2.length >= e2 ? t3 : "" + Array(e2 + 1 - r2.length).join(n2) + t3;
    }, v = { s: m, z: function(t3) {
      var e2 = -t3.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t3(e2, n2) {
      if (e2.date() < n2.date())
        return -t3(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c, y: h2, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g = "en", D = {};
    D[g] = M;
    var p2 = "$isDayjsObject", S = function(t3) {
      return t3 instanceof _ || !(!t3 || !t3[p2]);
    }, w = function t3(e2, n2, r2) {
      var i2;
      if (!e2)
        return g;
      if ("string" == typeof e2) {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1)
          return t3(u2[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, O = function(t3, e2) {
      if (S(t3))
        return t3.clone();
      var n2 = "object" == typeof e2 ? e2 : {};
      return n2.date = t3, n2.args = arguments, new _(n2);
    }, b = v;
    b.l = w, b.i = S, b.w = function(t3, e2) {
      return O(t3, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t3) {
        this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
      }
      var m2 = M2.prototype;
      return m2.parse = function(t3) {
        this.$d = function(t4) {
          var e2 = t4.date, n2 = t4.utc;
          if (null === e2)
            return /* @__PURE__ */ new Date(NaN);
          if (b.u(e2))
            return /* @__PURE__ */ new Date();
          if (e2 instanceof Date)
            return new Date(e2);
          if ("string" == typeof e2 && !/Z$/i.test(e2)) {
            var r2 = e2.match($);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t3), this.init();
      }, m2.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m2.$utils = function() {
        return b;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t3, e2) {
        var n2 = O(t3);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t3, e2) {
        return O(t3) < this.startOf(e2);
      }, m2.isBefore = function(t3, e2) {
        return this.endOf(e2) < O(t3);
      }, m2.$g = function(t3, e2, n2) {
        return b.u(t3) ? this[e2] : this.set(n2, t3);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t3, e2) {
        var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t3), l2 = function(t4, e3) {
          var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t4) : new Date(n2.$y, e3, t4), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $2 = function(t4, e3) {
          return b.w(n2.toDate()[t4].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h2:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return $2(v2 + "Hours", 0);
          case u:
            return $2(v2 + "Minutes", 1);
          case s:
            return $2(v2 + "Seconds", 2);
          case i:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m2.$set = function(t3, e2) {
        var n2, o2 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h2] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === c || o2 === h2) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          l2 && this.$d[l2]($2);
        return this.init(), this;
      }, m2.set = function(t3, e2) {
        return this.clone().$set(t3, e2);
      }, m2.get = function(t3) {
        return this[b.p(t3)]();
      }, m2.add = function(r2, f2) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $2 = b.p(f2), y2 = function(t3) {
          var e2 = O(l2);
          return b.w(e2.date(e2.date() + Math.round(t3 * r2)), l2);
        };
        if ($2 === c)
          return this.set(c, this.$M + r2);
        if ($2 === h2)
          return this.set(h2, this.$y + r2);
        if ($2 === a)
          return y2(1);
        if ($2 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t2, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return b.w(m3, this);
      }, m2.subtract = function(t3, e2) {
        return this.add(-1 * t3, e2);
      }, m2.format = function(t3) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || l;
        var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h3 = function(t4, n3, i3, s3) {
          return t4 && (t4[n3] || t4(e2, r2)) || i3[n3].slice(0, s3);
        }, d2 = function(t4) {
          return b.s(s2 % 12 || 12, t4, "0");
        }, $2 = f2 || function(t4, e3, n3) {
          var r3 = t4 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y, function(t4, r3) {
          return r3 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e2.$y).slice(-2);
              case "YYYY":
                return b.s(e2.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return b.s(a2 + 1, 2, "0");
              case "MMM":
                return h3(n2.monthsShort, a2, c2, 3);
              case "MMMM":
                return h3(c2, a2);
              case "D":
                return e2.$D;
              case "DD":
                return b.s(e2.$D, 2, "0");
              case "d":
                return String(e2.$W);
              case "dd":
                return h3(n2.weekdaysMin, e2.$W, o2, 2);
              case "ddd":
                return h3(n2.weekdaysShort, e2.$W, o2, 3);
              case "dddd":
                return o2[e2.$W];
              case "H":
                return String(s2);
              case "HH":
                return b.s(s2, 2, "0");
              case "h":
                return d2(1);
              case "hh":
                return d2(2);
              case "a":
                return $2(s2, u2, true);
              case "A":
                return $2(s2, u2, false);
              case "m":
                return String(u2);
              case "mm":
                return b.s(u2, 2, "0");
              case "s":
                return String(e2.$s);
              case "ss":
                return b.s(e2.$s, 2, "0");
              case "SSS":
                return b.s(e2.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t4) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
          return b.m(y2, m3);
        };
        switch (M3) {
          case h2:
            $2 = D2() / 12;
            break;
          case c:
            $2 = D2();
            break;
          case f:
            $2 = D2() / 3;
            break;
          case o:
            $2 = (g2 - v2) / 6048e5;
            break;
          case a:
            $2 = (g2 - v2) / 864e5;
            break;
          case u:
            $2 = g2 / n;
            break;
          case s:
            $2 = g2 / e;
            break;
          case i:
            $2 = g2 / t2;
            break;
          default:
            $2 = g2;
        }
        return l2 ? $2 : b.a($2);
      }, m2.daysInMonth = function() {
        return this.endOf(c).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t3, e2) {
        if (!t3)
          return this.$L;
        var n2 = this.clone(), r2 = w(t3, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return b.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), k = _.prototype;
    return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h2], ["$D", d]].forEach(function(t3) {
      k[t3[1]] = function(e2) {
        return this.$g(e2, t3[0], t3[1]);
      };
    }), O.extend = function(t3, e2) {
      return t3.$i || (t3(e2, _, O), t3.$i = true), O;
    }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
      return O(1e3 * t3);
    }, O.en = D[g], O.Ls = D, O.p = {}, O;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
function useChatInput() {
  const inputText = ref("");
  const textareaRef = ref();
  const maxHeight = 110;
  const minHeight = 44;
  const cStore = useChatStore();
  const { getUCLang } = useLang();
  const handleKeydown = (event) => {
    if (event.key === "Enter") {
      if (event.shiftKey) {
        return;
      } else {
        event.preventDefault();
        sendMessage();
      }
    }
  };
  const autoResize = () => {
    nextTick$1(() => {
      const textarea = textareaRef.value;
      if (!textarea)
        return;
      textarea.style.height = "auto";
      const newHeight = Math.max(
        Math.min(textarea.scrollHeight, maxHeight),
        minHeight
      );
      textarea.style.height = `${newHeight}px`;
    });
  };
  const sendMessage = () => {
    const message = inputText.value.trim();
    if (!message)
      return;
    const currentTime = dayjs().format("YYYY-MM-DD HH:mm:ss");
    console.log("发送消息:", message);
    const query = {
      chatId: cStore.chatId,
      messageType: MessageType.TEXT,
      language: getUCLang(),
      contentType: "text/plain",
      content: message,
      timestamp: currentTime
    };
    const thisChat = {
      avatar: "1",
      // 网页渠道客户默认头像
      content: message,
      contentType: "text/plain",
      sequenceId: "unknown",
      timestamp: currentTime,
      sender: "custom",
      username: "custom"
    };
    cStore.chatInfo.push(thisChat);
    cStore.wsSend(query);
    inputText.value = "";
    resetHeight();
    return message;
  };
  const resetHeight = () => {
    nextTick$1(() => {
      const textarea = textareaRef.value;
      if (textarea) {
        textarea.style.height = "auto";
      }
    });
  };
  return {
    inputText,
    textareaRef,
    handleKeydown,
    autoResize,
    sendMessage
  };
}
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  name: "CustomerInputCard",
  components: { CustomerInputToolbar, PrimaryButton },
  props: {
    color: {
      type: String,
      default: "#00703d"
    }
  },
  setup() {
    const cStore = useChatStore();
    const sendDisabled = computed(() => cStore.sendDisable);
    const { inputText, textareaRef, handleKeydown, autoResize, sendMessage } = useChatInput();
    const handleSend = () => {
      sendMessage();
    };
    return { cStore, sendDisabled, handleSend, inputText, textareaRef, handleKeydown, autoResize, sendMessage };
  }
});
const CustomerInputCard_vue_vue_type_style_index_0_scoped_ddc49f7e_lang = "";
const _hoisted_1$9 = { class: "chat-input-card" };
const _hoisted_2$3 = ["placeholder"];
const _hoisted_3$2 = { class: "send-button-container" };
const _hoisted_4$1 = { class: "w-400 s-12 l-20 text-4" };
const _hoisted_5 = {
  key: 0,
  class: "disable-mask"
};
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CustomerInputToolbar = resolveComponent("CustomerInputToolbar");
  const _component_PrimaryButton = resolveComponent("PrimaryButton");
  return openBlock(), createElementBlock("div", _hoisted_1$9, [
    createVNode(_component_CustomerInputToolbar),
    withDirectives(createBaseVNode("textarea", {
      ref: "textareaRef",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputText = $event),
      onKeydown: _cache[1] || (_cache[1] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args)),
      onInput: _cache[2] || (_cache[2] = (...args) => _ctx.autoResize && _ctx.autoResize(...args)),
      placeholder: _ctx.$t("session.chat.button.placeholder"),
      class: "chat-textarea"
    }, null, 40, _hoisted_2$3), [
      [vModelText, _ctx.inputText]
    ]),
    createBaseVNode("div", _hoisted_3$2, [
      createBaseVNode("span", _hoisted_4$1, toDisplayString(_ctx.$t("session.chat.button.lineBreak")), 1),
      createVNode(_component_PrimaryButton, {
        size: "small",
        label: "common.send",
        onClick: _ctx.handleSend,
        "force-color": _ctx.color
      }, null, 8, ["onClick", "force-color"])
    ]),
    _ctx.sendDisabled || _ctx.cStore.chatStatus === 3 ? (openBlock(), createElementBlock("div", _hoisted_5)) : createCommentVNode("", true)
  ]);
}
const CustomerInputCard = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$8], ["__scopeId", "data-v-ddc49f7e"]]);
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  name: "TimeStamp",
  props: {
    timestamp: {
      type: String,
      default: "2025-01-01 00:00:00"
    }
  },
  setup(props) {
    const month = computed(() => props.timestamp.split("-")[1]);
    const day = computed(() => props.timestamp.split(" ")[0].split("-")[2]);
    const hour = computed(() => props.timestamp.split(" ")[1].split(":")[0]);
    const min = computed(() => props.timestamp.split(":")[1]);
    return { month, day, hour, min };
  }
});
const TimeStamp_vue_vue_type_style_index_0_scoped_f8d6588a_lang = "";
const _hoisted_1$8 = { class: "w-400 s-10 l-10 text-3 time-stamp" };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", _hoisted_1$8, toDisplayString(_ctx.$t("session.chat.time", { month: _ctx.month, day: _ctx.day, hour: _ctx.hour, minute: _ctx.min })), 1);
}
const TimeStamp = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$7], ["__scopeId", "data-v-f8d6588a"]]);
const CDN_URL = {}.CDN_URL;
const getImgUrl = (url2, imgType = "") => {
  return `${CDN_URL}${url2}${imgType !== "" ? "." : ""}${imgType}`;
};
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  name: "AvatarImg",
  props: {
    avatar: {
      type: String,
      default: "avatar-1"
    }
  },
  setup() {
    return { getImgUrl };
  }
});
const _hoisted_1$7 = ["src"];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("img", {
    src: _ctx.getImgUrl(`avatar/${_ctx.avatar}`, "png")
  }, null, 8, _hoisted_1$7);
}
const AvatarImg = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$6]]);
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  name: "ChannelImg",
  props: {
    avatar: {
      type: Number,
      default: 1
    }
  },
  setup() {
    return { getImgUrl };
  }
});
const _hoisted_1$6 = ["src"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("img", {
    src: _ctx.getImgUrl(`channel/${_ctx.avatar === 1 ? "none" : "telegram"}`, "png")
  }, null, 8, _hoisted_1$6);
}
const ChannelImg = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$5]]);
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  name: "ChannelAvatar",
  props: {
    id: {
      type: String,
      default: "1"
    },
    channel: {
      type: Number,
      default: 1
    }
  },
  setup() {
    const getAvatar = (id) => {
      return h(AvatarImg, {
        avatar: `avatar-${id ? id : "1"}`
      });
    };
    const getChannel = (id) => {
      return h(ChannelImg, {
        avatar: id
      });
    };
    return { getAvatar, getChannel };
  }
});
const ChannelAvatar_vue_vue_type_style_index_0_scoped_6e21cf61_lang = "";
const _hoisted_1$5 = { class: "channel-avatar" };
const _hoisted_2$2 = { class: "channel-avatar-content" };
const _hoisted_3$1 = {
  key: 0,
  class: "channel-avatar-badge"
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    createBaseVNode("div", _hoisted_2$2, [
      (openBlock(), createBlock(resolveDynamicComponent(_ctx.getAvatar(_ctx.id)), { style: { width: "40px", height: "40px" } }))
    ]),
    _ctx.channel !== 1 ? (openBlock(), createElementBlock("div", _hoisted_3$1, [
      (openBlock(), createBlock(resolveDynamicComponent(_ctx.getChannel(_ctx.channel)), { style: { width: "10px", height: "10px" } }))
    ])) : createCommentVNode("", true)
  ]);
}
const ChannelAvatar = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$4], ["__scopeId", "data-v-6e21cf61"]]);
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  name: "CustomerContent",
  components: { ChannelAvatar, TimeStamp },
  props: {
    username: {
      type: String,
      default: "username"
    },
    avatar: {
      type: String,
      default: "0"
    },
    text: {
      type: String,
      default: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore"
    },
    timestamp: {
      type: String,
      default: "2025-01-01 00:00:00"
    },
    isMe: {
      type: Boolean,
      default: false
    },
    isFirst: {
      type: Boolean,
      default: true
    },
    bubbleColor: {
      type: String,
      default: "#00703d"
    }
  },
  setup(props) {
    const color2 = computed(() => props.bubbleColor + "19");
    return { color: color2 };
  }
});
const CustomerContent_vue_vue_type_style_index_0_scoped_d1e6fcc1_lang = "";
const _hoisted_1$4 = { class: "chat-content" };
const _hoisted_2$1 = { class: "main-chat-wrapper" };
const _hoisted_3 = {
  key: 0,
  class: "w-500 s-12 l-20 username-label"
};
const _hoisted_4 = {
  class: "w-400 s-14 l-20",
  style: { "white-space": "pre-line" }
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TimeStamp = resolveComponent("TimeStamp");
  const _component_ChannelAvatar = resolveComponent("ChannelAvatar");
  return openBlock(), createElementBlock("div", _hoisted_1$4, [
    _ctx.isFirst ? (openBlock(), createBlock(_component_TimeStamp, {
      key: 0,
      timestamp: _ctx.timestamp
    }, null, 8, ["timestamp"])) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: normalizeClass(["main-chat", { "my-chat": _ctx.isMe, "first-chat": _ctx.isFirst }])
    }, [
      _ctx.isFirst ? (openBlock(), createBlock(_component_ChannelAvatar, {
        key: 0,
        id: _ctx.avatar
      }, null, 8, ["id"])) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_2$1, [
        _ctx.isFirst && !_ctx.isMe ? (openBlock(), createElementBlock("span", _hoisted_3, toDisplayString(_ctx.username), 1)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(["main-chat-bubble", { "my-chat": _ctx.isMe, "first-chat": _ctx.isFirst }]),
          style: normalizeStyle({ "--bubble-color": _ctx.color })
        }, [
          createBaseVNode("span", _hoisted_4, toDisplayString(_ctx.text), 1)
        ], 6)
      ])
    ], 2)
  ]);
}
const CustomerContent = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$3], ["__scopeId", "data-v-d1e6fcc1"]]);
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  name: "CustomContainer",
  components: { CustomerContent },
  props: {
    color: {
      type: String,
      default: "#00703d"
    }
  },
  setup() {
    const cStore = useChatStore();
    const chatRef = ref();
    const currentChatBox = computed(() => {
      const chats = cStore.chatInfo;
      return chats.map((chat, index) => {
        const previousChat = index > 0 ? chats[index - 1] : null;
        return {
          ...chat,
          isFirst: !previousChat || chat.sender !== previousChat.sender,
          isMe: chat.sender === "custom"
        };
      });
    });
    const scrollToBottom = () => {
      const scrollContainer = chatRef.value;
      if (scrollContainer) {
        scrollContainer.scrollTo({
          top: scrollContainer.scrollHeight,
          behavior: "smooth"
        });
      }
    };
    watch(() => currentChatBox.value, () => {
      nextTick$1(() => {
        scrollToBottom();
      });
    });
    onMounted(() => {
      nextTick$1(() => {
        scrollToBottom();
      });
    });
    return { currentChatBox, chatRef };
  }
});
const CustomerContainer_vue_vue_type_style_index_0_scoped_0bd73be3_lang = "";
const _hoisted_1$3 = {
  class: "chat-container",
  ref: "chatRef"
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CustomerContent = resolveComponent("CustomerContent");
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    _cache[0] || (_cache[0] = createBaseVNode("div", null, null, -1)),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.currentChatBox, (chat) => {
      return openBlock(), createBlock(_component_CustomerContent, {
        key: chat.sequenceId,
        username: chat.username,
        avatar: chat.avatar,
        text: chat.content,
        timestamp: chat.timestamp,
        "is-first": chat.isFirst,
        "is-me": chat.isMe,
        "bubble-color": _ctx.color
      }, null, 8, ["username", "avatar", "text", "timestamp", "is-first", "is-me", "bubble-color"]);
    }), 128))
  ], 512);
}
const CustomerContainer = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$2], ["__scopeId", "data-v-0bd73be3"]]);
const _hoisted_1$2 = ["width", "height"];
const _hoisted_2 = ["stroke"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "LineArrow",
  props: {
    size: {
      type: String,
      default: "16"
    },
    color: {
      type: String,
      default: "#696D69"
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("svg", {
        width: __props.size,
        height: __props.size,
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        createBaseVNode("path", {
          d: "M12 6L8 10L4 6",
          stroke: __props.color,
          "stroke-width": "1.4",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, 8, _hoisted_2)
      ], 8, _hoisted_1$2);
    };
  }
});
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  name: "ChatDialog",
  components: { LineArrow: _sfc_main$2, CustomerInputCard, CustomerContainer },
  props: {
    props: {
      type: Object,
      required: true
    },
    onClose: {
      type: Function,
      default: () => {
      }
    }
  },
  setup(props) {
    return { getImgUrl };
  }
});
const ChatDialog_vue_vue_type_style_index_0_scoped_7366b548_lang = "";
const _hoisted_1$1 = ["src"];
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LineArrow = resolveComponent("LineArrow");
  const _component_CustomerContainer = resolveComponent("CustomerContainer");
  const _component_CustomerInputCard = resolveComponent("CustomerInputCard");
  return openBlock(), createElementBlock("div", {
    class: "dialog-style",
    style: normalizeStyle({ "--bg-color": _ctx.props.boxColor, "--width": `${_ctx.props.boxWidth}px`, "--height": `${_ctx.props.boxHeight}px` })
  }, [
    createBaseVNode("div", {
      class: "dialog-header",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.onClose())
    }, [
      createBaseVNode("img", {
        src: _ctx.getImgUrl(_ctx.props.logo),
        class: "logo-image"
      }, null, 8, _hoisted_1$1),
      createVNode(_component_LineArrow, {
        color: "white",
        size: "24"
      })
    ]),
    createVNode(_component_CustomerContainer, {
      color: _ctx.props.boxColor
    }, null, 8, ["color"]),
    createVNode(_component_CustomerInputCard, {
      color: _ctx.props.boxColor
    }, null, 8, ["color"])
  ], 4);
}
const ChatDialog = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-7366b548"]]);
var EntranceType = /* @__PURE__ */ ((EntranceType2) => {
  EntranceType2[EntranceType2["INVISIBLE"] = 0] = "INVISIBLE";
  EntranceType2[EntranceType2["RECT"] = 1] = "RECT";
  EntranceType2[EntranceType2["SQUARE"] = 2] = "SQUARE";
  EntranceType2[EntranceType2["CIRCLE"] = 3] = "CIRCLE";
  return EntranceType2;
})(EntranceType || {});
var EntranceLocationType = /* @__PURE__ */ ((EntranceLocationType2) => {
  EntranceLocationType2[EntranceLocationType2["TOPLEFT"] = 1] = "TOPLEFT";
  EntranceLocationType2[EntranceLocationType2["TOPRIGHT"] = 2] = "TOPRIGHT";
  EntranceLocationType2[EntranceLocationType2["MIDDLELEFT"] = 3] = "MIDDLELEFT";
  EntranceLocationType2[EntranceLocationType2["MIDDLERIGHT"] = 4] = "MIDDLERIGHT";
  EntranceLocationType2[EntranceLocationType2["BOTTOMLEFT"] = 5] = "BOTTOMLEFT";
  EntranceLocationType2[EntranceLocationType2["BOTTOMRIGHT"] = 6] = "BOTTOMRIGHT";
  return EntranceLocationType2;
})(EntranceLocationType || {});
function useWrapperSize(wrapperRef) {
  const wrapperHeight = ref(0);
  const wrapperWidth = ref(0);
  let resizeObserver = null;
  onMounted(() => {
    if (wrapperRef.value) {
      resizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          const height = entry.contentRect.height;
          const width = entry.contentRect.width;
          wrapperHeight.value = height;
          wrapperWidth.value = width;
        }
      });
      resizeObserver.observe(wrapperRef.value);
    }
  });
  onUnmounted(() => {
    if (resizeObserver) {
      console.log("wrapper高度监听断开");
      resizeObserver.disconnect();
    }
  });
  return {
    wrapperHeight,
    wrapperWidth
  };
}
const BASE = "http://localhost:9999";
async function makeRequest(config) {
  const { method, endpoint, channelId, body, urlParams } = config;
  const token = localStorage.getItem("__ABOT_ACCESS_TOKEN__");
  let url2 = BASE + endpoint;
  if (urlParams) {
    url2 += urlParams;
  }
  const headers = {
    "Content-Type": "application/json"
  };
  if (channelId) {
    headers["Authorization"] = `Bearer ${token}`;
    headers["TENANT-ID"] = channelId;
    headers["Accept-Language"] = "zh_cn";
  }
  const requestOptions = {
    method,
    headers
  };
  if (method === "POST" && body) {
    requestOptions.body = JSON.stringify(body);
  }
  const response = await fetch(url2, requestOptions);
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
  return response;
}
async function getStyleSetting(channelId) {
  const urlParams = channelId ? `/${channelId}?_t=${(/* @__PURE__ */ new Date()).getTime()}` : "";
  return makeRequest({
    method: "GET",
    endpoint: "/merchant/channel/website",
    channelId,
    urlParams
  });
}
async function getChatHistory(chatId, channelId) {
  return makeRequest({
    method: "POST",
    endpoint: "/merchant/chats/messages",
    channelId,
    body: { chatId }
  });
}
async function getLatestChat(channelId) {
  return makeRequest({
    method: "GET",
    endpoint: "/merchant/chats/getLatestChat",
    channelId
  });
}
const _sfc_main = /* @__PURE__ */ defineComponent({
  name: "CustomerWindow",
  components: { ChatDialog },
  props: {
    config: {
      type: Object,
      required: true
    },
    containerId: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const { getUCLang } = useLang();
    const wrapperRef = ref();
    const cStore = useChatStore();
    const { wrapperHeight, wrapperWidth } = useWrapperSize(wrapperRef);
    const dialogOpen = ref(false);
    const entranceProps = ref({
      id: "",
      channelId: props.config.configId,
      channelName: "",
      remark: "",
      announcementFlag: false,
      announcement: {
        ["zh-CN"]: ""
      },
      accessCode: "",
      linkCode: "",
      entranceType: 0,
      width: 44,
      height: 128,
      color: "#00703d",
      location: 1,
      buttonText: {
        ["en-US"]: "Live Chat",
        ["zh-TW"]: "在線客服",
        ["zh-CN"]: "在线客服"
      },
      delay: "3000",
      boxColor: "#00703d",
      logo: "/logo/abot-logo-white.png",
      agentLogo: "/avatar/avatar-0.png",
      boxWidth: 250,
      boxHeight: 560
    });
    onMounted(async () => {
      cStore.channelId = props.config.configId ?? "0";
      const response = await getStyleSetting(props.config.configId);
      const data = await response.json();
      entranceProps.value = data.data;
      console.log("配置获取成功:", entranceProps.value);
      if (cStore.chatId === "0") {
        const latestChat = await getLatestChat(props.config.configId);
        const latestChatData = await latestChat.json();
        console.log("聊天信息获取成功:", latestChatData.data);
        if (latestChatData.data !== null) {
          cStore.chatId = latestChatData.data.chatId;
          cStore.chatStatus = latestChatData.data.status;
          cStore.sendDisable = latestChatData.data.status === 0 ? true : false;
        }
      }
      if (cStore.chatId !== "0") {
        console.log("读到chatId:", cStore.chatId);
        const history = await getChatHistory(cStore.chatId, props.config.configId);
        const historyData = await history.json();
        console.log(historyData.data);
        cStore.loadOldChat(historyData.data);
      }
      await cStore.wsConnect();
    });
    onUnmounted(() => {
      cStore.wsClose();
    });
    const noText = computed(() => {
      return entranceProps.value.width === 44 && entranceProps.value.height === 44;
    });
    const posTop = computed(() => {
      const position = entranceProps.value.location;
      if (position === EntranceLocationType.TOPLEFT || position === EntranceLocationType.TOPRIGHT) {
        return "0px";
      } else if (position === EntranceLocationType.MIDDLELEFT || position === EntranceLocationType.MIDDLERIGHT) {
        return `calc(${wrapperHeight.value / 2}px - var(--height) / 2 - 20px)`;
      } else {
        return `calc(${wrapperHeight.value}px - var(--height) - 40px)`;
      }
    });
    const posLeft = computed(() => {
      const position = entranceProps.value.location;
      if (position === EntranceLocationType.TOPRIGHT || position === EntranceLocationType.MIDDLERIGHT || position === EntranceLocationType.BOTTOMRIGHT) {
        return `calc(${wrapperWidth.value}px - var(--width) - 40px)`;
      } else {
        return "0px";
      }
    });
    const showLabel = computed(() => entranceProps.value.buttonText[getUCLang()]);
    const handleDialogOpen = () => {
      dialogOpen.value = true;
    };
    return {
      getImgUrl,
      getUCLang,
      showLabel,
      noText,
      entranceProps,
      EntranceType,
      posTop,
      posLeft,
      wrapperRef,
      dialogOpen,
      handleDialogOpen
    };
  }
});
const CustomerWindow_vue_vue_type_style_index_0_scoped_83e11129_lang = "";
const _hoisted_1 = ["src"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChatDialog = resolveComponent("ChatDialog");
  return openBlock(), createElementBlock("div", {
    ref: "wrapperRef",
    class: "style-wrapper",
    style: normalizeStyle({ "--lang-spacing": _ctx.getUCLang() === "en-US" ? "0px" : "6px" })
  }, [
    !_ctx.dialogOpen ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["entrance-style", {
        "entrance-type-rect": _ctx.entranceProps.entranceType === _ctx.EntranceType.RECT,
        "entrance-type-square": _ctx.entranceProps.entranceType === _ctx.EntranceType.SQUARE,
        "entrance-type-circle": _ctx.entranceProps.entranceType === _ctx.EntranceType.CIRCLE,
        "entrance-type-none": _ctx.entranceProps.entranceType === _ctx.EntranceType.INVISIBLE
      }]),
      style: normalizeStyle({
        "--width": `${_ctx.entranceProps.width}px`,
        "--height": `${_ctx.entranceProps.height}px`,
        "--bg-color": `${_ctx.entranceProps.color}`,
        "--top": `${_ctx.posTop}`,
        "--bottom": ``,
        "--left": `${_ctx.posLeft}`,
        "--right": ``
      }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleDialogOpen && _ctx.handleDialogOpen(...args))
    }, [
      createBaseVNode("img", {
        src: _ctx.getImgUrl("logo/white-logo", "png"),
        style: { height: "20px", width: "20px" }
      }, null, 8, _hoisted_1),
      !_ctx.noText ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: normalizeClass(["entrance-label", {
          "entrance-label-rect": _ctx.entranceProps.entranceType === _ctx.EntranceType.RECT,
          "entrance-label-square": _ctx.entranceProps.entranceType === _ctx.EntranceType.SQUARE,
          "entrance-label-circle": _ctx.entranceProps.entranceType === _ctx.EntranceType.CIRCLE
        }])
      }, toDisplayString(_ctx.showLabel), 3)) : createCommentVNode("", true)
    ], 6)) : createCommentVNode("", true),
    _ctx.dialogOpen ? (openBlock(), createBlock(_component_ChatDialog, {
      key: 1,
      onClose: _cache[1] || (_cache[1] = ($event) => _ctx.dialogOpen = false),
      props: _ctx.entranceProps
    }, null, 8, ["props"])) : createCommentVNode("", true)
  ], 4);
}
const CustomerWindow = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-83e11129"]]);
const font = "";
const color = "";
window.useI18n = useI18n;
async function initABot() {
  console.log("🚀 ABot开始初始化");
  let { configId } = getConfigFromURL();
  console.log("📝 获取到Config ID:", configId);
  const containerId = `abot-container-${configId}`;
  createContainer(containerId);
  const userConfig = await fetchUserConfig(configId);
  const store = createPinia();
  const app = createApp(CustomerWindow, {
    config: userConfig,
    containerId
  });
  app.use(store);
  try {
    app.use(i18nPlugin);
    console.log("✅ i18n 安装成功");
  } catch (error) {
    console.error("❌ i18n 安装失败:", error);
  }
  app.mount(`#${containerId}`);
  console.log("✅ ABot初始化完成");
}
function getConfigFromURL() {
  const scripts = document.getElementsByTagName("script");
  for (let script of scripts) {
    if (script.src && (script.src.includes("index.js") || script.src.includes("widget.js"))) {
      try {
        const url2 = new URL(script.src);
        const configId = url2.searchParams.get("config");
        return { configId };
      } catch (error) {
        console.warn("URL解析失败，使用默认config");
        return "default";
      }
    }
  }
  return "default";
}
async function fetchUserConfig(configId) {
  try {
    console.log("🌐 从服务器获取配置...", configId);
    if (localStorage.getItem("__ABOT_PLUGIN_USERNAME") !== void 0) {
    }
    const username = getOrCreateUserUUID();
    localStorage.setItem("__ABOT_PLUGIN_USERNAME__", username);
    const API_BASE_URL = "http://localhost:9999/auth/oauth2/token";
    const API_ENDPOINT = `${API_BASE_URL}?username=${username}&password=123&grant_type=password&scope=server`;
    const headers = {
      "Content-Type": "application/json"
    };
    if (configId) {
      headers["Authorization"] = `Basic Y2hhdDpjMTIzNDU2`;
      headers["TENANT-ID"] = configId;
      headers["Accept-Language"] = "zh_cn";
    }
    console.log("📡 请求配置:", {
      url: API_ENDPOINT,
      headers
    });
    if (!localStorage.getItem("__ABOT_ACCESS_TOKEN__")) {
      const response = await fetch(API_ENDPOINT, {
        method: "POST",
        headers
      });
      if (!response.ok) {
        console.error("something wrong here");
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const configData = await response.json();
      console.log("✅ 配置获取成功:", configData);
      localStorage.setItem("__ABOT_ACCESS_TOKEN__", configData.access_token);
      localStorage.setItem("__ABOT_CHANNEL__", configId);
    }
    return getDefaultConfig(configId);
  } catch (error) {
    console.warn("❌ 配置获取失败，使用默认配置:", error.message);
    return getDefaultConfig(configId);
  }
}
function getDefaultConfig(configId) {
  return {
    configId,
    primaryColor: "#1890ff"
  };
}
function createContainer(containerId) {
  if (document.getElementById(containerId))
    return;
  const container = document.createElement("div");
  container.id = containerId;
  document.body.appendChild(container);
  console.log("📦 创建容器:", containerId);
}
window.ABot = {
  init: function(userConfig) {
    const configId = userConfig.configId || "manual";
    const containerId = `abot-container-${configId}`;
    createContainer(containerId);
    const app = createApp(CustomerWindow, {
      config: { ...userConfig, configId },
      containerId
    });
    app.mount(`#${containerId}`);
    console.log("✅ 手动初始化完成");
  }
};
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", initABot);
}
//# sourceMappingURL=widget.js.map
